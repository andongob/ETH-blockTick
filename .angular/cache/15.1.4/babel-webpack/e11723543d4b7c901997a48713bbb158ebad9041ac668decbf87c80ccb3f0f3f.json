{"ast":null,"code":"var assert = require('assert');\nvar BigInteger = require('bigi');\nvar Point = require('./point');\nfunction Curve(p, a, b, Gx, Gy, n, h) {\n  this.p = p;\n  this.a = a;\n  this.b = b;\n  this.G = Point.fromAffine(this, Gx, Gy);\n  this.n = n;\n  this.h = h;\n  this.infinity = new Point(this, null, null, BigInteger.ZERO);\n\n  // result caching\n  this.pOverFour = p.add(BigInteger.ONE).shiftRight(2);\n\n  // determine size of p in bytes\n  this.pLength = Math.floor((this.p.bitLength() + 7) / 8);\n}\nCurve.prototype.pointFromX = function (isOdd, x) {\n  var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p);\n  var beta = alpha.modPow(this.pOverFour, this.p); // XXX: not compatible with all curves\n\n  var y = beta;\n  if (beta.isEven() ^ !isOdd) {\n    y = this.p.subtract(y); // -y % p\n  }\n\n  return Point.fromAffine(this, x, y);\n};\nCurve.prototype.isInfinity = function (Q) {\n  if (Q === this.infinity) return true;\n  return Q.z.signum() === 0 && Q.y.signum() !== 0;\n};\nCurve.prototype.isOnCurve = function (Q) {\n  if (this.isInfinity(Q)) return true;\n  var x = Q.affineX;\n  var y = Q.affineY;\n  var a = this.a;\n  var b = this.b;\n  var p = this.p;\n\n  // Check that xQ and yQ are integers in the interval [0, p - 1]\n  if (x.signum() < 0 || x.compareTo(p) >= 0) return false;\n  if (y.signum() < 0 || y.compareTo(p) >= 0) return false;\n\n  // and check that y^2 = x^3 + ax + b (mod p)\n  var lhs = y.square().mod(p);\n  var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p);\n  return lhs.equals(rhs);\n};\n\n/**\n * Validate an elliptic curve point.\n *\n * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive\n */\nCurve.prototype.validate = function (Q) {\n  // Check Q != O\n  assert(!this.isInfinity(Q), 'Point is at infinity');\n  assert(this.isOnCurve(Q), 'Point is not on the curve');\n\n  // Check nQ = O (where Q is a scalar multiple of G)\n  var nQ = Q.multiply(this.n);\n  assert(this.isInfinity(nQ), 'Point is not a scalar multiple of G');\n  return true;\n};\nmodule.exports = Curve;","map":{"version":3,"names":["assert","require","BigInteger","Point","Curve","p","a","b","Gx","Gy","n","h","G","fromAffine","infinity","ZERO","pOverFour","add","ONE","shiftRight","pLength","Math","floor","bitLength","prototype","pointFromX","isOdd","x","alpha","pow","multiply","mod","beta","modPow","y","isEven","subtract","isInfinity","Q","z","signum","isOnCurve","affineX","affineY","compareTo","lhs","square","rhs","equals","validate","nQ","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFG - Enginering/BLOCKTICK/blocktick_dApp/node_modules/ecurve/lib/curve.js"],"sourcesContent":["var assert = require('assert')\nvar BigInteger = require('bigi')\n\nvar Point = require('./point')\n\nfunction Curve (p, a, b, Gx, Gy, n, h) {\n  this.p = p\n  this.a = a\n  this.b = b\n  this.G = Point.fromAffine(this, Gx, Gy)\n  this.n = n\n  this.h = h\n\n  this.infinity = new Point(this, null, null, BigInteger.ZERO)\n\n  // result caching\n  this.pOverFour = p.add(BigInteger.ONE).shiftRight(2)\n\n  // determine size of p in bytes\n  this.pLength = Math.floor((this.p.bitLength() + 7) / 8)\n}\n\nCurve.prototype.pointFromX = function (isOdd, x) {\n  var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p)\n  var beta = alpha.modPow(this.pOverFour, this.p) // XXX: not compatible with all curves\n\n  var y = beta\n  if (beta.isEven() ^ !isOdd) {\n    y = this.p.subtract(y) // -y % p\n  }\n\n  return Point.fromAffine(this, x, y)\n}\n\nCurve.prototype.isInfinity = function (Q) {\n  if (Q === this.infinity) return true\n\n  return Q.z.signum() === 0 && Q.y.signum() !== 0\n}\n\nCurve.prototype.isOnCurve = function (Q) {\n  if (this.isInfinity(Q)) return true\n\n  var x = Q.affineX\n  var y = Q.affineY\n  var a = this.a\n  var b = this.b\n  var p = this.p\n\n  // Check that xQ and yQ are integers in the interval [0, p - 1]\n  if (x.signum() < 0 || x.compareTo(p) >= 0) return false\n  if (y.signum() < 0 || y.compareTo(p) >= 0) return false\n\n  // and check that y^2 = x^3 + ax + b (mod p)\n  var lhs = y.square().mod(p)\n  var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p)\n  return lhs.equals(rhs)\n}\n\n/**\n * Validate an elliptic curve point.\n *\n * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive\n */\nCurve.prototype.validate = function (Q) {\n  // Check Q != O\n  assert(!this.isInfinity(Q), 'Point is at infinity')\n  assert(this.isOnCurve(Q), 'Point is not on the curve')\n\n  // Check nQ = O (where Q is a scalar multiple of G)\n  var nQ = Q.multiply(this.n)\n  assert(this.isInfinity(nQ), 'Point is not a scalar multiple of G')\n\n  return true\n}\n\nmodule.exports = Curve\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}