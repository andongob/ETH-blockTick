{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;\nvar assert = require('assert');\nvar ethjsUtil = require('ethjs-util');\nvar secp256k1 = require('./secp256k1v3-adapter');\nvar BN = require(\"bn.js\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\n/**\r\n * Returns a zero address.\r\n */\nexports.zeroAddress = function () {\n  var addressLength = 20;\n  var addr = bytes_1.zeros(addressLength);\n  return bytes_1.bufferToHex(addr);\n};\n/**\r\n * Checks if the address is a valid. Accepts checksummed addresses too.\r\n */\nexports.isValidAddress = function (address) {\n  return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\r\n * Checks if a given address is a zero address.\r\n */\nexports.isZeroAddress = function (address) {\n  var zeroAddr = exports.zeroAddress();\n  return zeroAddr === bytes_1.addHexPrefix(address);\n};\n/**\r\n * Returns a checksummed address.\r\n *\r\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\r\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\r\n * For more details, consult EIP-1191.\r\n *\r\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\r\n * used variation in Ethereum was without the chainId. This may change in the future.\r\n */\nexports.toChecksumAddress = function (address, eip1191ChainId) {\n  address = ethjsUtil.stripHexPrefix(address).toLowerCase();\n  var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\n  var hash = hash_1.keccak(prefix + address).toString('hex');\n  var ret = '0x';\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return ret;\n};\n/**\r\n * Checks if the address is a valid checksummed address.\r\n *\r\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\r\n */\nexports.isValidChecksumAddress = function (address, eip1191ChainId) {\n  return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;\n};\n/**\r\n * Generates an address of a newly created contract.\r\n * @param from The address which is creating this new address\r\n * @param nonce The nonce of the from account\r\n */\nexports.generateAddress = function (from, nonce) {\n  from = bytes_1.toBuffer(from);\n  var nonceBN = new BN(nonce);\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return hash_1.rlphash([from, null]).slice(-20);\n  }\n  // Only take the lower 160bits of the hash\n  return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\r\n * Generates an address for a contract created using CREATE2.\r\n * @param from The address which is creating this new address\r\n * @param salt A salt\r\n * @param initCode The init code of the contract being created\r\n */\nexports.generateAddress2 = function (from, salt, initCode) {\n  var fromBuf = bytes_1.toBuffer(from);\n  var saltBuf = bytes_1.toBuffer(salt);\n  var initCodeBuf = bytes_1.toBuffer(initCode);\n  assert(fromBuf.length === 20);\n  assert(saltBuf.length === 32);\n  var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));\n  return address.slice(-20);\n};\n/**\r\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\r\n */\nexports.isPrecompiled = function (address) {\n  var a = bytes_1.unpad(address);\n  return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\r\n * Checks if the private key satisfies the rules of the curve secp256k1.\r\n */\nexports.isValidPrivate = function (privateKey) {\n  return secp256k1.privateKeyVerify(privateKey);\n};\n/**\r\n * Checks if the public key satisfies the rules of the curve secp256k1\r\n * and the requirements of Ethereum.\r\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\r\n * @param sanitize Accept public keys in other formats\r\n */\nexports.isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n  if (!sanitize) {\n    return false;\n  }\n  return secp256k1.publicKeyVerify(publicKey);\n};\n/**\r\n * Returns the ethereum address of a given public key.\r\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\r\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\r\n * @param sanitize Accept public keys in other formats\r\n */\nexports.pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  pubKey = bytes_1.toBuffer(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n  }\n  assert(pubKey.length === 64);\n  // Only take the lower 160bits of the hash\n  return hash_1.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\r\n * Returns the ethereum address of a given private key.\r\n * @param privateKey A private key must be 256 bits wide\r\n */\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\r\n * Returns the ethereum public key of a given private key.\r\n * @param privateKey A private key must be 256 bits wide\r\n */\nexports.privateToPublic = function (privateKey) {\n  privateKey = bytes_1.toBuffer(privateKey);\n  // skip the type flag and use the X, Y points\n  return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\r\n * Converts a public key to the Ethereum format.\r\n */\nexports.importPublic = function (publicKey) {\n  publicKey = bytes_1.toBuffer(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n  }\n  return publicKey;\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","importPublic","privateToPublic","privateToAddress","publicToAddress","pubToAddress","isValidPublic","isValidPrivate","isPrecompiled","generateAddress2","generateAddress","isValidChecksumAddress","toChecksumAddress","isZeroAddress","isValidAddress","zeroAddress","assert","require","ethjsUtil","secp256k1","BN","bytes_1","hash_1","addressLength","addr","zeros","bufferToHex","address","test","zeroAddr","addHexPrefix","eip1191ChainId","stripHexPrefix","toLowerCase","prefix","undefined","toString","hash","keccak","ret","i","length","parseInt","toUpperCase","from","nonce","toBuffer","nonceBN","isZero","rlphash","slice","Buffer","toArray","salt","initCode","fromBuf","saltBuf","initCodeBuf","keccak256","concat","a","unpad","privateKey","privateKeyVerify","publicKey","sanitize","publicKeyVerify","pubKey","publicKeyConvert","publicKeyCreate"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/account.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;\r\nvar assert = require('assert');\r\nvar ethjsUtil = require('ethjs-util');\r\nvar secp256k1 = require('./secp256k1v3-adapter');\r\nvar BN = require(\"bn.js\");\r\nvar bytes_1 = require(\"./bytes\");\r\nvar hash_1 = require(\"./hash\");\r\n/**\r\n * Returns a zero address.\r\n */\r\nexports.zeroAddress = function () {\r\n    var addressLength = 20;\r\n    var addr = bytes_1.zeros(addressLength);\r\n    return bytes_1.bufferToHex(addr);\r\n};\r\n/**\r\n * Checks if the address is a valid. Accepts checksummed addresses too.\r\n */\r\nexports.isValidAddress = function (address) {\r\n    return /^0x[0-9a-fA-F]{40}$/.test(address);\r\n};\r\n/**\r\n * Checks if a given address is a zero address.\r\n */\r\nexports.isZeroAddress = function (address) {\r\n    var zeroAddr = exports.zeroAddress();\r\n    return zeroAddr === bytes_1.addHexPrefix(address);\r\n};\r\n/**\r\n * Returns a checksummed address.\r\n *\r\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\r\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\r\n * For more details, consult EIP-1191.\r\n *\r\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\r\n * used variation in Ethereum was without the chainId. This may change in the future.\r\n */\r\nexports.toChecksumAddress = function (address, eip1191ChainId) {\r\n    address = ethjsUtil.stripHexPrefix(address).toLowerCase();\r\n    var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\r\n    var hash = hash_1.keccak(prefix + address).toString('hex');\r\n    var ret = '0x';\r\n    for (var i = 0; i < address.length; i++) {\r\n        if (parseInt(hash[i], 16) >= 8) {\r\n            ret += address[i].toUpperCase();\r\n        }\r\n        else {\r\n            ret += address[i];\r\n        }\r\n    }\r\n    return ret;\r\n};\r\n/**\r\n * Checks if the address is a valid checksummed address.\r\n *\r\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\r\n */\r\nexports.isValidChecksumAddress = function (address, eip1191ChainId) {\r\n    return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;\r\n};\r\n/**\r\n * Generates an address of a newly created contract.\r\n * @param from The address which is creating this new address\r\n * @param nonce The nonce of the from account\r\n */\r\nexports.generateAddress = function (from, nonce) {\r\n    from = bytes_1.toBuffer(from);\r\n    var nonceBN = new BN(nonce);\r\n    if (nonceBN.isZero()) {\r\n        // in RLP we want to encode null in the case of zero nonce\r\n        // read the RLP documentation for an answer if you dare\r\n        return hash_1.rlphash([from, null]).slice(-20);\r\n    }\r\n    // Only take the lower 160bits of the hash\r\n    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\r\n};\r\n/**\r\n * Generates an address for a contract created using CREATE2.\r\n * @param from The address which is creating this new address\r\n * @param salt A salt\r\n * @param initCode The init code of the contract being created\r\n */\r\nexports.generateAddress2 = function (from, salt, initCode) {\r\n    var fromBuf = bytes_1.toBuffer(from);\r\n    var saltBuf = bytes_1.toBuffer(salt);\r\n    var initCodeBuf = bytes_1.toBuffer(initCode);\r\n    assert(fromBuf.length === 20);\r\n    assert(saltBuf.length === 32);\r\n    var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));\r\n    return address.slice(-20);\r\n};\r\n/**\r\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\r\n */\r\nexports.isPrecompiled = function (address) {\r\n    var a = bytes_1.unpad(address);\r\n    return a.length === 1 && a[0] >= 1 && a[0] <= 8;\r\n};\r\n/**\r\n * Checks if the private key satisfies the rules of the curve secp256k1.\r\n */\r\nexports.isValidPrivate = function (privateKey) {\r\n    return secp256k1.privateKeyVerify(privateKey);\r\n};\r\n/**\r\n * Checks if the public key satisfies the rules of the curve secp256k1\r\n * and the requirements of Ethereum.\r\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\r\n * @param sanitize Accept public keys in other formats\r\n */\r\nexports.isValidPublic = function (publicKey, sanitize) {\r\n    if (sanitize === void 0) { sanitize = false; }\r\n    if (publicKey.length === 64) {\r\n        // Convert to SEC1 for secp256k1\r\n        return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\r\n    }\r\n    if (!sanitize) {\r\n        return false;\r\n    }\r\n    return secp256k1.publicKeyVerify(publicKey);\r\n};\r\n/**\r\n * Returns the ethereum address of a given public key.\r\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\r\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\r\n * @param sanitize Accept public keys in other formats\r\n */\r\nexports.pubToAddress = function (pubKey, sanitize) {\r\n    if (sanitize === void 0) { sanitize = false; }\r\n    pubKey = bytes_1.toBuffer(pubKey);\r\n    if (sanitize && pubKey.length !== 64) {\r\n        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\r\n    }\r\n    assert(pubKey.length === 64);\r\n    // Only take the lower 160bits of the hash\r\n    return hash_1.keccak(pubKey).slice(-20);\r\n};\r\nexports.publicToAddress = exports.pubToAddress;\r\n/**\r\n * Returns the ethereum address of a given private key.\r\n * @param privateKey A private key must be 256 bits wide\r\n */\r\nexports.privateToAddress = function (privateKey) {\r\n    return exports.publicToAddress(exports.privateToPublic(privateKey));\r\n};\r\n/**\r\n * Returns the ethereum public key of a given private key.\r\n * @param privateKey A private key must be 256 bits wide\r\n */\r\nexports.privateToPublic = function (privateKey) {\r\n    privateKey = bytes_1.toBuffer(privateKey);\r\n    // skip the type flag and use the X, Y points\r\n    return secp256k1.publicKeyCreate(privateKey, false).slice(1);\r\n};\r\n/**\r\n * Converts a public key to the Ethereum format.\r\n */\r\nexports.importPublic = function (publicKey) {\r\n    publicKey = bytes_1.toBuffer(publicKey);\r\n    if (publicKey.length !== 64) {\r\n        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\r\n    }\r\n    return publicKey;\r\n};\r\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,YAAY,GAAGF,OAAO,CAACG,eAAe,GAAGH,OAAO,CAACI,gBAAgB,GAAGJ,OAAO,CAACK,eAAe,GAAGL,OAAO,CAACM,YAAY,GAAGN,OAAO,CAACO,aAAa,GAAGP,OAAO,CAACQ,cAAc,GAAGR,OAAO,CAACS,aAAa,GAAGT,OAAO,CAACU,gBAAgB,GAAGV,OAAO,CAACW,eAAe,GAAGX,OAAO,CAACY,sBAAsB,GAAGZ,OAAO,CAACa,iBAAiB,GAAGb,OAAO,CAACc,aAAa,GAAGd,OAAO,CAACe,cAAc,GAAGf,OAAO,CAACgB,WAAW,GAAG,KAAK,CAAC;AACrY,IAAIC,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAC9B,IAAIC,SAAS,GAAGD,OAAO,CAAC,YAAY,CAAC;AACrC,IAAIE,SAAS,GAAGF,OAAO,CAAC,uBAAuB,CAAC;AAChD,IAAIG,EAAE,GAAGH,OAAO,CAAC,OAAO,CAAC;AACzB,IAAII,OAAO,GAAGJ,OAAO,CAAC,SAAS,CAAC;AAChC,IAAIK,MAAM,GAAGL,OAAO,CAAC,QAAQ,CAAC;AAC9B;AACA;AACA;AACAlB,OAAO,CAACgB,WAAW,GAAG,YAAY;EAC9B,IAAIQ,aAAa,GAAG,EAAE;EACtB,IAAIC,IAAI,GAAGH,OAAO,CAACI,KAAK,CAACF,aAAa,CAAC;EACvC,OAAOF,OAAO,CAACK,WAAW,CAACF,IAAI,CAAC;AACpC,CAAC;AACD;AACA;AACA;AACAzB,OAAO,CAACe,cAAc,GAAG,UAAUa,OAAO,EAAE;EACxC,OAAO,qBAAqB,CAACC,IAAI,CAACD,OAAO,CAAC;AAC9C,CAAC;AACD;AACA;AACA;AACA5B,OAAO,CAACc,aAAa,GAAG,UAAUc,OAAO,EAAE;EACvC,IAAIE,QAAQ,GAAG9B,OAAO,CAACgB,WAAW,EAAE;EACpC,OAAOc,QAAQ,KAAKR,OAAO,CAACS,YAAY,CAACH,OAAO,CAAC;AACrD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5B,OAAO,CAACa,iBAAiB,GAAG,UAAUe,OAAO,EAAEI,cAAc,EAAE;EAC3DJ,OAAO,GAAGT,SAAS,CAACc,cAAc,CAACL,OAAO,CAAC,CAACM,WAAW,EAAE;EACzD,IAAIC,MAAM,GAAGH,cAAc,KAAKI,SAAS,GAAGJ,cAAc,CAACK,QAAQ,EAAE,GAAG,IAAI,GAAG,EAAE;EACjF,IAAIC,IAAI,GAAGf,MAAM,CAACgB,MAAM,CAACJ,MAAM,GAAGP,OAAO,CAAC,CAACS,QAAQ,CAAC,KAAK,CAAC;EAC1D,IAAIG,GAAG,GAAG,IAAI;EACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,OAAO,CAACc,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,IAAIE,QAAQ,CAACL,IAAI,CAACG,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE;MAC5BD,GAAG,IAAIZ,OAAO,CAACa,CAAC,CAAC,CAACG,WAAW,EAAE;IACnC,CAAC,MACI;MACDJ,GAAG,IAAIZ,OAAO,CAACa,CAAC,CAAC;IACrB;EACJ;EACA,OAAOD,GAAG;AACd,CAAC;AACD;AACA;AACA;AACA;AACA;AACAxC,OAAO,CAACY,sBAAsB,GAAG,UAAUgB,OAAO,EAAEI,cAAc,EAAE;EAChE,OAAOhC,OAAO,CAACe,cAAc,CAACa,OAAO,CAAC,IAAI5B,OAAO,CAACa,iBAAiB,CAACe,OAAO,EAAEI,cAAc,CAAC,KAAKJ,OAAO;AAC5G,CAAC;AACD;AACA;AACA;AACA;AACA;AACA5B,OAAO,CAACW,eAAe,GAAG,UAAUkC,IAAI,EAAEC,KAAK,EAAE;EAC7CD,IAAI,GAAGvB,OAAO,CAACyB,QAAQ,CAACF,IAAI,CAAC;EAC7B,IAAIG,OAAO,GAAG,IAAI3B,EAAE,CAACyB,KAAK,CAAC;EAC3B,IAAIE,OAAO,CAACC,MAAM,EAAE,EAAE;IAClB;IACA;IACA,OAAO1B,MAAM,CAAC2B,OAAO,CAAC,CAACL,IAAI,EAAE,IAAI,CAAC,CAAC,CAACM,KAAK,CAAC,CAAC,EAAE,CAAC;EAClD;EACA;EACA,OAAO5B,MAAM,CAAC2B,OAAO,CAAC,CAACL,IAAI,EAAEO,MAAM,CAACP,IAAI,CAACG,OAAO,CAACK,OAAO,EAAE,CAAC,CAAC,CAAC,CAACF,KAAK,CAAC,CAAC,EAAE,CAAC;AAC5E,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACAnD,OAAO,CAACU,gBAAgB,GAAG,UAAUmC,IAAI,EAAES,IAAI,EAAEC,QAAQ,EAAE;EACvD,IAAIC,OAAO,GAAGlC,OAAO,CAACyB,QAAQ,CAACF,IAAI,CAAC;EACpC,IAAIY,OAAO,GAAGnC,OAAO,CAACyB,QAAQ,CAACO,IAAI,CAAC;EACpC,IAAII,WAAW,GAAGpC,OAAO,CAACyB,QAAQ,CAACQ,QAAQ,CAAC;EAC5CtC,MAAM,CAACuC,OAAO,CAACd,MAAM,KAAK,EAAE,CAAC;EAC7BzB,MAAM,CAACwC,OAAO,CAACf,MAAM,KAAK,EAAE,CAAC;EAC7B,IAAId,OAAO,GAAGL,MAAM,CAACoC,SAAS,CAACP,MAAM,CAACQ,MAAM,CAAC,CAACR,MAAM,CAACP,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,EAAEW,OAAO,EAAEC,OAAO,EAAElC,MAAM,CAACoC,SAAS,CAACD,WAAW,CAAC,CAAC,CAAC,CAAC;EAC1H,OAAO9B,OAAO,CAACuB,KAAK,CAAC,CAAC,EAAE,CAAC;AAC7B,CAAC;AACD;AACA;AACA;AACAnD,OAAO,CAACS,aAAa,GAAG,UAAUmB,OAAO,EAAE;EACvC,IAAIiC,CAAC,GAAGvC,OAAO,CAACwC,KAAK,CAAClC,OAAO,CAAC;EAC9B,OAAOiC,CAAC,CAACnB,MAAM,KAAK,CAAC,IAAImB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;AACnD,CAAC;AACD;AACA;AACA;AACA7D,OAAO,CAACQ,cAAc,GAAG,UAAUuD,UAAU,EAAE;EAC3C,OAAO3C,SAAS,CAAC4C,gBAAgB,CAACD,UAAU,CAAC;AACjD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA/D,OAAO,CAACO,aAAa,GAAG,UAAU0D,SAAS,EAAEC,QAAQ,EAAE;EACnD,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;IAAEA,QAAQ,GAAG,KAAK;EAAE;EAC7C,IAAID,SAAS,CAACvB,MAAM,KAAK,EAAE,EAAE;IACzB;IACA,OAAOtB,SAAS,CAAC+C,eAAe,CAACf,MAAM,CAACQ,MAAM,CAAC,CAACR,MAAM,CAACP,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEoB,SAAS,CAAC,CAAC,CAAC;EAClF;EACA,IAAI,CAACC,QAAQ,EAAE;IACX,OAAO,KAAK;EAChB;EACA,OAAO9C,SAAS,CAAC+C,eAAe,CAACF,SAAS,CAAC;AAC/C,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACAjE,OAAO,CAACM,YAAY,GAAG,UAAU8D,MAAM,EAAEF,QAAQ,EAAE;EAC/C,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;IAAEA,QAAQ,GAAG,KAAK;EAAE;EAC7CE,MAAM,GAAG9C,OAAO,CAACyB,QAAQ,CAACqB,MAAM,CAAC;EACjC,IAAIF,QAAQ,IAAIE,MAAM,CAAC1B,MAAM,KAAK,EAAE,EAAE;IAClC0B,MAAM,GAAGhD,SAAS,CAACiD,gBAAgB,CAACD,MAAM,EAAE,KAAK,CAAC,CAACjB,KAAK,CAAC,CAAC,CAAC;EAC/D;EACAlC,MAAM,CAACmD,MAAM,CAAC1B,MAAM,KAAK,EAAE,CAAC;EAC5B;EACA,OAAOnB,MAAM,CAACgB,MAAM,CAAC6B,MAAM,CAAC,CAACjB,KAAK,CAAC,CAAC,EAAE,CAAC;AAC3C,CAAC;AACDnD,OAAO,CAACK,eAAe,GAAGL,OAAO,CAACM,YAAY;AAC9C;AACA;AACA;AACA;AACAN,OAAO,CAACI,gBAAgB,GAAG,UAAU2D,UAAU,EAAE;EAC7C,OAAO/D,OAAO,CAACK,eAAe,CAACL,OAAO,CAACG,eAAe,CAAC4D,UAAU,CAAC,CAAC;AACvE,CAAC;AACD;AACA;AACA;AACA;AACA/D,OAAO,CAACG,eAAe,GAAG,UAAU4D,UAAU,EAAE;EAC5CA,UAAU,GAAGzC,OAAO,CAACyB,QAAQ,CAACgB,UAAU,CAAC;EACzC;EACA,OAAO3C,SAAS,CAACkD,eAAe,CAACP,UAAU,EAAE,KAAK,CAAC,CAACZ,KAAK,CAAC,CAAC,CAAC;AAChE,CAAC;AACD;AACA;AACA;AACAnD,OAAO,CAACE,YAAY,GAAG,UAAU+D,SAAS,EAAE;EACxCA,SAAS,GAAG3C,OAAO,CAACyB,QAAQ,CAACkB,SAAS,CAAC;EACvC,IAAIA,SAAS,CAACvB,MAAM,KAAK,EAAE,EAAE;IACzBuB,SAAS,GAAG7C,SAAS,CAACiD,gBAAgB,CAACJ,SAAS,EAAE,KAAK,CAAC,CAACd,KAAK,CAAC,CAAC,CAAC;EACrE;EACA,OAAOc,SAAS;AACpB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}