{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\nvar Address = require('./address');\nvar Base58Check = require('./encoding/base58check');\nvar BN = require('./crypto/bn');\nvar JSUtil = require('./util/js');\nvar Networks = require('./networks');\nvar Point = require('./crypto/point');\nvar PublicKey = require('./publickey');\nvar Random = require('./crypto/random');\nvar $ = require('./util/preconditions');\n\n/**\n * Instantiate a PrivateKey from a BN, Buffer and WIF.\n *\n * @example\n * ```javascript\n * // generate a new random key\n * var key = PrivateKey();\n *\n * // get the associated address\n * var address = key.toAddress();\n *\n * // encode into wallet export format\n * var exported = key.toWIF();\n *\n * // instantiate from the exported (and saved) private key\n * var imported = PrivateKey.fromWIF(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {PrivateKey} A new valid instance of an PrivateKey\n * @constructor\n */\nfunction PrivateKey(data, network) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 8 */\n\n  if (!(this instanceof PrivateKey)) {\n    return new PrivateKey(data, network);\n  }\n  if (data instanceof PrivateKey) {\n    return data;\n  }\n  var info = this._classifyArguments(data, network);\n\n  // validation\n  if (!info.bn || info.bn.cmp(new BN(0)) === 0) {\n    throw new TypeError('Number can not be equal to zero, undefined, null or false');\n  }\n  if (!info.bn.lt(Point.getN())) {\n    throw new TypeError('Number must be less than N');\n  }\n  if (typeof info.network === 'undefined') {\n    throw new TypeError('Must specify the network (\"livenet\" or \"testnet\")');\n  }\n  JSUtil.defineImmutable(this, {\n    bn: info.bn,\n    compressed: info.compressed,\n    network: info.network\n  });\n  Object.defineProperty(this, 'publicKey', {\n    configurable: false,\n    enumerable: true,\n    get: this.toPublicKey.bind(this)\n  });\n  return this;\n}\n;\n\n/**\n * Internal helper to instantiate PrivateKey internal `info` object from\n * different kinds of arguments passed to the constructor.\n *\n * @param {*} data\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @return {Object}\n */\nPrivateKey.prototype._classifyArguments = function (data, network) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: true,\n    network: network ? Networks.get(network) : Networks.defaultNetwork\n  };\n\n  // detect type of data\n  if (_.isUndefined(data) || _.isNull(data)) {\n    info.bn = PrivateKey._getRandomBN();\n  } else if (data instanceof BN) {\n    info.bn = data;\n  } else if (data instanceof Buffer || data instanceof Uint8Array) {\n    info = PrivateKey._transformBuffer(data, network);\n  } else if (data.bn && data.network) {\n    info = PrivateKey._transformObject(data);\n  } else if (!network && Networks.get(data)) {\n    info.bn = PrivateKey._getRandomBN();\n    info.network = Networks.get(data);\n  } else if (typeof data === 'string') {\n    if (JSUtil.isHexa(data)) {\n      info.bn = new BN(Buffer.from(data, 'hex'));\n    } else {\n      info = PrivateKey._transformWIF(data, network);\n    }\n  } else {\n    throw new TypeError('First argument is an unrecognized data type.');\n  }\n  return info;\n};\n\n/**\n * Internal function to get a random Big Number (BN)\n *\n * @returns {BN} A new randomly generated BN\n * @private\n */\nPrivateKey._getRandomBN = function () {\n  var condition;\n  var bn;\n  do {\n    var privbuf = Random.getRandomBuffer(32);\n    bn = BN.fromBuffer(privbuf);\n    condition = bn.lt(Point.getN());\n  } while (!condition);\n  return bn;\n};\n\n/**\n * Internal function to transform a WIF Buffer into a private key\n *\n * @param {Buffer} buf - An WIF string\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformBuffer = function (buf, network) {\n  var info = {};\n  if (buf.length === 32) {\n    return PrivateKey._transformBNBuffer(buf, network);\n  }\n  info.network = Networks.get(buf[0], 'privatekey');\n  if (!info.network) {\n    throw new Error('Invalid network');\n  }\n  if (network && info.network !== Networks.get(network)) {\n    throw new TypeError('Private key network mismatch');\n  }\n  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {\n    info.compressed = true;\n  } else if (buf.length === 1 + 32) {\n    info.compressed = false;\n  } else {\n    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');\n  }\n  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));\n  return info;\n};\n\n/**\n * Internal function to transform a BN buffer into a private key\n *\n * @param {Buffer} buf\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {object} an Object with keys: bn, network, and compressed\n * @private\n */\nPrivateKey._transformBNBuffer = function (buf, network) {\n  var info = {};\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.bn = BN.fromBuffer(buf);\n  info.compressed = false;\n  return info;\n};\n\n/**\n * Internal function to transform a WIF string into a private key\n *\n * @param {string} buf - An WIF string\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformWIF = function (str, network) {\n  return PrivateKey._transformBuffer(Base58Check.decode(str), network);\n};\n\n/**\n * Instantiate a PrivateKey from a Buffer with the DER or WIF representation\n *\n * @param {Buffer} arg\n * @param {Network} network\n * @return {PrivateKey}\n */\nPrivateKey.fromBuffer = function (arg, network) {\n  return new PrivateKey(arg, network);\n};\n\n/**\n * Internal function to transform a JSON string on plain object into a private key\n * return this.\n *\n * @param {string} json - A JSON string or plain object\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformObject = function (json) {\n  var bn = new BN(json.bn, 'hex');\n  var network = Networks.get(json.network);\n  return {\n    bn: bn,\n    network: network,\n    compressed: json.compressed\n  };\n};\n\n/**\n * Instantiate a PrivateKey from a WIF string\n *\n * @param {string} str - The WIF encoded private key string\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromString = PrivateKey.fromWIF = function (str) {\n  $.checkArgument(_.isString(str), 'First argument is expected to be a string.');\n  return new PrivateKey(str);\n};\n\n/**\n * Instantiate a PrivateKey from a plain JavaScript object\n *\n * @param {Object} obj - The output from privateKey.toObject()\n */\nPrivateKey.fromObject = function (obj) {\n  $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');\n  return new PrivateKey(obj);\n};\n\n/**\n * Instantiate a PrivateKey from random bytes\n *\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromRandom = function (network) {\n  var bn = PrivateKey._getRandomBN();\n  return new PrivateKey(bn, network);\n};\n\n/**\n * Check if there would be any errors when initializing a PrivateKey\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {null|Error} An error if exists\n */\n\nPrivateKey.getValidationError = function (data, network) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PrivateKey(data, network);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {Boolean} If the private key is would be valid\n */\nPrivateKey.isValid = function (data, network) {\n  if (!data) {\n    return false;\n  }\n  return !PrivateKey.getValidationError(data, network);\n};\n\n/**\n * Will output the PrivateKey encoded as hex string\n *\n * @returns {string}\n */\nPrivateKey.prototype.toString = function () {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * Will output the PrivateKey to a WIF string\n *\n * @returns {string} A WIP representation of the private key\n */\nPrivateKey.prototype.toWIF = function () {\n  var network = this.network;\n  var compressed = this.compressed;\n  var buf;\n  if (compressed) {\n    buf = Buffer.concat([Buffer.from([network.privatekey]), this.bn.toBuffer({\n      size: 32\n    }), Buffer.from([0x01])]);\n  } else {\n    buf = Buffer.concat([Buffer.from([network.privatekey]), this.bn.toBuffer({\n      size: 32\n    })]);\n  }\n  return Base58Check.encode(buf);\n};\n\n/**\n * Will return the private key as a BN instance\n *\n * @returns {BN} A BN instance of the private key\n */\nPrivateKey.prototype.toBigNumber = function () {\n  return this.bn;\n};\n\n/**\n * Will return the private key as a BN buffer\n *\n * @returns {Buffer} A buffer of the private key\n */\nPrivateKey.prototype.toBuffer = function () {\n  return this.bn.toBuffer({\n    size: 32\n  });\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Will return the private key as a BN buffer without leading zero padding\n *\n * @returns {Buffer} A buffer of the private key\n */\nPrivateKey.prototype.toBufferNoPadding = function () {\n  return this.bn.toBuffer();\n};\n\n/**\n * Will return the corresponding public key\n *\n * @returns {PublicKey} A public key generated from the private key\n */\nPrivateKey.prototype.toPublicKey = function () {\n  if (!this._pubkey) {\n    this._pubkey = PublicKey.fromPrivateKey(this);\n  }\n  return this._pubkey;\n};\n\n/**\n * Will return an address for the private key\n * @param {Network=} network - optional parameter specifying\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * the desired network for the address\n *\n * @returns {Address} An address generated from the private key\n */\nPrivateKey.prototype.toAddress = function (network, type) {\n  var pubkey = this.toPublicKey();\n  return Address.fromPublicKey(pubkey, network || this.network, type);\n};\n\n/**\n * @returns {Object} A plain object representation\n */\nPrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {\n  return {\n    bn: this.bn.toString('hex'),\n    compressed: this.compressed,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Private key\n */\nPrivateKey.prototype.inspect = function () {\n  var uncompressed = !this.compressed ? ', uncompressed' : '';\n  return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>';\n};\nmodule.exports = PrivateKey;","map":{"version":3,"names":["_","require","Address","Base58Check","BN","JSUtil","Networks","Point","PublicKey","Random","$","PrivateKey","data","network","info","_classifyArguments","bn","cmp","TypeError","lt","getN","defineImmutable","compressed","Object","defineProperty","configurable","enumerable","get","toPublicKey","bind","prototype","defaultNetwork","isUndefined","isNull","_getRandomBN","Buffer","Uint8Array","_transformBuffer","_transformObject","isHexa","from","_transformWIF","condition","privbuf","getRandomBuffer","fromBuffer","buf","length","_transformBNBuffer","Error","slice","str","decode","arg","json","fromString","fromWIF","checkArgument","isString","fromObject","obj","isObject","fromRandom","getValidationError","error","e","isValid","toString","toBuffer","toWIF","concat","privatekey","size","encode","toBigNumber","toBufferNoPadding","_pubkey","fromPrivateKey","toAddress","type","pubkey","fromPublicKey","toObject","toJSON","inspect","uncompressed","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFG - Enginering/BLOCKTICK/blocktick_dApp/node_modules/bitcore-lib/lib/privatekey.js"],"sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar Address = require('./address');\nvar Base58Check = require('./encoding/base58check');\nvar BN = require('./crypto/bn');\nvar JSUtil = require('./util/js');\nvar Networks = require('./networks');\nvar Point = require('./crypto/point');\nvar PublicKey = require('./publickey');\nvar Random = require('./crypto/random');\nvar $ = require('./util/preconditions');\n\n/**\n * Instantiate a PrivateKey from a BN, Buffer and WIF.\n *\n * @example\n * ```javascript\n * // generate a new random key\n * var key = PrivateKey();\n *\n * // get the associated address\n * var address = key.toAddress();\n *\n * // encode into wallet export format\n * var exported = key.toWIF();\n *\n * // instantiate from the exported (and saved) private key\n * var imported = PrivateKey.fromWIF(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {PrivateKey} A new valid instance of an PrivateKey\n * @constructor\n */\nfunction PrivateKey(data, network) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 8 */\n\n  if (!(this instanceof PrivateKey)) {\n    return new PrivateKey(data, network);\n  }\n  if (data instanceof PrivateKey) {\n    return data;\n  }\n\n  var info = this._classifyArguments(data, network);\n\n  // validation\n  if (!info.bn || info.bn.cmp(new BN(0)) === 0){\n    throw new TypeError('Number can not be equal to zero, undefined, null or false');\n  }\n  if (!info.bn.lt(Point.getN())) {\n    throw new TypeError('Number must be less than N');\n  }\n  if (typeof(info.network) === 'undefined') {\n    throw new TypeError('Must specify the network (\"livenet\" or \"testnet\")');\n  }\n\n  JSUtil.defineImmutable(this, {\n    bn: info.bn,\n    compressed: info.compressed,\n    network: info.network\n  });\n\n  Object.defineProperty(this, 'publicKey', {\n    configurable: false,\n    enumerable: true,\n    get: this.toPublicKey.bind(this)\n  });\n\n  return this;\n\n};\n\n/**\n * Internal helper to instantiate PrivateKey internal `info` object from\n * different kinds of arguments passed to the constructor.\n *\n * @param {*} data\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @return {Object}\n */\nPrivateKey.prototype._classifyArguments = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: true,\n    network: network ? Networks.get(network) : Networks.defaultNetwork\n  };\n\n  // detect type of data\n  if (_.isUndefined(data) || _.isNull(data)){\n    info.bn = PrivateKey._getRandomBN();\n  } else if (data instanceof BN) {\n    info.bn = data;\n  } else if (data instanceof Buffer || data instanceof Uint8Array) {\n    info = PrivateKey._transformBuffer(data, network);\n  } else if (data.bn && data.network){\n    info = PrivateKey._transformObject(data);\n  } else if (!network && Networks.get(data)) {\n    info.bn = PrivateKey._getRandomBN();\n    info.network = Networks.get(data);\n  } else if (typeof(data) === 'string'){\n    if (JSUtil.isHexa(data)) {\n      info.bn = new BN(Buffer.from(data, 'hex'));\n    } else {\n      info = PrivateKey._transformWIF(data, network);\n    }\n  } else {\n    throw new TypeError('First argument is an unrecognized data type.');\n  }\n  return info;\n};\n\n/**\n * Internal function to get a random Big Number (BN)\n *\n * @returns {BN} A new randomly generated BN\n * @private\n */\nPrivateKey._getRandomBN = function(){\n  var condition;\n  var bn;\n  do {\n    var privbuf = Random.getRandomBuffer(32);\n    bn = BN.fromBuffer(privbuf);\n    condition = bn.lt(Point.getN());\n  } while (!condition);\n  return bn;\n};\n\n/**\n * Internal function to transform a WIF Buffer into a private key\n *\n * @param {Buffer} buf - An WIF string\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformBuffer = function(buf, network) {\n\n  var info = {};\n\n  if (buf.length === 32) {\n    return PrivateKey._transformBNBuffer(buf, network);\n  }\n\n  info.network = Networks.get(buf[0], 'privatekey');\n\n  if (!info.network) {\n    throw new Error('Invalid network');\n  }\n\n  if (network && info.network !== Networks.get(network)) {\n    throw new TypeError('Private key network mismatch');\n  }\n\n  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {\n    info.compressed = true;\n  } else if (buf.length === 1 + 32) {\n    info.compressed = false;\n  } else {\n    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');\n  }\n\n  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));\n\n  return info;\n};\n\n/**\n * Internal function to transform a BN buffer into a private key\n *\n * @param {Buffer} buf\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {object} an Object with keys: bn, network, and compressed\n * @private\n */\nPrivateKey._transformBNBuffer = function(buf, network) {\n  var info = {};\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.bn = BN.fromBuffer(buf);\n  info.compressed = false;\n  return info;\n};\n\n/**\n * Internal function to transform a WIF string into a private key\n *\n * @param {string} buf - An WIF string\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformWIF = function(str, network) {\n  return PrivateKey._transformBuffer(Base58Check.decode(str), network);\n};\n\n/**\n * Instantiate a PrivateKey from a Buffer with the DER or WIF representation\n *\n * @param {Buffer} arg\n * @param {Network} network\n * @return {PrivateKey}\n */\nPrivateKey.fromBuffer = function(arg, network) {\n  return new PrivateKey(arg, network);\n};\n\n/**\n * Internal function to transform a JSON string on plain object into a private key\n * return this.\n *\n * @param {string} json - A JSON string or plain object\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformObject = function(json) {\n  var bn = new BN(json.bn, 'hex');\n  var network = Networks.get(json.network);\n  return {\n    bn: bn,\n    network: network,\n    compressed: json.compressed\n  };\n};\n\n/**\n * Instantiate a PrivateKey from a WIF string\n *\n * @param {string} str - The WIF encoded private key string\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromString = PrivateKey.fromWIF = function(str) {\n  $.checkArgument(_.isString(str), 'First argument is expected to be a string.');\n  return new PrivateKey(str);\n};\n\n/**\n * Instantiate a PrivateKey from a plain JavaScript object\n *\n * @param {Object} obj - The output from privateKey.toObject()\n */\nPrivateKey.fromObject = function(obj) {\n  $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');\n  return new PrivateKey(obj);\n};\n\n/**\n * Instantiate a PrivateKey from random bytes\n *\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromRandom = function(network) {\n  var bn = PrivateKey._getRandomBN();\n  return new PrivateKey(bn, network);\n};\n\n/**\n * Check if there would be any errors when initializing a PrivateKey\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {null|Error} An error if exists\n */\n\nPrivateKey.getValidationError = function(data, network) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PrivateKey(data, network);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {Boolean} If the private key is would be valid\n */\nPrivateKey.isValid = function(data, network){\n  if (!data) {\n    return false;\n  }\n  return !PrivateKey.getValidationError(data, network);\n};\n\n/**\n * Will output the PrivateKey encoded as hex string\n *\n * @returns {string}\n */\nPrivateKey.prototype.toString = function() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * Will output the PrivateKey to a WIF string\n *\n * @returns {string} A WIP representation of the private key\n */\nPrivateKey.prototype.toWIF = function() {\n  var network = this.network;\n  var compressed = this.compressed;\n\n  var buf;\n  if (compressed) {\n    buf = Buffer.concat([Buffer.from([network.privatekey]),\n                         this.bn.toBuffer({size: 32}),\n                         Buffer.from([0x01])]);\n  } else {\n    buf = Buffer.concat([Buffer.from([network.privatekey]),\n                         this.bn.toBuffer({size: 32})]);\n  }\n\n  return Base58Check.encode(buf);\n};\n\n/**\n * Will return the private key as a BN instance\n *\n * @returns {BN} A BN instance of the private key\n */\nPrivateKey.prototype.toBigNumber = function(){\n  return this.bn;\n};\n\n/**\n * Will return the private key as a BN buffer\n *\n * @returns {Buffer} A buffer of the private key\n */\nPrivateKey.prototype.toBuffer = function(){\n  return this.bn.toBuffer({size: 32});\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Will return the private key as a BN buffer without leading zero padding\n *\n * @returns {Buffer} A buffer of the private key\n */\nPrivateKey.prototype.toBufferNoPadding = function() {\n  return this.bn.toBuffer();\n};\n\n/**\n * Will return the corresponding public key\n *\n * @returns {PublicKey} A public key generated from the private key\n */\nPrivateKey.prototype.toPublicKey = function(){\n  if (!this._pubkey) {\n    this._pubkey = PublicKey.fromPrivateKey(this);\n  }\n  return this._pubkey;\n};\n\n/**\n * Will return an address for the private key\n * @param {Network=} network - optional parameter specifying\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * the desired network for the address\n *\n * @returns {Address} An address generated from the private key\n */\nPrivateKey.prototype.toAddress = function(network, type) {\n  var pubkey = this.toPublicKey();\n  return Address.fromPublicKey(pubkey, network || this.network, type);\n};\n\n/**\n * @returns {Object} A plain object representation\n */\nPrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {\n  return {\n    bn: this.bn.toString('hex'),\n    compressed: this.compressed,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Private key\n */\nPrivateKey.prototype.inspect = function() {\n  var uncompressed = !this.compressed ? ', uncompressed' : '';\n  return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>';\n};\n\nmodule.exports = PrivateKey;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}