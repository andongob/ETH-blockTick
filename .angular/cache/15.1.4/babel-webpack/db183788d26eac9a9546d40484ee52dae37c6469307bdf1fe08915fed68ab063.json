{"ast":null,"code":"const BigInteger = require('bigi');\nconst Buffer = require('safe-buffer').Buffer;\nconst ecurve = require('ecurve');\nconst randomBytes = require('randombytes');\nconst curve = ecurve.getCurveByName('secp256k1');\nconst check = require('./check');\nconst convert = require('./convert');\nconst concat = Buffer.concat;\nconst G = curve.G;\nconst p = curve.p;\nconst n = curve.n;\nconst zero = BigInteger.ZERO;\nconst one = BigInteger.ONE;\nconst two = BigInteger.valueOf(2);\nconst three = BigInteger.valueOf(3);\nconst four = BigInteger.valueOf(4);\nconst seven = BigInteger.valueOf(7);\nfunction deterministicGetK0(privateKey, publicKey, message) {\n  check.checkSignParams(privateKey, message);\n  const h = taggedHash('BIP0340/nonce', concat([convert.intToBuffer(privateKey), publicKey, message]));\n  const i = convert.bufferToInt(h);\n  return i.mod(n);\n}\nfunction isEven(pubKey) {\n  return pubKey.affineY.mod(two).equals(zero);\n}\nfunction getEvenKey(pubKey, privateKey) {\n  if (isEven(pubKey)) {\n    return privateKey.clone();\n  }\n  return n.subtract(privateKey);\n}\nfunction getE(Rx, Px, m) {\n  const hash = taggedHash('BIP0340/challenge', concat([Rx, Px, m]));\n  return convert.bufferToInt(hash).mod(n);\n}\nfunction getR(s, e, P) {\n  const sG = G.multiply(s);\n  const eP = P.multiply(e);\n  return sG.add(eP.negate());\n}\nfunction taggedHash(tag, msg) {\n  const tagHash = convert.hash(tag);\n  return convert.hash(concat([tagHash, tagHash, Buffer.from(msg)]));\n}\nfunction liftX(Px) {\n  const x = convert.bufferToInt(Px);\n  const c = x.pow(three).add(seven).mod(p);\n  const y = c.modPow(p.add(one).divide(four), p);\n  if (c.compareTo(y.modPow(two, p)) !== 0) {\n    throw new Error('c is not equal to y^2');\n  }\n  let P = ecurve.Point.fromAffine(curve, x, y);\n  if (!isEven(P)) {\n    P = ecurve.Point.fromAffine(curve, x, p.subtract(y));\n  }\n  check.checkPointExists(true, P);\n  return P;\n}\nfunction randomA() {\n  let a = null;\n  for (;;) {\n    a = convert.bufferToInt(Buffer.from(randomBytes(32)));\n    try {\n      check.checkRange('a', a);\n      return a;\n    } catch (e) {\n      // out of range, generate another one\n    }\n  }\n}\nmodule.exports = {\n  deterministicGetK0,\n  isEven,\n  getEvenKey,\n  getE,\n  getR,\n  taggedHash,\n  liftX,\n  randomA\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}