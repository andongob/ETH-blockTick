{"ast":null,"code":"'use strict';\n\nconst bitcore = require('bitcore-lib');\nconst BN = bitcore.crypto.BN;\nconst unorm = require('unorm');\nconst _ = bitcore.deps._;\nconst pbkdf2 = require('./pbkdf2');\nconst errors = require('./errors');\nconst Hash = bitcore.crypto.Hash;\nconst Random = bitcore.crypto.Random;\nconst $ = bitcore.util.preconditions;\n\n/**\n * This is an immutable class that represents a BIP39 Mnemonic code.\n * See BIP39 specification for more info: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n * A Mnemonic code is a a group of easy to remember words used for the generation\n * of deterministic wallets. A Mnemonic can be used to generate a seed using\n * an optional passphrase, for later generate a HDPrivateKey.\n *\n * @example\n * // generate a random mnemonic\n * var mnemonic = new Mnemonic();\n * var phrase = mnemonic.phrase;\n *\n * // use a different language\n * var mnemonic = new Mnemonic(Mnemonic.Words.SPANISH);\n * var xprivkey = mnemonic.toHDPrivateKey();\n *\n * @param {*=} data - a seed, phrase, or entropy to initialize (can be skipped)\n * @param {Array=} wordlist - the wordlist to generate mnemonics from\n * @returns {Mnemonic} A new instance of Mnemonic\n * @constructor\n */\nvar Mnemonic = function (data, wordlist) {\n  if (!(this instanceof Mnemonic)) {\n    return new Mnemonic(data, wordlist);\n  }\n  if (_.isArray(data)) {\n    wordlist = data;\n    data = null;\n  }\n\n  // handle data overloading\n  var ent, phrase, seed;\n  if (Buffer.isBuffer(data)) {\n    seed = data;\n    ent = seed.length * 8;\n  } else if (_.isString(data)) {\n    phrase = unorm.nfkd(data);\n  } else if (_.isNumber(data)) {\n    ent = data;\n  } else if (data) {\n    throw new bitcore.errors.InvalidArgument('data', 'Must be a Buffer, a string or an integer');\n  }\n  ent = ent || 128;\n\n  // check and detect wordlist\n  wordlist = wordlist || Mnemonic._getDictionary(phrase);\n  if (phrase && !wordlist) {\n    throw new errors.UnknownWordlist(phrase);\n  }\n  wordlist = wordlist || Mnemonic.Words.ENGLISH;\n  if (seed) {\n    phrase = Mnemonic._entropy2mnemonic(seed, wordlist);\n  }\n\n  // validate phrase and ent\n  if (phrase && !Mnemonic.isValid(phrase, wordlist)) {\n    throw new errors.InvalidMnemonic(phrase);\n  }\n  if (ent % 32 !== 0 || ent < 128 || ent > 256) {\n    throw new bitcore.errors.InvalidArgument('ENT', 'Values must be ENT > 128 and ENT < 256 and ENT % 32 == 0');\n  }\n  phrase = phrase || Mnemonic._mnemonic(ent, wordlist);\n\n  // this fixes spacing in JP\n  phrase = unorm.nfkd(phrase);\n  Object.defineProperty(this, 'wordlist', {\n    configurable: false,\n    value: wordlist\n  });\n  Object.defineProperty(this, 'phrase', {\n    configurable: false,\n    value: phrase\n  });\n};\nMnemonic.Words = require('./words');\n\n/**\n * Will return a boolean if the mnemonic is valid\n *\n * @example\n *\n * var valid = Mnemonic.isValid('lab rescue lunch elbow recall phrase perfect donkey biology guess moment husband');\n * // true\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} [wordlist] - The wordlist used\n * @returns {boolean}\n */\nMnemonic.isValid = function (mnemonic, wordlist) {\n  mnemonic = unorm.nfkd(mnemonic);\n  wordlist = wordlist || Mnemonic._getDictionary(mnemonic);\n  if (!wordlist) {\n    return false;\n  }\n  var words = mnemonic.split(' ');\n  var bin = '';\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n    bin = bin + ('00000000000' + ind.toString(2)).slice(-11);\n  }\n  var cs = bin.length / 33;\n  var hash_bits = bin.slice(-cs);\n  var nonhash_bits = bin.slice(0, bin.length - cs);\n  var buf = Buffer.alloc(nonhash_bits.length / 8);\n  for (i = 0; i < nonhash_bits.length / 8; i++) {\n    buf.writeUInt8(parseInt(bin.slice(i * 8, (i + 1) * 8), 2), i);\n  }\n  var expected_hash_bits = Mnemonic._entropyChecksum(buf);\n  return expected_hash_bits === hash_bits;\n};\n\n/**\n * Internal function to check if a mnemonic belongs to a wordlist.\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} wordlist - The wordlist\n * @returns {boolean}\n */\nMnemonic._belongsToWordlist = function (mnemonic, wordlist) {\n  var words = unorm.nfkd(mnemonic).split(' ');\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n  }\n  return true;\n};\n\n/**\n * Internal function to detect the wordlist used to generate the mnemonic.\n *\n * @param {String} mnemonic - The mnemonic string\n * @returns {Array} the wordlist or null\n */\nMnemonic._getDictionary = function (mnemonic) {\n  if (!mnemonic) return null;\n  var dicts = Object.keys(Mnemonic.Words);\n  for (var i = 0; i < dicts.length; i++) {\n    var key = dicts[i];\n    if (Mnemonic._belongsToWordlist(mnemonic, Mnemonic.Words[key])) {\n      return Mnemonic.Words[key];\n    }\n  }\n  return null;\n};\n\n/**\n * Will generate a seed based on the mnemonic and optional passphrase.\n *\n * @param {String} [passphrase]\n * @returns {Buffer}\n */\nMnemonic.prototype.toSeed = function (passphrase) {\n  passphrase = passphrase || '';\n  return pbkdf2(unorm.nfkd(this.phrase), unorm.nfkd('mnemonic' + passphrase), 2048, 64);\n};\n\n/**\n * Will generate a Mnemonic object based on a seed.\n *\n * @param {Buffer} [seed]\n * @param {string} [wordlist]\n * @returns {Mnemonic}\n */\nMnemonic.fromSeed = function (seed, wordlist) {\n  $.checkArgument(Buffer.isBuffer(seed), 'seed must be a Buffer.');\n  $.checkArgument(_.isArray(wordlist) || _.isString(wordlist), 'wordlist must be a string or an array.');\n  return new Mnemonic(seed, wordlist);\n};\n\n/**\n *\n * Generates a HD Private Key from a Mnemonic.\n * Optionally receive a passphrase and bitcoin network.\n *\n * @param {String=} [passphrase]\n * @param {Network|String|number=} [network] - The network: 'livenet' or 'testnet'\n * @returns {HDPrivateKey}\n */\nMnemonic.prototype.toHDPrivateKey = function (passphrase, network) {\n  var seed = this.toSeed(passphrase);\n  return bitcore.HDPrivateKey.fromSeed(seed, network);\n};\n\n/**\n * Will return a the string representation of the mnemonic\n *\n * @returns {String} Mnemonic\n */\nMnemonic.prototype.toString = function () {\n  return this.phrase;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Mnemonic\n */\nMnemonic.prototype.inspect = function () {\n  return '<Mnemonic: ' + this.toString() + ' >';\n};\n\n/**\n * Internal function to generate a random mnemonic\n *\n * @param {Number} ENT - Entropy size, defaults to 128\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\nMnemonic._mnemonic = function (ENT, wordlist) {\n  var buf = Random.getRandomBuffer(ENT / 8);\n  return Mnemonic._entropy2mnemonic(buf, wordlist);\n};\n\n/**\n * Internal function to generate mnemonic based on entropy\n *\n * @param {Buffer} entropy - Entropy buffer\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\nMnemonic._entropy2mnemonic = function (entropy, wordlist) {\n  var bin = '';\n  for (var i = 0; i < entropy.length; i++) {\n    bin = bin + ('00000000' + entropy[i].toString(2)).slice(-8);\n  }\n  bin = bin + Mnemonic._entropyChecksum(entropy);\n  if (bin.length % 11 !== 0) {\n    throw new errors.InvalidEntropy(bin);\n  }\n  var mnemonic = [];\n  for (i = 0; i < bin.length / 11; i++) {\n    var wi = parseInt(bin.slice(i * 11, (i + 1) * 11), 2);\n    mnemonic.push(wordlist[wi]);\n  }\n  var ret;\n  if (wordlist === Mnemonic.Words.JAPANESE) {\n    ret = mnemonic.join('\\u3000');\n  } else {\n    ret = mnemonic.join(' ');\n  }\n  return ret;\n};\n\n/**\n * Internal function to create checksum of entropy\n *\n * @param {Buffer} entropy\n * @returns {string} Checksum of entropy length / 32\n * @private\n */\nMnemonic._entropyChecksum = function (entropy) {\n  var hash = Hash.sha256(entropy);\n  var bits = entropy.length * 8;\n  var cs = bits / 32;\n  var hashbits = new BN(hash.toString('hex'), 16).toString(2);\n\n  // zero pad the hash bits\n  while (hashbits.length % 256 !== 0) {\n    hashbits = '0' + hashbits;\n  }\n  var checksum = hashbits.slice(0, cs);\n  return checksum;\n};\nMnemonic.bitcore = bitcore;\nmodule.exports = Mnemonic;","map":{"version":3,"names":["bitcore","require","BN","crypto","unorm","_","deps","pbkdf2","errors","Hash","Random","$","util","preconditions","Mnemonic","data","wordlist","isArray","ent","phrase","seed","Buffer","isBuffer","length","isString","nfkd","isNumber","InvalidArgument","_getDictionary","UnknownWordlist","Words","ENGLISH","_entropy2mnemonic","isValid","InvalidMnemonic","_mnemonic","Object","defineProperty","configurable","value","mnemonic","words","split","bin","i","ind","indexOf","toString","slice","cs","hash_bits","nonhash_bits","buf","alloc","writeUInt8","parseInt","expected_hash_bits","_entropyChecksum","_belongsToWordlist","dicts","keys","key","prototype","toSeed","passphrase","fromSeed","checkArgument","toHDPrivateKey","network","HDPrivateKey","inspect","ENT","getRandomBuffer","entropy","InvalidEntropy","wi","push","ret","JAPANESE","join","hash","sha256","bits","hashbits","checksum","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFG - Enginering/BLOCKTICK/blocktick_dApp/node_modules/bitcore-mnemonic/lib/mnemonic.js"],"sourcesContent":["'use strict';\n\nconst bitcore = require('bitcore-lib');\nconst BN = bitcore.crypto.BN;\nconst unorm = require('unorm');\nconst _ = bitcore.deps._;\n\nconst pbkdf2 = require('./pbkdf2');\nconst errors = require('./errors');\n\nconst Hash = bitcore.crypto.Hash;\nconst Random = bitcore.crypto.Random;\n\nconst $ = bitcore.util.preconditions;\n\n\n/**\n * This is an immutable class that represents a BIP39 Mnemonic code.\n * See BIP39 specification for more info: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n * A Mnemonic code is a a group of easy to remember words used for the generation\n * of deterministic wallets. A Mnemonic can be used to generate a seed using\n * an optional passphrase, for later generate a HDPrivateKey.\n *\n * @example\n * // generate a random mnemonic\n * var mnemonic = new Mnemonic();\n * var phrase = mnemonic.phrase;\n *\n * // use a different language\n * var mnemonic = new Mnemonic(Mnemonic.Words.SPANISH);\n * var xprivkey = mnemonic.toHDPrivateKey();\n *\n * @param {*=} data - a seed, phrase, or entropy to initialize (can be skipped)\n * @param {Array=} wordlist - the wordlist to generate mnemonics from\n * @returns {Mnemonic} A new instance of Mnemonic\n * @constructor\n */\nvar Mnemonic = function(data, wordlist) {\n  if (!(this instanceof Mnemonic)) {\n    return new Mnemonic(data, wordlist);\n  }\n\n  if (_.isArray(data)) {\n    wordlist = data;\n    data = null;\n  }\n\n\n  // handle data overloading\n  var ent, phrase, seed;\n  if (Buffer.isBuffer(data)) {\n    seed = data;\n    ent = seed.length * 8;\n  } else if (_.isString(data)) {\n    phrase = unorm.nfkd(data);\n  } else if (_.isNumber(data)) {\n    ent = data;\n  } else if (data) {\n    throw new bitcore.errors.InvalidArgument('data', 'Must be a Buffer, a string or an integer');\n  }\n  ent = ent || 128;\n\n\n  // check and detect wordlist\n  wordlist = wordlist || Mnemonic._getDictionary(phrase);\n  if (phrase && !wordlist) {\n    throw new errors.UnknownWordlist(phrase);\n  }\n  wordlist = wordlist || Mnemonic.Words.ENGLISH;\n\n  if (seed) {\n    phrase = Mnemonic._entropy2mnemonic(seed, wordlist);\n  }\n\n\n  // validate phrase and ent\n  if (phrase && !Mnemonic.isValid(phrase, wordlist)) {\n    throw new errors.InvalidMnemonic(phrase);\n  }\n  if (ent % 32 !== 0 || ent < 128 || ent > 256) {\n    throw new bitcore.errors.InvalidArgument('ENT', 'Values must be ENT > 128 and ENT < 256 and ENT % 32 == 0');\n  }\n\n  phrase = phrase || Mnemonic._mnemonic(ent, wordlist);\n\n  // this fixes spacing in JP\n  phrase = unorm.nfkd(phrase);\n\n  Object.defineProperty(this, 'wordlist', {\n    configurable: false,\n    value: wordlist\n  });\n\n  Object.defineProperty(this, 'phrase', {\n    configurable: false,\n    value: phrase\n  });\n};\n\nMnemonic.Words = require('./words');\n\n/**\n * Will return a boolean if the mnemonic is valid\n *\n * @example\n *\n * var valid = Mnemonic.isValid('lab rescue lunch elbow recall phrase perfect donkey biology guess moment husband');\n * // true\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} [wordlist] - The wordlist used\n * @returns {boolean}\n */\nMnemonic.isValid = function(mnemonic, wordlist) {\n  mnemonic = unorm.nfkd(mnemonic);\n  wordlist = wordlist || Mnemonic._getDictionary(mnemonic);\n\n  if (!wordlist) {\n    return false;\n  }\n\n  var words = mnemonic.split(' ');\n  var bin = '';\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n    bin = bin + ('00000000000' + ind.toString(2)).slice(-11);\n  }\n\n  var cs = bin.length / 33;\n  var hash_bits = bin.slice(-cs);\n  var nonhash_bits = bin.slice(0, bin.length - cs);\n  var buf = Buffer.alloc(nonhash_bits.length / 8);\n  for (i = 0; i < nonhash_bits.length / 8; i++) {\n    buf.writeUInt8(parseInt(bin.slice(i * 8, (i + 1) * 8), 2), i);\n  }\n  var expected_hash_bits = Mnemonic._entropyChecksum(buf);\n  return expected_hash_bits === hash_bits;\n};\n\n/**\n * Internal function to check if a mnemonic belongs to a wordlist.\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} wordlist - The wordlist\n * @returns {boolean}\n */\nMnemonic._belongsToWordlist = function(mnemonic, wordlist) {\n  var words = unorm.nfkd(mnemonic).split(' ');\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n  }\n  return true;\n};\n\n/**\n * Internal function to detect the wordlist used to generate the mnemonic.\n *\n * @param {String} mnemonic - The mnemonic string\n * @returns {Array} the wordlist or null\n */\nMnemonic._getDictionary = function(mnemonic) {\n  if (!mnemonic) return null;\n\n  var dicts = Object.keys(Mnemonic.Words);\n  for (var i = 0; i < dicts.length; i++) {\n    var key = dicts[i];\n    if (Mnemonic._belongsToWordlist(mnemonic, Mnemonic.Words[key])) {\n      return Mnemonic.Words[key];\n    }\n  }\n  return null;\n};\n\n/**\n * Will generate a seed based on the mnemonic and optional passphrase.\n *\n * @param {String} [passphrase]\n * @returns {Buffer}\n */\nMnemonic.prototype.toSeed = function(passphrase) {\n  passphrase = passphrase || '';\n  return pbkdf2(unorm.nfkd(this.phrase), unorm.nfkd('mnemonic' + passphrase), 2048, 64);\n};\n\n/**\n * Will generate a Mnemonic object based on a seed.\n *\n * @param {Buffer} [seed]\n * @param {string} [wordlist]\n * @returns {Mnemonic}\n */\nMnemonic.fromSeed = function(seed, wordlist) {\n  $.checkArgument(Buffer.isBuffer(seed), 'seed must be a Buffer.');\n  $.checkArgument(_.isArray(wordlist) || _.isString(wordlist), 'wordlist must be a string or an array.');\n  return new Mnemonic(seed, wordlist);\n};\n\n/**\n *\n * Generates a HD Private Key from a Mnemonic.\n * Optionally receive a passphrase and bitcoin network.\n *\n * @param {String=} [passphrase]\n * @param {Network|String|number=} [network] - The network: 'livenet' or 'testnet'\n * @returns {HDPrivateKey}\n */\nMnemonic.prototype.toHDPrivateKey = function(passphrase, network) {\n  var seed = this.toSeed(passphrase);\n  return bitcore.HDPrivateKey.fromSeed(seed, network);\n};\n\n/**\n * Will return a the string representation of the mnemonic\n *\n * @returns {String} Mnemonic\n */\nMnemonic.prototype.toString = function() {\n  return this.phrase;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Mnemonic\n */\nMnemonic.prototype.inspect = function() {\n  return '<Mnemonic: ' + this.toString() + ' >';\n};\n\n/**\n * Internal function to generate a random mnemonic\n *\n * @param {Number} ENT - Entropy size, defaults to 128\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\nMnemonic._mnemonic = function(ENT, wordlist) {\n  var buf = Random.getRandomBuffer(ENT / 8);\n  return Mnemonic._entropy2mnemonic(buf, wordlist);\n};\n\n/**\n * Internal function to generate mnemonic based on entropy\n *\n * @param {Buffer} entropy - Entropy buffer\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\nMnemonic._entropy2mnemonic = function(entropy, wordlist) {\n  var bin = '';\n  for (var i = 0; i < entropy.length; i++) {\n    bin = bin + ('00000000' + entropy[i].toString(2)).slice(-8);\n  }\n\n  bin = bin + Mnemonic._entropyChecksum(entropy);\n  if (bin.length % 11 !== 0) {\n    throw new errors.InvalidEntropy(bin);\n  }\n  var mnemonic = [];\n  for (i = 0; i < bin.length / 11; i++) {\n    var wi = parseInt(bin.slice(i * 11, (i + 1) * 11), 2);\n    mnemonic.push(wordlist[wi]);\n  }\n  var ret;\n  if (wordlist === Mnemonic.Words.JAPANESE) {\n    ret = mnemonic.join('\\u3000');\n  } else {\n    ret = mnemonic.join(' ');\n  }\n  return ret;\n};\n\n/**\n * Internal function to create checksum of entropy\n *\n * @param {Buffer} entropy\n * @returns {string} Checksum of entropy length / 32\n * @private\n */\nMnemonic._entropyChecksum = function(entropy) {\n  var hash = Hash.sha256(entropy);\n  var bits = entropy.length * 8;\n  var cs = bits / 32;\n\n  var hashbits = new BN(hash.toString('hex'), 16).toString(2);\n\n  // zero pad the hash bits\n  while (hashbits.length % 256 !== 0) {\n    hashbits = '0' + hashbits;\n  }\n\n  var checksum = hashbits.slice(0, cs);\n\n  return checksum;\n};\n\nMnemonic.bitcore = bitcore;\n\nmodule.exports = Mnemonic;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}