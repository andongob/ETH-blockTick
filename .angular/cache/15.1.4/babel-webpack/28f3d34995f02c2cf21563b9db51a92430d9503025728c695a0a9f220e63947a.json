{"ast":null,"code":"'use strict';\n\nconst bitcore = require('bitcore-lib');\nconst BN = bitcore.crypto.BN;\nconst unorm = require('unorm');\nconst _ = bitcore.deps._;\nconst pbkdf2 = require('./pbkdf2');\nconst errors = require('./errors');\nconst Hash = bitcore.crypto.Hash;\nconst Random = bitcore.crypto.Random;\nconst $ = bitcore.util.preconditions;\n\n/**\n * This is an immutable class that represents a BIP39 Mnemonic code.\n * See BIP39 specification for more info: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n * A Mnemonic code is a a group of easy to remember words used for the generation\n * of deterministic wallets. A Mnemonic can be used to generate a seed using\n * an optional passphrase, for later generate a HDPrivateKey.\n *\n * @example\n * // generate a random mnemonic\n * var mnemonic = new Mnemonic();\n * var phrase = mnemonic.phrase;\n *\n * // use a different language\n * var mnemonic = new Mnemonic(Mnemonic.Words.SPANISH);\n * var xprivkey = mnemonic.toHDPrivateKey();\n *\n * @param {*=} data - a seed, phrase, or entropy to initialize (can be skipped)\n * @param {Array=} wordlist - the wordlist to generate mnemonics from\n * @returns {Mnemonic} A new instance of Mnemonic\n * @constructor\n */\nvar Mnemonic = function (data, wordlist) {\n  if (!(this instanceof Mnemonic)) {\n    return new Mnemonic(data, wordlist);\n  }\n  if (_.isArray(data)) {\n    wordlist = data;\n    data = null;\n  }\n\n  // handle data overloading\n  var ent, phrase, seed;\n  if (Buffer.isBuffer(data)) {\n    seed = data;\n    ent = seed.length * 8;\n  } else if (_.isString(data)) {\n    phrase = unorm.nfkd(data);\n  } else if (_.isNumber(data)) {\n    ent = data;\n  } else if (data) {\n    throw new bitcore.errors.InvalidArgument('data', 'Must be a Buffer, a string or an integer');\n  }\n  ent = ent || 128;\n\n  // check and detect wordlist\n  wordlist = wordlist || Mnemonic._getDictionary(phrase);\n  if (phrase && !wordlist) {\n    throw new errors.UnknownWordlist(phrase);\n  }\n  wordlist = wordlist || Mnemonic.Words.ENGLISH;\n  if (seed) {\n    phrase = Mnemonic._entropy2mnemonic(seed, wordlist);\n  }\n\n  // validate phrase and ent\n  if (phrase && !Mnemonic.isValid(phrase, wordlist)) {\n    throw new errors.InvalidMnemonic(phrase);\n  }\n  if (ent % 32 !== 0 || ent < 128 || ent > 256) {\n    throw new bitcore.errors.InvalidArgument('ENT', 'Values must be ENT > 128 and ENT < 256 and ENT % 32 == 0');\n  }\n  phrase = phrase || Mnemonic._mnemonic(ent, wordlist);\n\n  // this fixes spacing in JP\n  phrase = unorm.nfkd(phrase);\n  Object.defineProperty(this, 'wordlist', {\n    configurable: false,\n    value: wordlist\n  });\n  Object.defineProperty(this, 'phrase', {\n    configurable: false,\n    value: phrase\n  });\n};\nMnemonic.Words = require('./words');\n\n/**\n * Will return a boolean if the mnemonic is valid\n *\n * @example\n *\n * var valid = Mnemonic.isValid('lab rescue lunch elbow recall phrase perfect donkey biology guess moment husband');\n * // true\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} [wordlist] - The wordlist used\n * @returns {boolean}\n */\nMnemonic.isValid = function (mnemonic, wordlist) {\n  mnemonic = unorm.nfkd(mnemonic);\n  wordlist = wordlist || Mnemonic._getDictionary(mnemonic);\n  if (!wordlist) {\n    return false;\n  }\n  var words = mnemonic.split(' ');\n  var bin = '';\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n    bin = bin + ('00000000000' + ind.toString(2)).slice(-11);\n  }\n  var cs = bin.length / 33;\n  var hash_bits = bin.slice(-cs);\n  var nonhash_bits = bin.slice(0, bin.length - cs);\n  var buf = Buffer.alloc(nonhash_bits.length / 8);\n  for (i = 0; i < nonhash_bits.length / 8; i++) {\n    buf.writeUInt8(parseInt(bin.slice(i * 8, (i + 1) * 8), 2), i);\n  }\n  var expected_hash_bits = Mnemonic._entropyChecksum(buf);\n  return expected_hash_bits === hash_bits;\n};\n\n/**\n * Internal function to check if a mnemonic belongs to a wordlist.\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} wordlist - The wordlist\n * @returns {boolean}\n */\nMnemonic._belongsToWordlist = function (mnemonic, wordlist) {\n  var words = unorm.nfkd(mnemonic).split(' ');\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n  }\n  return true;\n};\n\n/**\n * Internal function to detect the wordlist used to generate the mnemonic.\n *\n * @param {String} mnemonic - The mnemonic string\n * @returns {Array} the wordlist or null\n */\nMnemonic._getDictionary = function (mnemonic) {\n  if (!mnemonic) return null;\n  var dicts = Object.keys(Mnemonic.Words);\n  for (var i = 0; i < dicts.length; i++) {\n    var key = dicts[i];\n    if (Mnemonic._belongsToWordlist(mnemonic, Mnemonic.Words[key])) {\n      return Mnemonic.Words[key];\n    }\n  }\n  return null;\n};\n\n/**\n * Will generate a seed based on the mnemonic and optional passphrase.\n *\n * @param {String} [passphrase]\n * @returns {Buffer}\n */\nMnemonic.prototype.toSeed = function (passphrase) {\n  passphrase = passphrase || '';\n  return pbkdf2(unorm.nfkd(this.phrase), unorm.nfkd('mnemonic' + passphrase), 2048, 64);\n};\n\n/**\n * Will generate a Mnemonic object based on a seed.\n *\n * @param {Buffer} [seed]\n * @param {string} [wordlist]\n * @returns {Mnemonic}\n */\nMnemonic.fromSeed = function (seed, wordlist) {\n  $.checkArgument(Buffer.isBuffer(seed), 'seed must be a Buffer.');\n  $.checkArgument(_.isArray(wordlist) || _.isString(wordlist), 'wordlist must be a string or an array.');\n  return new Mnemonic(seed, wordlist);\n};\n\n/**\n *\n * Generates a HD Private Key from a Mnemonic.\n * Optionally receive a passphrase and bitcoin network.\n *\n * @param {String=} [passphrase]\n * @param {Network|String|number=} [network] - The network: 'livenet' or 'testnet'\n * @returns {HDPrivateKey}\n */\nMnemonic.prototype.toHDPrivateKey = function (passphrase, network) {\n  var seed = this.toSeed(passphrase);\n  return bitcore.HDPrivateKey.fromSeed(seed, network);\n};\n\n/**\n * Will return a the string representation of the mnemonic\n *\n * @returns {String} Mnemonic\n */\nMnemonic.prototype.toString = function () {\n  return this.phrase;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Mnemonic\n */\nMnemonic.prototype.inspect = function () {\n  return '<Mnemonic: ' + this.toString() + ' >';\n};\n\n/**\n * Internal function to generate a random mnemonic\n *\n * @param {Number} ENT - Entropy size, defaults to 128\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\nMnemonic._mnemonic = function (ENT, wordlist) {\n  var buf = Random.getRandomBuffer(ENT / 8);\n  return Mnemonic._entropy2mnemonic(buf, wordlist);\n};\n\n/**\n * Internal function to generate mnemonic based on entropy\n *\n * @param {Buffer} entropy - Entropy buffer\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\nMnemonic._entropy2mnemonic = function (entropy, wordlist) {\n  var bin = '';\n  for (var i = 0; i < entropy.length; i++) {\n    bin = bin + ('00000000' + entropy[i].toString(2)).slice(-8);\n  }\n  bin = bin + Mnemonic._entropyChecksum(entropy);\n  if (bin.length % 11 !== 0) {\n    throw new errors.InvalidEntropy(bin);\n  }\n  var mnemonic = [];\n  for (i = 0; i < bin.length / 11; i++) {\n    var wi = parseInt(bin.slice(i * 11, (i + 1) * 11), 2);\n    mnemonic.push(wordlist[wi]);\n  }\n  var ret;\n  if (wordlist === Mnemonic.Words.JAPANESE) {\n    ret = mnemonic.join('\\u3000');\n  } else {\n    ret = mnemonic.join(' ');\n  }\n  return ret;\n};\n\n/**\n * Internal function to create checksum of entropy\n *\n * @param {Buffer} entropy\n * @returns {string} Checksum of entropy length / 32\n * @private\n */\nMnemonic._entropyChecksum = function (entropy) {\n  var hash = Hash.sha256(entropy);\n  var bits = entropy.length * 8;\n  var cs = bits / 32;\n  var hashbits = new BN(hash.toString('hex'), 16).toString(2);\n\n  // zero pad the hash bits\n  while (hashbits.length % 256 !== 0) {\n    hashbits = '0' + hashbits;\n  }\n  var checksum = hashbits.slice(0, cs);\n  return checksum;\n};\nMnemonic.bitcore = bitcore;\nmodule.exports = Mnemonic;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}