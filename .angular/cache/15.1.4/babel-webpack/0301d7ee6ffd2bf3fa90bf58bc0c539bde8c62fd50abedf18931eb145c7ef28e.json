{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar BN = require('./crypto/bn');\nvar Base58 = require('./encoding/base58');\nvar Base58Check = require('./encoding/base58check');\nvar Hash = require('./crypto/hash');\nvar HDPrivateKey = require('./hdprivatekey');\nvar Network = require('./networks');\nvar Point = require('./crypto/point');\nvar PublicKey = require('./publickey');\nvar bitcoreErrors = require('./errors');\nvar errors = bitcoreErrors;\nvar hdErrors = bitcoreErrors.HDPublicKey;\nvar assert = require('assert');\nvar JSUtil = require('./util/js');\nvar BufferUtil = require('./util/buffer');\n\n/**\r\n * The representation of an hierarchically derived public key.\r\n *\r\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\r\n *\r\n * @constructor\r\n * @param {Object|string|Buffer} arg\r\n */\nfunction HDPublicKey(arg) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      } else {\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n          return new HDPrivateKey(arg).hdPublicKey;\n        }\n        throw error;\n      }\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        } else {\n          return this._buildFromObject(arg);\n        }\n      } else {\n        throw new hdErrors.UnrecognizedArgument(arg);\n      }\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n\n/**\r\n * Verifies that a given path is valid.\r\n *\r\n * @param {string|number} arg\r\n * @return {boolean}\r\n */\nHDPublicKey.isValidPath = function (arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\n  }\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n  return false;\n};\n\n/**\r\n * WARNING: This method is deprecated. Use deriveChild instead.\r\n *\r\n *\r\n * Get a derivated child based on a string or number.\r\n *\r\n * If the first argument is a string, it's parsed as the full path of\r\n * derivation. Valid values for this argument include \"m\" (which returns the\r\n * same public key), \"m/0/1/40/2/1000\".\r\n *\r\n * Note that hardened keys can't be derived from a public extended key.\r\n *\r\n * If the first argument is a number, the child with that index will be\r\n * derived. See the example usage for clarification.\r\n *\r\n * @example\r\n * ```javascript\r\n * var parent = new HDPublicKey('xpub...');\r\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\r\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\r\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\r\n * ```\r\n *\r\n * @param {string|number} arg\r\n */\nHDPublicKey.prototype.derive = function (arg, hardened) {\n  return this.deriveChild(arg, hardened);\n};\n\n/**\r\n * WARNING: This method will not be officially supported until v1.0.0.\r\n *\r\n *\r\n * Get a derivated child based on a string or number.\r\n *\r\n * If the first argument is a string, it's parsed as the full path of\r\n * derivation. Valid values for this argument include \"m\" (which returns the\r\n * same public key), \"m/0/1/40/2/1000\".\r\n *\r\n * Note that hardened keys can't be derived from a public extended key.\r\n *\r\n * If the first argument is a number, the child with that index will be\r\n * derived. See the example usage for clarification.\r\n *\r\n * @example\r\n * ```javascript\r\n * var parent = new HDPublicKey('xpub...');\r\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\r\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\r\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\r\n * ```\r\n *\r\n * @param {string|number} arg\r\n */\nHDPublicKey.prototype.deriveChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\nHDPublicKey.prototype._deriveWithNumber = function (index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n  var publicKey;\n  try {\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n  } catch (e) {\n    return this._deriveWithNumber(index + 1);\n  }\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    publicKey: publicKey\n  });\n  return derived;\n};\nHDPublicKey.prototype._deriveFromString = function (path) {\n  /* jshint maxcomplexity: 8 */\n  if (_.includes(path, \"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function (prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n  return derived;\n};\n\n/**\r\n * Verifies that a given serialized public key in base58 with checksum format\r\n * is valid.\r\n *\r\n * @param {string|Buffer} data - the serialized public key\r\n * @param {string|Network=} network - optional, if present, checks that the\r\n *     network provided matches the network serialized.\r\n * @return {boolean}\r\n */\nHDPublicKey.isValidSerialized = function (data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n\n/**\r\n * Checks what's the error that causes the validation of a serialized public key\r\n * in base58 with checksum to fail.\r\n *\r\n * @param {string|Buffer} data - the serialized public key\r\n * @param {string|Network=} network - optional, if present, checks that the\r\n *     network provided matches the network serialized.\r\n * @return {errors|null}\r\n */\nHDPublicKey.getSerializedError = function (data, network) {\n  /* jshint maxcomplexity: 10 */\n  /* jshint maxstatements: 20 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n  return null;\n};\nHDPublicKey._validateNetwork = function (data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\nHDPublicKey.prototype._buildFromObject = function (arg) {\n  /* jshint maxcomplexity: 10 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode, 'hex') : arg.chainCode,\n    publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey, 'hex') : BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\nHDPublicKey.prototype._buildFromSerialized = function (arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart, HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\n/**\r\n * Receives a object with buffers in all the properties and populates the\r\n * internal structure\r\n *\r\n * @param {Object} arg\r\n * @param {buffer.Buffer} arg.version\r\n * @param {buffer.Buffer} arg.depth\r\n * @param {buffer.Buffer} arg.parentFingerPrint\r\n * @param {buffer.Buffer} arg.childIndex\r\n * @param {buffer.Buffer} arg.chainCode\r\n * @param {buffer.Buffer} arg.publicKey\r\n * @param {buffer.Buffer} arg.checksum\r\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\r\n *      representation\r\n * @return {HDPublicKey} this\r\n */\nHDPublicKey.prototype._buildFromBuffers = function (arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPublicKey._validateBufferArguments(arg);\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n  var sequence = [arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, arg.publicKey];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else {\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n      throw new errors.InvalidB58Checksum(concat, checksum);\n    }\n  }\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xpubkey;\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = Buffer.from(xpubkey);\n  var publicKey = new PublicKey(arg.publicKey, {\n    network: network\n  });\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n  JSUtil.defineImmutable(this, {\n    xpubkey: xpubkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n  return this;\n};\nHDPublicKey._validateBufferArguments = function (arg) {\n  var checkBuffer = function (name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\n    assert(buff.length === size, name + ' has not the expected size: found ' + buff.length + ', expected ' + size);\n  };\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\nHDPublicKey.fromString = function (arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\nHDPublicKey.fromObject = function (arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n\n/**\r\n * Returns the base58 checked representation of the public key\r\n * @return {string} a string starting with \"xpub...\" in livenet\r\n */\nHDPublicKey.prototype.toString = function () {\n  return this.xpubkey;\n};\n\n/**\r\n * Returns the console representation of this extended public key.\r\n * @return string\r\n */\nHDPublicKey.prototype.inspect = function () {\n  return '<HDPublicKey: ' + this.xpubkey + '>';\n};\n\n/**\r\n * Returns a plain JavaScript object with information to reconstruct a key.\r\n *\r\n * Fields are: <ul>\r\n *  <li> network: 'livenet' or 'testnet'\r\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\r\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\r\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\r\n *  <li>     parent's public key\r\n *  <li> childIndex: index with which this key was derived\r\n *  <li> chainCode: string in hexa encoding used for derivation\r\n *  <li> publicKey: string, hexa encoded, in compressed key format\r\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\r\n *  <li> xpubkey: the string with the base58 representation of this extended key\r\n *  <li> checksum: the base58 checksum of xpubkey\r\n * </ul>\r\n */\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n\n/**\r\n * Create a HDPublicKey from a buffer argument\r\n *\r\n * @param {Buffer} arg\r\n * @return {HDPublicKey}\r\n */\nHDPublicKey.fromBuffer = function (arg) {\n  return new HDPublicKey(arg);\n};\n\n/**\r\n * Return a buffer representation of the xpubkey\r\n *\r\n * @return {Buffer}\r\n */\nHDPublicKey.prototype.toBuffer = function () {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\nHDPublicKey.VersionStart = 0;\nHDPublicKey.VersionEnd = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\nmodule.exports = HDPublicKey;","map":{"version":3,"names":["_","require","$","BN","Base58","Base58Check","Hash","HDPrivateKey","Network","Point","PublicKey","bitcoreErrors","errors","hdErrors","HDPublicKey","assert","JSUtil","BufferUtil","arg","isString","isBuffer","error","getSerializedError","_buildFromSerialized","toString","ArgumentIsPrivateExtended","hdPublicKey","isObject","_buildFromPrivate","_buildFromObject","UnrecognizedArgument","MustSupplyArgument","isValidPath","indexes","_getDerivationIndexes","every","isNumber","Hardened","prototype","derive","hardened","deriveChild","_deriveWithNumber","_deriveFromString","InvalidDerivationArgument","index","InvalidIndexCantDeriveHardened","InvalidPath","indexBuffer","integerAsBuffer","data","concat","publicKey","toBuffer","hash","sha512hmac","_buffers","chainCode","leftPart","fromBuffer","slice","size","fromPoint","getG","mul","add","point","e","derived","network","depth","parentFingerPrint","fingerPrint","childIndex","path","includes","reduce","prev","isValidSerialized","isNull","validCharacters","InvalidB58Char","decode","InvalidB58Checksum","length","DataSize","InvalidLength","isUndefined","_validateNetwork","version","integerFromBuffer","livenet","xprivkey","testnet","networkArg","get","InvalidNetworkArgument","VersionStart","VersionEnd","xpubkey","InvalidNetwork","args","clone","privateKey","pointToCompressed","undefined","checksum","_buildFromBuffers","buffers","integerAsSingleByteBuffer","Buffer","from","decoded","DepthStart","DepthEnd","ParentFingerPrintStart","ParentFingerPrintEnd","ChildIndexStart","ChildIndexEnd","ChainCodeStart","ChainCodeEnd","PublicKeyStart","PublicKeyEnd","ChecksumStart","ChecksumEnd","_validateBufferArguments","defineImmutable","sequence","encode","ParentFingerPrintSize","sha256ripemd160","integerFromSingleByteBuffer","checkBuffer","name","buff","VersionSize","DepthSize","ChildIndexSize","ChainCodeSize","PublicKeySize","CheckSumSize","fromString","checkArgument","fromObject","inspect","toObject","toJSON","bufferToHex","copy","RootElementAlias","SerializedByteSize","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/bitcore-lib/lib/hdpublickey.js"],"sourcesContent":["'use strict';\r\n\r\nvar _ = require('lodash');\r\nvar $ = require('./util/preconditions');\r\n\r\nvar BN = require('./crypto/bn');\r\nvar Base58 = require('./encoding/base58');\r\nvar Base58Check = require('./encoding/base58check');\r\nvar Hash = require('./crypto/hash');\r\nvar HDPrivateKey = require('./hdprivatekey');\r\nvar Network = require('./networks');\r\nvar Point = require('./crypto/point');\r\nvar PublicKey = require('./publickey');\r\n\r\nvar bitcoreErrors = require('./errors');\r\nvar errors = bitcoreErrors;\r\nvar hdErrors = bitcoreErrors.HDPublicKey;\r\nvar assert = require('assert');\r\n\r\nvar JSUtil = require('./util/js');\r\nvar BufferUtil = require('./util/buffer');\r\n\r\n/**\r\n * The representation of an hierarchically derived public key.\r\n *\r\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\r\n *\r\n * @constructor\r\n * @param {Object|string|Buffer} arg\r\n */\r\nfunction HDPublicKey(arg) {\r\n  /* jshint maxcomplexity: 12 */\r\n  /* jshint maxstatements: 20 */\r\n  if (arg instanceof HDPublicKey) {\r\n    return arg;\r\n  }\r\n  if (!(this instanceof HDPublicKey)) {\r\n    return new HDPublicKey(arg);\r\n  }\r\n  if (arg) {\r\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\r\n      var error = HDPublicKey.getSerializedError(arg);\r\n      if (!error) {\r\n        return this._buildFromSerialized(arg);\r\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\r\n        return this._buildFromSerialized(arg.toString());\r\n      } else {\r\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\r\n          return new HDPrivateKey(arg).hdPublicKey;\r\n        }\r\n        throw error;\r\n      }\r\n    } else {\r\n      if (_.isObject(arg)) {\r\n        if (arg instanceof HDPrivateKey) {\r\n          return this._buildFromPrivate(arg);\r\n        } else {\r\n          return this._buildFromObject(arg);\r\n        }\r\n      } else {\r\n        throw new hdErrors.UnrecognizedArgument(arg);\r\n      }\r\n    }\r\n  } else {\r\n    throw new hdErrors.MustSupplyArgument();\r\n  }\r\n}\r\n\r\n/**\r\n * Verifies that a given path is valid.\r\n *\r\n * @param {string|number} arg\r\n * @return {boolean}\r\n */\r\nHDPublicKey.isValidPath = function(arg) {\r\n  if (_.isString(arg)) {\r\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\r\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\r\n  }\r\n\r\n  if (_.isNumber(arg)) {\r\n    return arg >= 0 && arg < HDPublicKey.Hardened;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * WARNING: This method is deprecated. Use deriveChild instead.\r\n *\r\n *\r\n * Get a derivated child based on a string or number.\r\n *\r\n * If the first argument is a string, it's parsed as the full path of\r\n * derivation. Valid values for this argument include \"m\" (which returns the\r\n * same public key), \"m/0/1/40/2/1000\".\r\n *\r\n * Note that hardened keys can't be derived from a public extended key.\r\n *\r\n * If the first argument is a number, the child with that index will be\r\n * derived. See the example usage for clarification.\r\n *\r\n * @example\r\n * ```javascript\r\n * var parent = new HDPublicKey('xpub...');\r\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\r\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\r\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\r\n * ```\r\n *\r\n * @param {string|number} arg\r\n */\r\nHDPublicKey.prototype.derive = function(arg, hardened) {\r\n  return this.deriveChild(arg, hardened);\r\n};\r\n\r\n/**\r\n * WARNING: This method will not be officially supported until v1.0.0.\r\n *\r\n *\r\n * Get a derivated child based on a string or number.\r\n *\r\n * If the first argument is a string, it's parsed as the full path of\r\n * derivation. Valid values for this argument include \"m\" (which returns the\r\n * same public key), \"m/0/1/40/2/1000\".\r\n *\r\n * Note that hardened keys can't be derived from a public extended key.\r\n *\r\n * If the first argument is a number, the child with that index will be\r\n * derived. See the example usage for clarification.\r\n *\r\n * @example\r\n * ```javascript\r\n * var parent = new HDPublicKey('xpub...');\r\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\r\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\r\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\r\n * ```\r\n *\r\n * @param {string|number} arg\r\n */\r\nHDPublicKey.prototype.deriveChild = function(arg, hardened) {\r\n  if (_.isNumber(arg)) {\r\n    return this._deriveWithNumber(arg, hardened);\r\n  } else if (_.isString(arg)) {\r\n    return this._deriveFromString(arg);\r\n  } else {\r\n    throw new hdErrors.InvalidDerivationArgument(arg);\r\n  }\r\n};\r\n\r\nHDPublicKey.prototype._deriveWithNumber = function(index, hardened) {\r\n  if (index >= HDPublicKey.Hardened || hardened) {\r\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\r\n  }\r\n  if (index < 0) {\r\n    throw new hdErrors.InvalidPath(index);\r\n  }\r\n\r\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\r\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\r\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\r\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32});\r\n  var chainCode = hash.slice(32, 64);\r\n\r\n  var publicKey;\r\n  try {\r\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\r\n  } catch (e) {\r\n    return this._deriveWithNumber(index + 1);\r\n  }\r\n\r\n  var derived = new HDPublicKey({\r\n    network: this.network,\r\n    depth: this.depth + 1,\r\n    parentFingerPrint: this.fingerPrint,\r\n    childIndex: index,\r\n    chainCode: chainCode,\r\n    publicKey: publicKey\r\n  });\r\n\r\n  return derived;\r\n};\r\n\r\nHDPublicKey.prototype._deriveFromString = function(path) {\r\n  /* jshint maxcomplexity: 8 */\r\n  if (_.includes(path, \"'\")) {\r\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\r\n  } else if (!HDPublicKey.isValidPath(path)) {\r\n    throw new hdErrors.InvalidPath(path);\r\n  }\r\n\r\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\r\n  var derived = indexes.reduce(function(prev, index) {\r\n    return prev._deriveWithNumber(index);\r\n  }, this);\r\n\r\n  return derived;\r\n};\r\n\r\n/**\r\n * Verifies that a given serialized public key in base58 with checksum format\r\n * is valid.\r\n *\r\n * @param {string|Buffer} data - the serialized public key\r\n * @param {string|Network=} network - optional, if present, checks that the\r\n *     network provided matches the network serialized.\r\n * @return {boolean}\r\n */\r\nHDPublicKey.isValidSerialized = function(data, network) {\r\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\r\n};\r\n\r\n/**\r\n * Checks what's the error that causes the validation of a serialized public key\r\n * in base58 with checksum to fail.\r\n *\r\n * @param {string|Buffer} data - the serialized public key\r\n * @param {string|Network=} network - optional, if present, checks that the\r\n *     network provided matches the network serialized.\r\n * @return {errors|null}\r\n */\r\nHDPublicKey.getSerializedError = function(data, network) {\r\n  /* jshint maxcomplexity: 10 */\r\n  /* jshint maxstatements: 20 */\r\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\r\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\r\n  }\r\n  if (!Base58.validCharacters(data)) {\r\n    return new errors.InvalidB58Char('(unknown)', data);\r\n  }\r\n  try {\r\n    data = Base58Check.decode(data);\r\n  } catch (e) {\r\n    return new errors.InvalidB58Checksum(data);\r\n  }\r\n  if (data.length !== HDPublicKey.DataSize) {\r\n    return new hdErrors.InvalidLength(data);\r\n  }\r\n  if (!_.isUndefined(network)) {\r\n    var error = HDPublicKey._validateNetwork(data, network);\r\n    if (error) {\r\n      return error;\r\n    }\r\n  }\r\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\r\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey ) {\r\n    return new hdErrors.ArgumentIsPrivateExtended();\r\n  }\r\n  return null;\r\n};\r\n\r\nHDPublicKey._validateNetwork = function(data, networkArg) {\r\n  var network = Network.get(networkArg);\r\n  if (!network) {\r\n    return new errors.InvalidNetworkArgument(networkArg);\r\n  }\r\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\r\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\r\n    return new errors.InvalidNetwork(version);\r\n  }\r\n  return null;\r\n};\r\n\r\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\r\n  var args = _.clone(arg._buffers);\r\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\r\n  args.publicKey = Point.pointToCompressed(point);\r\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\r\n  args.privateKey = undefined;\r\n  args.checksum = undefined;\r\n  args.xprivkey = undefined;\r\n  return this._buildFromBuffers(args);\r\n};\r\n\r\nHDPublicKey.prototype._buildFromObject = function(arg) {\r\n  /* jshint maxcomplexity: 10 */\r\n  // TODO: Type validation\r\n  var buffers = {\r\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\r\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\r\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\r\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\r\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,\r\n    publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey,'hex') :\r\n      BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\r\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\r\n  };\r\n  return this._buildFromBuffers(buffers);\r\n};\r\n\r\nHDPublicKey.prototype._buildFromSerialized = function(arg) {\r\n  var decoded = Base58Check.decode(arg);\r\n  var buffers = {\r\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\r\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\r\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart,\r\n                                     HDPublicKey.ParentFingerPrintEnd),\r\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\r\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\r\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\r\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\r\n    xpubkey: arg\r\n  };\r\n  return this._buildFromBuffers(buffers);\r\n};\r\n\r\n/**\r\n * Receives a object with buffers in all the properties and populates the\r\n * internal structure\r\n *\r\n * @param {Object} arg\r\n * @param {buffer.Buffer} arg.version\r\n * @param {buffer.Buffer} arg.depth\r\n * @param {buffer.Buffer} arg.parentFingerPrint\r\n * @param {buffer.Buffer} arg.childIndex\r\n * @param {buffer.Buffer} arg.chainCode\r\n * @param {buffer.Buffer} arg.publicKey\r\n * @param {buffer.Buffer} arg.checksum\r\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\r\n *      representation\r\n * @return {HDPublicKey} this\r\n */\r\nHDPublicKey.prototype._buildFromBuffers = function(arg) {\r\n  /* jshint maxcomplexity: 8 */\r\n  /* jshint maxstatements: 20 */\r\n\r\n  HDPublicKey._validateBufferArguments(arg);\r\n\r\n  JSUtil.defineImmutable(this, {\r\n    _buffers: arg\r\n  });\r\n\r\n  var sequence = [\r\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\r\n    arg.publicKey\r\n  ];\r\n  var concat = BufferUtil.concat(sequence);\r\n  var checksum = Base58Check.checksum(concat);\r\n  if (!arg.checksum || !arg.checksum.length) {\r\n    arg.checksum = checksum;\r\n  } else {\r\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\r\n      throw new errors.InvalidB58Checksum(concat, checksum);\r\n    }\r\n  }\r\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\r\n\r\n  var xpubkey;\r\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\r\n  arg.xpubkey = Buffer.from(xpubkey);\r\n\r\n  var publicKey = new PublicKey(arg.publicKey, {network: network});\r\n  var size = HDPublicKey.ParentFingerPrintSize;\r\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\r\n\r\n  JSUtil.defineImmutable(this, {\r\n    xpubkey: xpubkey,\r\n    network: network,\r\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\r\n    publicKey: publicKey,\r\n    fingerPrint: fingerPrint\r\n  });\r\n\r\n  return this;\r\n};\r\n\r\nHDPublicKey._validateBufferArguments = function(arg) {\r\n  var checkBuffer = function(name, size) {\r\n    var buff = arg[name];\r\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\r\n    assert(\r\n      buff.length === size,\r\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\r\n    );\r\n  };\r\n  checkBuffer('version', HDPublicKey.VersionSize);\r\n  checkBuffer('depth', HDPublicKey.DepthSize);\r\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\r\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\r\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\r\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\r\n  if (arg.checksum && arg.checksum.length) {\r\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\r\n  }\r\n};\r\n\r\nHDPublicKey.fromString = function(arg) {\r\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\r\n  return new HDPublicKey(arg);\r\n};\r\n\r\nHDPublicKey.fromObject = function(arg) {\r\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\r\n  return new HDPublicKey(arg);\r\n};\r\n\r\n/**\r\n * Returns the base58 checked representation of the public key\r\n * @return {string} a string starting with \"xpub...\" in livenet\r\n */\r\nHDPublicKey.prototype.toString = function() {\r\n  return this.xpubkey;\r\n};\r\n\r\n/**\r\n * Returns the console representation of this extended public key.\r\n * @return string\r\n */\r\nHDPublicKey.prototype.inspect = function() {\r\n  return '<HDPublicKey: ' + this.xpubkey + '>';\r\n};\r\n\r\n/**\r\n * Returns a plain JavaScript object with information to reconstruct a key.\r\n *\r\n * Fields are: <ul>\r\n *  <li> network: 'livenet' or 'testnet'\r\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\r\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\r\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\r\n *  <li>     parent's public key\r\n *  <li> childIndex: index with which this key was derived\r\n *  <li> chainCode: string in hexa encoding used for derivation\r\n *  <li> publicKey: string, hexa encoded, in compressed key format\r\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\r\n *  <li> xpubkey: the string with the base58 representation of this extended key\r\n *  <li> checksum: the base58 checksum of xpubkey\r\n * </ul>\r\n */\r\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\r\n  return {\r\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\r\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\r\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\r\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\r\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\r\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\r\n    publicKey: this.publicKey.toString(),\r\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\r\n    xpubkey: this.xpubkey\r\n  };\r\n};\r\n\r\n/**\r\n * Create a HDPublicKey from a buffer argument\r\n *\r\n * @param {Buffer} arg\r\n * @return {HDPublicKey}\r\n */\r\nHDPublicKey.fromBuffer = function(arg) {\r\n  return new HDPublicKey(arg);\r\n};\r\n\r\n/**\r\n * Return a buffer representation of the xpubkey\r\n *\r\n * @return {Buffer}\r\n */\r\nHDPublicKey.prototype.toBuffer = function() {\r\n  return BufferUtil.copy(this._buffers.xpubkey);\r\n};\r\n\r\nHDPublicKey.Hardened = 0x80000000;\r\nHDPublicKey.RootElementAlias = ['m', 'M'];\r\n\r\nHDPublicKey.VersionSize = 4;\r\nHDPublicKey.DepthSize = 1;\r\nHDPublicKey.ParentFingerPrintSize = 4;\r\nHDPublicKey.ChildIndexSize = 4;\r\nHDPublicKey.ChainCodeSize = 32;\r\nHDPublicKey.PublicKeySize = 33;\r\nHDPublicKey.CheckSumSize = 4;\r\n\r\nHDPublicKey.DataSize = 78;\r\nHDPublicKey.SerializedByteSize = 82;\r\n\r\nHDPublicKey.VersionStart           = 0;\r\nHDPublicKey.VersionEnd             = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\r\nHDPublicKey.DepthStart             = HDPublicKey.VersionEnd;\r\nHDPublicKey.DepthEnd               = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\r\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\r\nHDPublicKey.ParentFingerPrintEnd   = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\r\nHDPublicKey.ChildIndexStart        = HDPublicKey.ParentFingerPrintEnd;\r\nHDPublicKey.ChildIndexEnd          = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\r\nHDPublicKey.ChainCodeStart         = HDPublicKey.ChildIndexEnd;\r\nHDPublicKey.ChainCodeEnd           = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\r\nHDPublicKey.PublicKeyStart         = HDPublicKey.ChainCodeEnd;\r\nHDPublicKey.PublicKeyEnd           = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\r\nHDPublicKey.ChecksumStart          = HDPublicKey.PublicKeyEnd;\r\nHDPublicKey.ChecksumEnd            = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\r\n\r\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\r\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\r\n\r\nmodule.exports = HDPublicKey;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}