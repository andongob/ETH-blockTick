{"ast":null,"code":"'use strict';\n\nvar bech32 = require('bech32');\n\n/**\n * Decode bech32/bech32m string\n * @param {String} str String to decode\n * @returns {Object} Decoded string info\n */\nvar decode = function (str) {\n  if (typeof str !== 'string') {\n    throw new Error('Input should be a string');\n  }\n  var decoded;\n  let fromWords = bech32.bech32.fromWords;\n  let encoding = encodings.BECH32;\n  try {\n    decoded = bech32.bech32.decode(str);\n  } catch (e) {\n    if (e.message.indexOf('Invalid checksum') > -1) {\n      decoded = bech32.bech32m.decode(str);\n      encoding = encodings.BECH32M;\n      fromWords = bech32.bech32m.fromWords;\n    } else {\n      throw e;\n    }\n  }\n  const version = decoded.words[0];\n  if (version >= 1 && encoding !== encodings.BECH32M) {\n    throw new Error('Version 1+ witness address must use Bech32m checksum');\n  }\n  return {\n    prefix: decoded.prefix,\n    data: Buffer.from(fromWords(decoded.words.slice(1))),\n    version\n  };\n};\n\n/**\n * Encode using BECH32 encoding\n * @param {String} prefix bech32 prefix\n * @param {Number} version\n * @param {String|Buffer} data \n * @param {String|Number} encoding (optional, default=bech32) Valid encodings are 'bech32', 'bech32m', 0, and 1.\n * @returns {String} encoded string\n */\nvar encode = function (prefix, version, data, encoding) {\n  if (typeof prefix !== 'string') {\n    throw new Error('Prefix should be a string');\n  }\n  if (typeof version !== 'number') {\n    throw new Error('version should be a number');\n  }\n  // convert string to number\n  if (encoding && typeof encoding == 'string') {\n    encoding = encodings[encoding.toUpperCase()] || -1; // fallback to -1 so it throws invalid encoding below\n  }\n\n  if (encoding && !(encoding == encodings.BECH32 || encoding == encodings.BECH32M)) {\n    throw new Error('Invalid encoding specified');\n  }\n  let b32Variety = encoding == encodings.BECH32M ? bech32.bech32m : bech32.bech32;\n  let words = b32Variety.toWords(data);\n  words.unshift(version);\n  return b32Variety.encode(prefix, words);\n};\nconst encodings = {\n  BECH32: 1,\n  BECH32M: 2\n};\nmodule.exports = {\n  decode: decode,\n  encode: encode,\n  encodings\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}