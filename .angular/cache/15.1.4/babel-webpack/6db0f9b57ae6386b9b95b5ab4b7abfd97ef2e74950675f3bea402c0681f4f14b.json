{"ast":null,"code":"'use strict';\n\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar Output = require('./output');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\nconst schnorr = require('bip-schnorr');\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript) {\n  var Transaction = require('./transaction');\n  var Input = require('./input');\n  var i;\n  // Copy transaction\n  var txcopy = Transaction.shallowCopy(transaction);\n\n  // Copy script\n  subscript = new Script(subscript);\n  subscript.removeCodeseparators();\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n  if ((sighashType & 31) === Signature.SIGHASH_NONE || (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');\n    }\n    txcopy.outputs.length = inputNumber + 1;\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n  var buf = new BufferWriter().write(txcopy.toBuffer()).writeInt32LE(sighashType).toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa';\n  let hashbuf = sighash(transaction, sighashType, inputIndex, subscript);\n  let sig;\n  switch (signingMethod) {\n    case 'ecdsa':\n      sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n        nhashtype: sighashType\n      });\n      break;\n    case 'schnorr':\n      sig = schnorr.sign(privateKey.toString(), hashbuf);\n      break;\n    default:\n      throw new Error(\"signingMethod not supported \", signingMethod);\n  }\n  return sig;\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, subscript, signingMethod) {\n  $.checkArgument(!_.isUndefined(transaction), \"Transaction Undefined\");\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), \"Signature Undefined\");\n  signingMethod = signingMethod || 'ecdsa';\n  let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);\n  let verified = false;\n  switch (signingMethod) {\n    case 'ecdsa':\n      verified = ECDSA.verify(hashbuf, signature, publicKey, 'little');\n      break;\n    case 'schnorr':\n      verified = schnorr.verify(publicKey, hashbuf, signature);\n      break;\n    default:\n      throw new Error(\"signingMethod not supported \", signingMethod);\n  }\n  return verified;\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};","map":{"version":3,"names":["Signature","require","Script","Output","BufferReader","BufferWriter","BN","Hash","ECDSA","$","_","schnorr","SIGHASH_SINGLE_BUG","BITS_64_ON","sighash","transaction","sighashType","inputNumber","subscript","Transaction","Input","i","txcopy","shallowCopy","removeCodeseparators","inputs","length","setScript","empty","SIGHASH_NONE","SIGHASH_SINGLE","sequenceNumber","outputs","Buffer","from","satoshis","fromBuffer","script","SIGHASH_ANYONECANPAY","buf","write","toBuffer","writeInt32LE","ret","sha256sha256","readReverse","sign","privateKey","inputIndex","signingMethod","hashbuf","sig","set","nhashtype","toString","Error","verify","signature","publicKey","checkArgument","isUndefined","verified","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFG - Enginering/BLOCKTICK/blocktick_dApp/node_modules/bitcore-lib/lib/transaction/sighash.js"],"sourcesContent":["'use strict';\n\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar Output = require('./output');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\nconst schnorr = require('bip-schnorr');\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript) {\n  var Transaction = require('./transaction');\n  var Input = require('./input');\n\n  var i;\n  // Copy transaction\n  var txcopy = Transaction.shallowCopy(transaction);\n\n  // Copy script\n  subscript = new Script(subscript);\n  subscript.removeCodeseparators();\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE ||\n    (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter()\n    .write(txcopy.toBuffer())\n    .writeInt32LE(sighashType)\n    .toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa';\n\n  let hashbuf = sighash(transaction, sighashType, inputIndex, subscript);\n  let sig; \n  switch (signingMethod) {\n    case 'ecdsa':\n      sig = ECDSA.sign(hashbuf, privateKey, 'little').set({ nhashtype: sighashType });\n      break;\n    case 'schnorr':\n      sig = schnorr.sign(privateKey.toString(), hashbuf);\n      break;\n    default: \n      throw new Error(\"signingMethod not supported \", signingMethod);\n  }\n  return sig;\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, subscript, signingMethod) {\n  $.checkArgument(!_.isUndefined(transaction), \"Transaction Undefined\");\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), \"Signature Undefined\");\n\n  signingMethod = signingMethod || 'ecdsa';\n  let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);\n  let verified = false;\n\n  switch (signingMethod) {\n    case 'ecdsa':\n      verified = ECDSA.verify(hashbuf, signature, publicKey, 'little');\n      break;\n    case 'schnorr':\n      verified = schnorr.verify(publicKey, hashbuf, signature);\n      break;\n    default:\n      throw new Error(\"signingMethod not supported \", signingMethod);\n  }\n  return verified;\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,SAAS,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AAC9C,IAAIC,MAAM,GAAGD,OAAO,CAAC,WAAW,CAAC;AACjC,IAAIE,MAAM,GAAGF,OAAO,CAAC,UAAU,CAAC;AAChC,IAAIG,YAAY,GAAGH,OAAO,CAAC,0BAA0B,CAAC;AACtD,IAAII,YAAY,GAAGJ,OAAO,CAAC,0BAA0B,CAAC;AACtD,IAAIK,EAAE,GAAGL,OAAO,CAAC,cAAc,CAAC;AAChC,IAAIM,IAAI,GAAGN,OAAO,CAAC,gBAAgB,CAAC;AACpC,IAAIO,KAAK,GAAGP,OAAO,CAAC,iBAAiB,CAAC;AACtC,IAAIQ,CAAC,GAAGR,OAAO,CAAC,uBAAuB,CAAC;AACxC,IAAIS,CAAC,GAAGT,OAAO,CAAC,QAAQ,CAAC;AACzB,MAAMU,OAAO,GAAGV,OAAO,CAAC,aAAa,CAAC;AAEtC,IAAIW,kBAAkB,GAAG,kEAAkE;AAC3F,IAAIC,UAAU,GAAG,kBAAkB;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,OAAO,GAAG,SAASA,OAAO,CAACC,WAAW,EAAEC,WAAW,EAAEC,WAAW,EAAEC,SAAS,EAAE;EAC/E,IAAIC,WAAW,GAAGlB,OAAO,CAAC,eAAe,CAAC;EAC1C,IAAImB,KAAK,GAAGnB,OAAO,CAAC,SAAS,CAAC;EAE9B,IAAIoB,CAAC;EACL;EACA,IAAIC,MAAM,GAAGH,WAAW,CAACI,WAAW,CAACR,WAAW,CAAC;;EAEjD;EACAG,SAAS,GAAG,IAAIhB,MAAM,CAACgB,SAAS,CAAC;EACjCA,SAAS,CAACM,oBAAoB,EAAE;EAEhC,KAAKH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,MAAM,CAACG,MAAM,CAACC,MAAM,EAAEL,CAAC,EAAE,EAAE;IACzC;IACAC,MAAM,CAACG,MAAM,CAACJ,CAAC,CAAC,GAAG,IAAID,KAAK,CAACE,MAAM,CAACG,MAAM,CAACJ,CAAC,CAAC,CAAC,CAACM,SAAS,CAACzB,MAAM,CAAC0B,KAAK,EAAE,CAAC;EAC1E;EAEAN,MAAM,CAACG,MAAM,CAACR,WAAW,CAAC,GAAG,IAAIG,KAAK,CAACE,MAAM,CAACG,MAAM,CAACR,WAAW,CAAC,CAAC,CAACU,SAAS,CAACT,SAAS,CAAC;EAEvF,IAAI,CAACF,WAAW,GAAG,EAAE,MAAMhB,SAAS,CAAC6B,YAAY,IAC/C,CAACb,WAAW,GAAG,EAAE,MAAMhB,SAAS,CAAC8B,cAAc,EAAE;IAEjD;IACA,KAAKT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,MAAM,CAACG,MAAM,CAACC,MAAM,EAAEL,CAAC,EAAE,EAAE;MACzC,IAAIA,CAAC,KAAKJ,WAAW,EAAE;QACrBK,MAAM,CAACG,MAAM,CAACJ,CAAC,CAAC,CAACU,cAAc,GAAG,CAAC;MACrC;IACF;EACF;EAEA,IAAI,CAACf,WAAW,GAAG,EAAE,MAAMhB,SAAS,CAAC6B,YAAY,EAAE;IACjDP,MAAM,CAACU,OAAO,GAAG,EAAE;EAErB,CAAC,MAAM,IAAI,CAAChB,WAAW,GAAG,EAAE,MAAMhB,SAAS,CAAC8B,cAAc,EAAE;IAC1D;IACA;IACA,IAAIb,WAAW,IAAIK,MAAM,CAACU,OAAO,CAACN,MAAM,EAAE;MACxC,OAAOO,MAAM,CAACC,IAAI,CAACtB,kBAAkB,EAAE,KAAK,CAAC;IAC/C;IAEAU,MAAM,CAACU,OAAO,CAACN,MAAM,GAAGT,WAAW,GAAG,CAAC;IAEvC,KAAKI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,EAAEI,CAAC,EAAE,EAAE;MAChCC,MAAM,CAACU,OAAO,CAACX,CAAC,CAAC,GAAG,IAAIlB,MAAM,CAAC;QAC7BgC,QAAQ,EAAE7B,EAAE,CAAC8B,UAAU,CAACH,MAAM,CAACC,IAAI,CAACrB,UAAU,EAAE,KAAK,CAAC,CAAC;QACvDwB,MAAM,EAAEnC,MAAM,CAAC0B,KAAK;MACtB,CAAC,CAAC;IACJ;EACF;EAEA,IAAIZ,WAAW,GAAGhB,SAAS,CAACsC,oBAAoB,EAAE;IAChDhB,MAAM,CAACG,MAAM,GAAG,CAACH,MAAM,CAACG,MAAM,CAACR,WAAW,CAAC,CAAC;EAC9C;EAEA,IAAIsB,GAAG,GAAG,IAAIlC,YAAY,EAAE,CACzBmC,KAAK,CAAClB,MAAM,CAACmB,QAAQ,EAAE,CAAC,CACxBC,YAAY,CAAC1B,WAAW,CAAC,CACzByB,QAAQ,EAAE;EACb,IAAIE,GAAG,GAAGpC,IAAI,CAACqC,YAAY,CAACL,GAAG,CAAC;EAChCI,GAAG,GAAG,IAAIvC,YAAY,CAACuC,GAAG,CAAC,CAACE,WAAW,EAAE;EACzC,OAAOF,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,IAAI,CAAC/B,WAAW,EAAEgC,UAAU,EAAE/B,WAAW,EAAEgC,UAAU,EAAE9B,SAAS,EAAE+B,aAAa,EAAE;EACxFA,aAAa,GAAGA,aAAa,IAAI,OAAO;EAExC,IAAIC,OAAO,GAAGpC,OAAO,CAACC,WAAW,EAAEC,WAAW,EAAEgC,UAAU,EAAE9B,SAAS,CAAC;EACtE,IAAIiC,GAAG;EACP,QAAQF,aAAa;IACnB,KAAK,OAAO;MACVE,GAAG,GAAG3C,KAAK,CAACsC,IAAI,CAACI,OAAO,EAAEH,UAAU,EAAE,QAAQ,CAAC,CAACK,GAAG,CAAC;QAAEC,SAAS,EAAErC;MAAY,CAAC,CAAC;MAC/E;IACF,KAAK,SAAS;MACZmC,GAAG,GAAGxC,OAAO,CAACmC,IAAI,CAACC,UAAU,CAACO,QAAQ,EAAE,EAAEJ,OAAO,CAAC;MAClD;IACF;MACE,MAAM,IAAIK,KAAK,CAAC,8BAA8B,EAAEN,aAAa,CAAC;EAAC;EAEnE,OAAOE,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,MAAM,CAACzC,WAAW,EAAE0C,SAAS,EAAEC,SAAS,EAAEV,UAAU,EAAE9B,SAAS,EAAE+B,aAAa,EAAE;EACvFxC,CAAC,CAACkD,aAAa,CAAC,CAACjD,CAAC,CAACkD,WAAW,CAAC7C,WAAW,CAAC,EAAE,uBAAuB,CAAC;EACrEN,CAAC,CAACkD,aAAa,CAAC,CAACjD,CAAC,CAACkD,WAAW,CAACH,SAAS,CAAC,IAAI,CAAC/C,CAAC,CAACkD,WAAW,CAACH,SAAS,CAACJ,SAAS,CAAC,EAAE,qBAAqB,CAAC;EAExGJ,aAAa,GAAGA,aAAa,IAAI,OAAO;EACxC,IAAIC,OAAO,GAAGpC,OAAO,CAACC,WAAW,EAAE0C,SAAS,CAACJ,SAAS,EAAEL,UAAU,EAAE9B,SAAS,CAAC;EAC9E,IAAI2C,QAAQ,GAAG,KAAK;EAEpB,QAAQZ,aAAa;IACnB,KAAK,OAAO;MACVY,QAAQ,GAAGrD,KAAK,CAACgD,MAAM,CAACN,OAAO,EAAEO,SAAS,EAAEC,SAAS,EAAE,QAAQ,CAAC;MAChE;IACF,KAAK,SAAS;MACZG,QAAQ,GAAGlD,OAAO,CAAC6C,MAAM,CAACE,SAAS,EAAER,OAAO,EAAEO,SAAS,CAAC;MACxD;IACF;MACE,MAAM,IAAIF,KAAK,CAAC,8BAA8B,EAAEN,aAAa,CAAC;EAAC;EAEnE,OAAOY,QAAQ;AACjB;;AAEA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG;EACfjD,OAAO,EAAEA,OAAO;EAChBgC,IAAI,EAAEA,IAAI;EACVU,MAAM,EAAEA;AACV,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}