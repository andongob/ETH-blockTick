{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst sha512_1 = require(\"@noble/hashes/sha512\");\nconst pbkdf2_1 = require(\"@noble/hashes/pbkdf2\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst _wordlists_1 = require(\"./_wordlists\");\nlet DEFAULT_WORDLIST = _wordlists_1._default;\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nconst WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' + 'Please pass a 2048 word array explicitly.';\nfunction normalize(str) {\n  return (str || '').normalize('NFKD');\n}\nfunction lpad(str, padString, length) {\n  while (str.length < length) {\n    str = padString + str;\n  }\n  return str;\n}\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => lpad(x.toString(2), '0', 8)).join('');\n}\nfunction deriveChecksumBits(entropyBuffer) {\n  const ENT = entropyBuffer.length * 8;\n  const CS = ENT / 32;\n  const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));\n  return bytesToBinary(Array.from(hash)).slice(0, CS);\n}\nfunction salt(password) {\n  return 'mnemonic' + (password || '');\n}\nfunction mnemonicToSeedSync(mnemonic, password) {\n  const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));\n  const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));\n  const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {\n    c: 2048,\n    dkLen: 64\n  });\n  return Buffer.from(res);\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\nfunction mnemonicToSeed(mnemonic, password) {\n  const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));\n  const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));\n  return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {\n    c: 2048,\n    dkLen: 64\n  }).then(res => Buffer.from(res));\n}\nexports.mnemonicToSeed = mnemonicToSeed;\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  wordlist = wordlist || DEFAULT_WORDLIST;\n  if (!wordlist) {\n    throw new Error(WORDLIST_REQUIRED);\n  }\n  const words = normalize(mnemonic).split(' ');\n  if (words.length % 3 !== 0) {\n    throw new Error(INVALID_MNEMONIC);\n  }\n  // convert word indices to 11 bit binary strings\n  const bits = words.map(word => {\n    const index = wordlist.indexOf(word);\n    if (index === -1) {\n      throw new Error(INVALID_MNEMONIC);\n    }\n    return lpad(index.toString(2), '0', 11);\n  }).join('');\n  // split the binary string into ENT/CS\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex);\n  // calculate the checksum and compare\n  const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n  if (entropyBytes.length < 16) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  if (entropyBytes.length > 32) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  if (entropyBytes.length % 4 !== 0) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  const entropy = Buffer.from(entropyBytes);\n  const newChecksum = deriveChecksumBits(entropy);\n  if (newChecksum !== checksumBits) {\n    throw new Error(INVALID_CHECKSUM);\n  }\n  return entropy.toString('hex');\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nfunction entropyToMnemonic(entropy, wordlist) {\n  if (!Buffer.isBuffer(entropy)) {\n    entropy = Buffer.from(entropy, 'hex');\n  }\n  wordlist = wordlist || DEFAULT_WORDLIST;\n  if (!wordlist) {\n    throw new Error(WORDLIST_REQUIRED);\n  }\n  // 128 <= ENT <= 256\n  if (entropy.length < 16) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n  if (entropy.length > 32) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n  if (entropy.length % 4 !== 0) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n  const entropyBits = bytesToBinary(Array.from(entropy));\n  const checksumBits = deriveChecksumBits(entropy);\n  const bits = entropyBits + checksumBits;\n  const chunks = bits.match(/(.{1,11})/g);\n  const words = chunks.map(binary => {\n    const index = binaryToByte(binary);\n    return wordlist[index];\n  });\n  return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093' // Japanese wordlist\n  ? words.join('\\u3000') : words.join(' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\nfunction generateMnemonic(strength, rng, wordlist) {\n  strength = strength || 128;\n  if (strength % 32 !== 0) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n  rng = rng || (size => Buffer.from(utils_1.randomBytes(size)));\n  return entropyToMnemonic(rng(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nfunction validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\nexports.validateMnemonic = validateMnemonic;\nfunction setDefaultWordlist(language) {\n  const result = _wordlists_1.wordlists[language];\n  if (result) {\n    DEFAULT_WORDLIST = result;\n  } else {\n    throw new Error('Could not find wordlist for language \"' + language + '\"');\n  }\n}\nexports.setDefaultWordlist = setDefaultWordlist;\nfunction getDefaultWordlist() {\n  if (!DEFAULT_WORDLIST) {\n    throw new Error('No Default Wordlist set');\n  }\n  return Object.keys(_wordlists_1.wordlists).filter(lang => {\n    if (lang === 'JA' || lang === 'EN') {\n      return false;\n    }\n    return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\n  })[0];\n}\nexports.getDefaultWordlist = getDefaultWordlist;\nvar _wordlists_2 = require(\"./_wordlists\");\nexports.wordlists = _wordlists_2.wordlists;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}