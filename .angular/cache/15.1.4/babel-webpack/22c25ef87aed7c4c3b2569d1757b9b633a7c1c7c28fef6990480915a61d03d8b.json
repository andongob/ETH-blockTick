{"ast":null,"code":"'use strict';\n\nvar BN = require('./bn');\nvar Point = require('./point');\nvar Signature = require('./signature');\nvar PublicKey = require('../publickey');\nvar Random = require('./random');\nvar Hash = require('./hash');\nvar BufferUtil = require('../util/buffer');\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\nvar ECDSA = function ECDSA(obj) {\n  if (!(this instanceof ECDSA)) {\n    return new ECDSA(obj);\n  }\n  if (obj) {\n    this.set(obj);\n  }\n};\n\n/* jshint maxcomplexity: 9 */\nECDSA.prototype.set = function (obj) {\n  this.hashbuf = obj.hashbuf || this.hashbuf;\n  this.endian = obj.endian || this.endian; //the endianness of hashbuf\n  this.privkey = obj.privkey || this.privkey;\n  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);\n  this.sig = obj.sig || this.sig;\n  this.k = obj.k || this.k;\n  this.verified = obj.verified || this.verified;\n  return this;\n};\nECDSA.prototype.privkey2pubkey = function () {\n  this.pubkey = this.privkey.toPublicKey();\n};\nECDSA.prototype.calci = function () {\n  for (var i = 0; i < 4; i++) {\n    this.sig.i = i;\n    var Qprime;\n    try {\n      Qprime = this.toPublicKey();\n    } catch (e) {\n      console.error(e);\n      continue;\n    }\n    if (Qprime.point.eq(this.pubkey.point)) {\n      this.sig.compressed = this.pubkey.compressed;\n      return this;\n    }\n  }\n  this.sig.i = undefined;\n  throw new Error('Unable to find valid recovery factor');\n};\nECDSA.fromString = function (str) {\n  var obj = JSON.parse(str);\n  return new ECDSA(obj);\n};\nECDSA.prototype.randomK = function () {\n  var N = Point.getN();\n  var k;\n  do {\n    k = BN.fromBuffer(Random.getRandomBuffer(32));\n  } while (!(k.lt(N) && k.gt(BN.Zero)));\n  this.k = k;\n  return this;\n};\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nECDSA.prototype.deterministicK = function (badrs) {\n  /* jshint maxstatements: 25 */\n  // if r or s were invalid when this function was used in signing,\n  // we do not want to actually compute r, s here for efficiency, so,\n  // we can increment badrs. explained at end of RFC 6979 section 3.2\n  if (_.isUndefined(badrs)) {\n    badrs = 0;\n  }\n  var v = Buffer.alloc(32);\n  v.fill(0x01);\n  var k = Buffer.alloc(32);\n  k.fill(0x00);\n  var x = this.privkey.bn.toBuffer({\n    size: 32\n  });\n  var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf;\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x01]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  v = Hash.sha256hmac(v, k);\n  var T = BN.fromBuffer(v);\n  var N = Point.getN();\n\n  // also explained in 3.2, we must ensure T is in the proper range (0, N)\n  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {\n    k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00])]), k);\n    v = Hash.sha256hmac(v, k);\n    v = Hash.sha256hmac(v, k);\n    T = BN.fromBuffer(v);\n  }\n  this.k = T;\n  return this;\n};\n\n// Information about public key recovery:\n// https://bitcointalk.org/index.php?topic=6430.0\n// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k\nECDSA.prototype.toPublicKey = function () {\n  /* jshint maxstatements: 25 */\n  var i = this.sig.i;\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));\n  var e = BN.fromBuffer(this.hashbuf);\n  var r = this.sig.r;\n  var s = this.sig.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = i & 1;\n\n  // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n  var isSecondKey = i >> 1;\n  var n = Point.getN();\n  var G = Point.getG();\n\n  // 1.1 Let x = r + jn\n  var x = isSecondKey ? r.add(n) : r;\n  var R = Point.fromX(isYOdd, x);\n\n  // 1.4 Check that nR is at infinity\n  var nR = R.mul(n);\n  if (!nR.isInfinity()) {\n    throw new Error('nR is not a valid curve point');\n  }\n\n  // Compute -e from e\n  var eNeg = e.neg().umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR - eG)\n  // Q = r^-1 (sR + -eG)\n  var rInv = r.invm(n);\n\n  //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);\n  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);\n  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);\n  return pubkey;\n};\nECDSA.prototype.sigError = function () {\n  /* jshint maxstatements: 25 */\n  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {\n    return 'hashbuf must be a 32 byte buffer';\n  }\n  var r = this.sig.r;\n  var s = this.sig.s;\n  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {\n    return 'r and s not in range';\n  }\n  var e = BN.fromBuffer(this.hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n  var n = Point.getN();\n  var sinv = s.invm(n);\n  var u1 = sinv.mul(e).umod(n);\n  var u2 = sinv.mul(r).umod(n);\n  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);\n  if (p.isInfinity()) {\n    return 'p is infinity';\n  }\n  if (p.getX().umod(n).cmp(r) !== 0) {\n    return 'Invalid signature';\n  } else {\n    return false;\n  }\n};\nECDSA.toLowS = function (s) {\n  //enforce low s\n  //see BIP 62, \"low S values in signatures\"\n  if (s.gt(BN.fromBuffer(Buffer.from('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {\n    s = Point.getN().sub(s);\n  }\n  return s;\n};\nECDSA.prototype._findSignature = function (d, e) {\n  var N = Point.getN();\n  var G = Point.getG();\n  // try different values of k until r, s are valid\n  var badrs = 0;\n  var k, Q, r, s;\n  do {\n    if (!this.k || badrs > 0) {\n      this.deterministicK(badrs);\n    }\n    badrs++;\n    k = this.k;\n    Q = G.mul(k);\n    r = Q.x.umod(N);\n    s = k.invm(N).mul(e.add(d.mul(r))).umod(N);\n  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);\n  s = ECDSA.toLowS(s);\n  return {\n    s: s,\n    r: r\n  };\n};\nECDSA.prototype.sign = function () {\n  var hashbuf = this.hashbuf;\n  var privkey = this.privkey;\n  var d = privkey.bn;\n  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));\n  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));\n  var e = BN.fromBuffer(hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n  var obj = this._findSignature(d, e);\n  obj.compressed = this.pubkey.compressed;\n  this.sig = new Signature(obj);\n  return this;\n};\nECDSA.prototype.signRandomK = function () {\n  this.randomK();\n  return this.sign();\n};\nECDSA.prototype.toString = function () {\n  var obj = {};\n  if (this.hashbuf) {\n    obj.hashbuf = this.hashbuf.toString('hex');\n  }\n  if (this.privkey) {\n    obj.privkey = this.privkey.toString();\n  }\n  if (this.pubkey) {\n    obj.pubkey = this.pubkey.toString();\n  }\n  if (this.sig) {\n    obj.sig = this.sig.toString();\n  }\n  if (this.k) {\n    obj.k = this.k.toString();\n  }\n  return JSON.stringify(obj);\n};\nECDSA.prototype.verify = function () {\n  if (!this.sigError()) {\n    this.verified = true;\n  } else {\n    this.verified = false;\n  }\n  return this;\n};\nECDSA.sign = function (hashbuf, privkey, endian) {\n  return ECDSA().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    privkey: privkey\n  }).sign().sig;\n};\nECDSA.verify = function (hashbuf, sig, pubkey, endian) {\n  return ECDSA().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    sig: sig,\n    pubkey: pubkey\n  }).verify().verified;\n};\nmodule.exports = ECDSA;","map":{"version":3,"names":["BN","require","Point","Signature","PublicKey","Random","Hash","BufferUtil","_","$","ECDSA","obj","set","prototype","hashbuf","endian","privkey","pubkey","publicKey","sig","k","verified","privkey2pubkey","toPublicKey","calci","i","Qprime","e","console","error","point","eq","compressed","undefined","Error","fromString","str","JSON","parse","randomK","N","getN","fromBuffer","getRandomBuffer","lt","gt","Zero","deterministicK","badrs","isUndefined","v","Buffer","alloc","fill","x","bn","toBuffer","size","reverse","sha256hmac","concat","from","T","checkArgument","r","s","isYOdd","isSecondKey","n","G","getG","add","R","fromX","nR","mul","isInfinity","eNeg","neg","umod","rInv","invm","Q","fromPoint","sigError","isBuffer","length","sinv","u1","u2","p","mulAdd","getX","cmp","toLowS","sub","_findSignature","d","sign","checkState","signRandomK","toString","stringify","verify","module","exports"],"sources":["C:/Users/Ndongo/Desktop/noborrar/Ethereum-Blocktick/node_modules/bitcore-lib/lib/crypto/ecdsa.js"],"sourcesContent":["'use strict';\r\n\r\nvar BN = require('./bn');\r\nvar Point = require('./point');\r\nvar Signature = require('./signature');\r\nvar PublicKey = require('../publickey');\r\nvar Random = require('./random');\r\nvar Hash = require('./hash');\r\nvar BufferUtil = require('../util/buffer');\r\nvar _ = require('lodash');\r\nvar $ = require('../util/preconditions');\r\n\r\nvar ECDSA = function ECDSA(obj) {\r\n  if (!(this instanceof ECDSA)) {\r\n    return new ECDSA(obj);\r\n  }\r\n  if (obj) {\r\n    this.set(obj);\r\n  }\r\n};\r\n\r\n/* jshint maxcomplexity: 9 */\r\nECDSA.prototype.set = function(obj) {\r\n  this.hashbuf = obj.hashbuf || this.hashbuf;\r\n  this.endian = obj.endian || this.endian; //the endianness of hashbuf\r\n  this.privkey = obj.privkey || this.privkey;\r\n  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);\r\n  this.sig = obj.sig || this.sig;\r\n  this.k = obj.k || this.k;\r\n  this.verified = obj.verified || this.verified;\r\n  return this;\r\n};\r\n\r\nECDSA.prototype.privkey2pubkey = function() {\r\n  this.pubkey = this.privkey.toPublicKey();\r\n};\r\n\r\nECDSA.prototype.calci = function() {\r\n  for (var i = 0; i < 4; i++) {\r\n    this.sig.i = i;\r\n    var Qprime;\r\n    try {\r\n      Qprime = this.toPublicKey();\r\n    } catch (e) {\r\n      console.error(e);\r\n      continue;\r\n    }\r\n\r\n    if (Qprime.point.eq(this.pubkey.point)) {\r\n      this.sig.compressed = this.pubkey.compressed;\r\n      return this;\r\n    }\r\n  }\r\n\r\n  this.sig.i = undefined;\r\n  throw new Error('Unable to find valid recovery factor');\r\n};\r\n\r\nECDSA.fromString = function(str) {\r\n  var obj = JSON.parse(str);\r\n  return new ECDSA(obj);\r\n};\r\n\r\nECDSA.prototype.randomK = function() {\r\n  var N = Point.getN();\r\n  var k;\r\n  do {\r\n    k = BN.fromBuffer(Random.getRandomBuffer(32));\r\n  } while (!(k.lt(N) && k.gt(BN.Zero)));\r\n  this.k = k;\r\n  return this;\r\n};\r\n\r\n\r\n// https://tools.ietf.org/html/rfc6979#section-3.2\r\nECDSA.prototype.deterministicK = function(badrs) {\r\n  /* jshint maxstatements: 25 */\r\n  // if r or s were invalid when this function was used in signing,\r\n  // we do not want to actually compute r, s here for efficiency, so,\r\n  // we can increment badrs. explained at end of RFC 6979 section 3.2\r\n  if (_.isUndefined(badrs)) {\r\n    badrs = 0;\r\n  }\r\n  var v = Buffer.alloc(32);\r\n  v.fill(0x01);\r\n  var k = Buffer.alloc(32);\r\n  k.fill(0x00);\r\n  var x = this.privkey.bn.toBuffer({\r\n    size: 32\r\n  });\r\n  var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf\r\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00]), x, hashbuf]), k);\r\n  v = Hash.sha256hmac(v, k);\r\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x01]), x, hashbuf]), k);\r\n  v = Hash.sha256hmac(v, k);\r\n  v = Hash.sha256hmac(v, k);\r\n  var T = BN.fromBuffer(v);\r\n  var N = Point.getN();\r\n\r\n  // also explained in 3.2, we must ensure T is in the proper range (0, N)\r\n  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {\r\n    k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00])]), k);\r\n    v = Hash.sha256hmac(v, k);\r\n    v = Hash.sha256hmac(v, k);\r\n    T = BN.fromBuffer(v);\r\n  }\r\n\r\n  this.k = T;\r\n  return this;\r\n};\r\n\r\n// Information about public key recovery:\r\n// https://bitcointalk.org/index.php?topic=6430.0\r\n// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k\r\nECDSA.prototype.toPublicKey = function() {\r\n  /* jshint maxstatements: 25 */\r\n  var i = this.sig.i;\r\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));\r\n\r\n  var e = BN.fromBuffer(this.hashbuf);\r\n  var r = this.sig.r;\r\n  var s = this.sig.s;\r\n\r\n  // A set LSB signifies that the y-coordinate is odd\r\n  var isYOdd = i & 1;\r\n\r\n  // The more significant bit specifies whether we should use the\r\n  // first or second candidate key.\r\n  var isSecondKey = i >> 1;\r\n\r\n  var n = Point.getN();\r\n  var G = Point.getG();\r\n\r\n  // 1.1 Let x = r + jn\r\n  var x = isSecondKey ? r.add(n) : r;\r\n  var R = Point.fromX(isYOdd, x);\r\n\r\n  // 1.4 Check that nR is at infinity\r\n  var nR = R.mul(n);\r\n\r\n  if (!nR.isInfinity()) {\r\n    throw new Error('nR is not a valid curve point');\r\n  }\r\n\r\n  // Compute -e from e\r\n  var eNeg = e.neg().umod(n);\r\n\r\n  // 1.6.1 Compute Q = r^-1 (sR - eG)\r\n  // Q = r^-1 (sR + -eG)\r\n  var rInv = r.invm(n);\r\n\r\n  //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);\r\n  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);\r\n\r\n  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);\r\n\r\n  return pubkey;\r\n};\r\n\r\nECDSA.prototype.sigError = function() {\r\n  /* jshint maxstatements: 25 */\r\n  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {\r\n    return 'hashbuf must be a 32 byte buffer';\r\n  }\r\n\r\n  var r = this.sig.r;\r\n  var s = this.sig.s;\r\n  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {\r\n    return 'r and s not in range';\r\n  }\r\n\r\n  var e = BN.fromBuffer(this.hashbuf, this.endian ? {\r\n    endian: this.endian\r\n  } : undefined);\r\n  var n = Point.getN();\r\n  var sinv = s.invm(n);\r\n  var u1 = sinv.mul(e).umod(n);\r\n  var u2 = sinv.mul(r).umod(n);\r\n\r\n  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);\r\n  if (p.isInfinity()) {\r\n    return 'p is infinity';\r\n  }\r\n\r\n  if (p.getX().umod(n).cmp(r) !== 0) {\r\n    return 'Invalid signature';\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\nECDSA.toLowS = function(s) {\r\n  //enforce low s\r\n  //see BIP 62, \"low S values in signatures\"\r\n  if (s.gt(BN.fromBuffer(Buffer.from('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {\r\n    s = Point.getN().sub(s);\r\n  }\r\n  return s;\r\n};\r\n\r\nECDSA.prototype._findSignature = function(d, e) {\r\n  var N = Point.getN();\r\n  var G = Point.getG();\r\n  // try different values of k until r, s are valid\r\n  var badrs = 0;\r\n  var k, Q, r, s;\r\n  do {\r\n    if (!this.k || badrs > 0) {\r\n      this.deterministicK(badrs);\r\n    }\r\n    badrs++;\r\n    k = this.k;\r\n    Q = G.mul(k);\r\n    r = Q.x.umod(N);\r\n    s = k.invm(N).mul(e.add(d.mul(r))).umod(N);\r\n  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);\r\n\r\n  s = ECDSA.toLowS(s);\r\n  return {\r\n    s: s,\r\n    r: r\r\n  };\r\n\r\n};\r\n\r\nECDSA.prototype.sign = function() {\r\n  var hashbuf = this.hashbuf;\r\n  var privkey = this.privkey;\r\n  var d = privkey.bn;\r\n\r\n  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));\r\n  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));\r\n\r\n  var e = BN.fromBuffer(hashbuf, this.endian ? {\r\n    endian: this.endian\r\n  } : undefined);\r\n\r\n  var obj = this._findSignature(d, e);\r\n  obj.compressed = this.pubkey.compressed;\r\n\r\n  this.sig = new Signature(obj);\r\n  return this;\r\n};\r\n\r\nECDSA.prototype.signRandomK = function() {\r\n  this.randomK();\r\n  return this.sign();\r\n};\r\n\r\nECDSA.prototype.toString = function() {\r\n  var obj = {};\r\n  if (this.hashbuf) {\r\n    obj.hashbuf = this.hashbuf.toString('hex');\r\n  }\r\n  if (this.privkey) {\r\n    obj.privkey = this.privkey.toString();\r\n  }\r\n  if (this.pubkey) {\r\n    obj.pubkey = this.pubkey.toString();\r\n  }\r\n  if (this.sig) {\r\n    obj.sig = this.sig.toString();\r\n  }\r\n  if (this.k) {\r\n    obj.k = this.k.toString();\r\n  }\r\n  return JSON.stringify(obj);\r\n};\r\n\r\nECDSA.prototype.verify = function() {\r\n  if (!this.sigError()) {\r\n    this.verified = true;\r\n  } else {\r\n    this.verified = false;\r\n  }\r\n  return this;\r\n};\r\n\r\nECDSA.sign = function(hashbuf, privkey, endian) {\r\n  return ECDSA().set({\r\n    hashbuf: hashbuf,\r\n    endian: endian,\r\n    privkey: privkey\r\n  }).sign().sig;\r\n};\r\n\r\nECDSA.verify = function(hashbuf, sig, pubkey, endian) {\r\n  return ECDSA().set({\r\n    hashbuf: hashbuf,\r\n    endian: endian,\r\n    sig: sig,\r\n    pubkey: pubkey\r\n  }).verify().verified;\r\n};\r\n\r\nmodule.exports = ECDSA;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}