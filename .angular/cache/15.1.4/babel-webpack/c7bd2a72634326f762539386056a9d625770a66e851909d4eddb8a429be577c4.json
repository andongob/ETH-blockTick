{"ast":null,"code":"const BigInteger = require('bigi');\nconst Buffer = require('safe-buffer').Buffer;\nconst ecurve = require('ecurve');\nconst curve = ecurve.getCurveByName('secp256k1');\nconst one = BigInteger.ONE;\nconst n = curve.n;\nconst p = curve.p;\nfunction checkBuffer(name, buf, len, idx) {\n  const idxStr = idx !== undefined ? '[' + idx + ']' : '';\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error(name + idxStr + ' must be a Buffer');\n  }\n  if (buf.length !== len) {\n    throw new Error(name + idxStr + ' must be ' + len + ' bytes long');\n  }\n}\nfunction checkArray(name, arr) {\n  if (!arr || !arr.length) {\n    throw new Error(name + ' must be an array with one or more elements');\n  }\n}\nfunction checkPubKeyArr(pubKeys) {\n  checkArray('pubKeys', pubKeys);\n  for (let i = 0; i < pubKeys.length; i++) {\n    checkBuffer('pubKey', pubKeys[i], 32, i);\n  }\n}\nfunction checkMessageArr(messages) {\n  checkArray('messages', messages);\n  for (let i = 0; i < messages.length; i++) {\n    checkBuffer('message', messages[i], 32, i);\n  }\n}\nfunction checkSignatureArr(signatures) {\n  checkArray('signatures', signatures);\n  for (let i = 0; i < signatures.length; i++) {\n    checkBuffer('signature', signatures[i], 64, i);\n  }\n}\nfunction checkNonceArr(nonces) {\n  checkArray('nonces', nonces);\n  for (let i = 0; i < nonces.length; i++) {\n    checkBuffer('nonce', nonces[i], 32, i);\n  }\n}\nfunction checkPrivateKey(privateKey, idx) {\n  const idxStr = idx !== undefined ? '[' + idx + ']' : '';\n  if (!BigInteger.isBigInteger(privateKey) && !(typeof privateKey == 'string')) {\n    throw new Error('privateKey' + idxStr + ' must be a BigInteger or valid hex string');\n  }\n  if (typeof privateKey == 'string') {\n    if (privateKey.match(/[^a-f^A-F^0-9]+/)) {\n      throw new Error('privateKey must be a BigInteger or valid hex string');\n    }\n    checkRange('privateKey', BigInteger.fromHex(privateKey));\n    return;\n  }\n  checkRange('privateKey', privateKey);\n}\nfunction checkSignParams(privateKey, message) {\n  checkPrivateKey(privateKey);\n  checkBuffer('message', message, 32);\n}\nfunction checkVerifyParams(pubKey, message, signature) {\n  checkBuffer('pubKey', pubKey, 32);\n  checkBuffer('message', message, 32);\n  checkBuffer('signature', signature, 64);\n}\nfunction checkBatchVerifyParams(pubKeys, messages, signatures) {\n  checkPubKeyArr(pubKeys);\n  checkMessageArr(messages);\n  checkSignatureArr(signatures);\n  if (pubKeys.length !== messages.length || messages.length !== signatures.length) {\n    throw new Error('all parameters must be an array with the same length');\n  }\n}\nfunction checkSessionParams(sessionId, privateKey, message, pubKeyCombined, ell) {\n  checkSignParams(privateKey, message);\n  checkBuffer('sessionId', sessionId, 32);\n  checkBuffer('pubKeyCombined', pubKeyCombined, 32);\n  checkBuffer('ell', ell, 32);\n}\nfunction checkRange(name, scalar) {\n  if (scalar.compareTo(one) < 0 || scalar.compareTo(n.subtract(one)) > 0) {\n    throw new Error(name + ' must be an integer in the range 1..n-1');\n  }\n}\nfunction checkSignatureInput(r, s) {\n  if (r.compareTo(p) >= 0) {\n    throw new Error('r is larger than or equal to field size');\n  }\n  if (s.compareTo(n) >= 0) {\n    throw new Error('s is larger than or equal to curve order');\n  }\n}\nfunction checkPointExists(pubKeyEven, P) {\n  if (P.curve.isInfinity(P)) {\n    throw new Error('point is at infinity');\n  }\n  const pEven = P.affineY.isEven();\n  if (pubKeyEven !== pEven) {\n    throw new Error('point does not exist');\n  }\n}\nfunction checkAux(aux) {\n  if (aux.length !== 32) {\n    throw new Error('aux must be 32 bytes');\n  }\n}\nmodule.exports = {\n  checkSessionParams,\n  checkSignParams,\n  checkVerifyParams,\n  checkBatchVerifyParams,\n  checkRange,\n  checkSignatureInput,\n  checkPointExists,\n  checkPubKeyArr,\n  checkArray,\n  checkNonceArr,\n  checkAux\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}