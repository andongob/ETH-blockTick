{"ast":null,"code":"const errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD: 'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n};\nfunction assert(cond, msg) {\n  if (!cond) throw new Error(msg);\n}\nfunction isUint8Array(name, value, length) {\n  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      const numbers = length.join(', ');\n      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;\n      assert(length.includes(value.length), msg);\n    } else {\n      const msg = `Expected ${name} to be an Uint8Array with length ${length}`;\n      assert(value.length === length, msg);\n    }\n  }\n}\nfunction isCompressed(value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean');\n}\nfunction getAssertedOutput(output = len => new Uint8Array(len), length) {\n  if (typeof output === 'function') output = output(length);\n  isUint8Array('output', output, length);\n  return output;\n}\nfunction toTypeString(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\nmodule.exports = secp256k1 => {\n  return {\n    contextRandomize(seed) {\n      assert(seed === null || seed instanceof Uint8Array, 'Expected seed to be an Uint8Array or null');\n      if (seed !== null) isUint8Array('seed', seed, 32);\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);\n      }\n    },\n    privateKeyVerify(seckey) {\n      isUint8Array('private key', seckey, 32);\n      return secp256k1.privateKeyVerify(seckey) === 0;\n    },\n    privateKeyNegate(seckey) {\n      isUint8Array('private key', seckey, 32);\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey;\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    privateKeyTweakAdd(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey;\n        case 1:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n    privateKeyTweakMul(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey;\n        case 1:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n    publicKeyVerify(pubkey) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      return secp256k1.publicKeyVerify(pubkey) === 0;\n    },\n    publicKeyCreate(seckey, compressed = true, output) {\n      isUint8Array('private key', seckey, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.SECKEY_INVALID);\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyConvert(pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyNegate(pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyCombine(pubkeys, compressed = true, output) {\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array');\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items');\n      for (const pubkey of pubkeys) {\n        isUint8Array('public key', pubkey, [33, 65]);\n      }\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE);\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n    publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n        case 2:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n    publicKeyTweakMul(pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n        case 2:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n    signatureNormalize(sig) {\n      isUint8Array('signature', sig, 64);\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig;\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n      }\n    },\n    signatureExport(sig, output) {\n      isUint8Array('signature', sig, 64);\n      output = getAssertedOutput(output, 72);\n      const obj = {\n        output,\n        outputlen: 72\n      };\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen);\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    signatureImport(sig, output) {\n      isUint8Array('signature', sig);\n      output = getAssertedOutput(output, 64);\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdsaSign(msg32, seckey, options = {}, output) {\n      isUint8Array('message', msg32, 32);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function');\n      output = getAssertedOutput(output, 64);\n      const obj = {\n        signature: output,\n        recid: null\n      };\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj;\n        case 1:\n          throw new Error(errors.SIGN);\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdsaVerify(sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64);\n      isUint8Array('message', msg32, 32);\n      isUint8Array('public key', pubkey, [33, 65]);\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true;\n        case 3:\n          return false;\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE);\n      }\n    },\n    ecdsaRecover(sig, recid, msg32, compressed = true, output) {\n      isUint8Array('signature', sig, 64);\n      assert(toTypeString(recid) === 'Number' && recid >= 0 && recid <= 3, 'Expected recovery id to be a Number within interval [0, 3]');\n      isUint8Array('message', msg32, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n        case 2:\n          throw new Error(errors.RECOVER);\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n    ecdh(pubkey, seckey, options = {}, output) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function');\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32);\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32);\n        isUint8Array('output', output);\n      } else {\n        output = getAssertedOutput(output, 32);\n      }\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output;\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n        case 2:\n          throw new Error(errors.ECDH);\n      }\n    }\n  };\n};","map":{"version":3,"names":["errors","IMPOSSIBLE_CASE","TWEAK_ADD","TWEAK_MUL","CONTEXT_RANDOMIZE_UNKNOW","SECKEY_INVALID","PUBKEY_PARSE","PUBKEY_SERIALIZE","PUBKEY_COMBINE","SIG_PARSE","SIGN","RECOVER","ECDH","assert","cond","msg","Error","isUint8Array","name","value","length","Uint8Array","undefined","Array","isArray","numbers","join","includes","isCompressed","toTypeString","getAssertedOutput","output","len","Object","prototype","toString","call","slice","module","exports","secp256k1","contextRandomize","seed","privateKeyVerify","seckey","privateKeyNegate","privateKeyTweakAdd","tweak","privateKeyTweakMul","publicKeyVerify","pubkey","publicKeyCreate","compressed","publicKeyConvert","publicKeyNegate","publicKeyCombine","pubkeys","publicKeyTweakAdd","publicKeyTweakMul","signatureNormalize","sig","signatureExport","obj","outputlen","signatureImport","ecdsaSign","msg32","options","data","noncefn","signature","recid","ecdsaVerify","ecdsaRecover","ecdh","hashfn","xbuf","ybuf"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/secp256k1/lib/index.js"],"sourcesContent":["const errors = {\r\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\r\n  TWEAK_ADD:\r\n    'The tweak was out of range or the resulted private key is invalid',\r\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\r\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\r\n  SECKEY_INVALID: 'Private Key is invalid',\r\n  PUBKEY_PARSE: 'Public Key could not be parsed',\r\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\r\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\r\n  SIG_PARSE: 'Signature could not be parsed',\r\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\r\n  RECOVER: 'Public key could not be recover',\r\n  ECDH: 'Scalar was invalid (zero or overflow)'\r\n}\r\n\r\nfunction assert (cond, msg) {\r\n  if (!cond) throw new Error(msg)\r\n}\r\n\r\nfunction isUint8Array (name, value, length) {\r\n  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)\r\n\r\n  if (length !== undefined) {\r\n    if (Array.isArray(length)) {\r\n      const numbers = length.join(', ')\r\n      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`\r\n      assert(length.includes(value.length), msg)\r\n    } else {\r\n      const msg = `Expected ${name} to be an Uint8Array with length ${length}`\r\n      assert(value.length === length, msg)\r\n    }\r\n  }\r\n}\r\n\r\nfunction isCompressed (value) {\r\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')\r\n}\r\n\r\nfunction getAssertedOutput (output = (len) => new Uint8Array(len), length) {\r\n  if (typeof output === 'function') output = output(length)\r\n  isUint8Array('output', output, length)\r\n  return output\r\n}\r\n\r\nfunction toTypeString (value) {\r\n  return Object.prototype.toString.call(value).slice(8, -1)\r\n}\r\n\r\nmodule.exports = (secp256k1) => {\r\n  return {\r\n    contextRandomize (seed) {\r\n      assert(\r\n        seed === null || seed instanceof Uint8Array,\r\n        'Expected seed to be an Uint8Array or null'\r\n      )\r\n      if (seed !== null) isUint8Array('seed', seed, 32)\r\n\r\n      switch (secp256k1.contextRandomize(seed)) {\r\n        case 1:\r\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)\r\n      }\r\n    },\r\n\r\n    privateKeyVerify (seckey) {\r\n      isUint8Array('private key', seckey, 32)\r\n\r\n      return secp256k1.privateKeyVerify(seckey) === 0\r\n    },\r\n\r\n    privateKeyNegate (seckey) {\r\n      isUint8Array('private key', seckey, 32)\r\n\r\n      switch (secp256k1.privateKeyNegate(seckey)) {\r\n        case 0:\r\n          return seckey\r\n        case 1:\r\n          throw new Error(errors.IMPOSSIBLE_CASE)\r\n      }\r\n    },\r\n\r\n    privateKeyTweakAdd (seckey, tweak) {\r\n      isUint8Array('private key', seckey, 32)\r\n      isUint8Array('tweak', tweak, 32)\r\n\r\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\r\n        case 0:\r\n          return seckey\r\n        case 1:\r\n          throw new Error(errors.TWEAK_ADD)\r\n      }\r\n    },\r\n\r\n    privateKeyTweakMul (seckey, tweak) {\r\n      isUint8Array('private key', seckey, 32)\r\n      isUint8Array('tweak', tweak, 32)\r\n\r\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\r\n        case 0:\r\n          return seckey\r\n        case 1:\r\n          throw new Error(errors.TWEAK_MUL)\r\n      }\r\n    },\r\n\r\n    publicKeyVerify (pubkey) {\r\n      isUint8Array('public key', pubkey, [33, 65])\r\n\r\n      return secp256k1.publicKeyVerify(pubkey) === 0\r\n    },\r\n\r\n    publicKeyCreate (seckey, compressed = true, output) {\r\n      isUint8Array('private key', seckey, 32)\r\n      isCompressed(compressed)\r\n      output = getAssertedOutput(output, compressed ? 33 : 65)\r\n\r\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\r\n        case 0:\r\n          return output\r\n        case 1:\r\n          throw new Error(errors.SECKEY_INVALID)\r\n        case 2:\r\n          throw new Error(errors.PUBKEY_SERIALIZE)\r\n      }\r\n    },\r\n\r\n    publicKeyConvert (pubkey, compressed = true, output) {\r\n      isUint8Array('public key', pubkey, [33, 65])\r\n      isCompressed(compressed)\r\n      output = getAssertedOutput(output, compressed ? 33 : 65)\r\n\r\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\r\n        case 0:\r\n          return output\r\n        case 1:\r\n          throw new Error(errors.PUBKEY_PARSE)\r\n        case 2:\r\n          throw new Error(errors.PUBKEY_SERIALIZE)\r\n      }\r\n    },\r\n\r\n    publicKeyNegate (pubkey, compressed = true, output) {\r\n      isUint8Array('public key', pubkey, [33, 65])\r\n      isCompressed(compressed)\r\n      output = getAssertedOutput(output, compressed ? 33 : 65)\r\n\r\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\r\n        case 0:\r\n          return output\r\n        case 1:\r\n          throw new Error(errors.PUBKEY_PARSE)\r\n        case 2:\r\n          throw new Error(errors.IMPOSSIBLE_CASE)\r\n        case 3:\r\n          throw new Error(errors.PUBKEY_SERIALIZE)\r\n      }\r\n    },\r\n\r\n    publicKeyCombine (pubkeys, compressed = true, output) {\r\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')\r\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')\r\n      for (const pubkey of pubkeys) {\r\n        isUint8Array('public key', pubkey, [33, 65])\r\n      }\r\n      isCompressed(compressed)\r\n      output = getAssertedOutput(output, compressed ? 33 : 65)\r\n\r\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\r\n        case 0:\r\n          return output\r\n        case 1:\r\n          throw new Error(errors.PUBKEY_PARSE)\r\n        case 2:\r\n          throw new Error(errors.PUBKEY_COMBINE)\r\n        case 3:\r\n          throw new Error(errors.PUBKEY_SERIALIZE)\r\n      }\r\n    },\r\n\r\n    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {\r\n      isUint8Array('public key', pubkey, [33, 65])\r\n      isUint8Array('tweak', tweak, 32)\r\n      isCompressed(compressed)\r\n      output = getAssertedOutput(output, compressed ? 33 : 65)\r\n\r\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\r\n        case 0:\r\n          return output\r\n        case 1:\r\n          throw new Error(errors.PUBKEY_PARSE)\r\n        case 2:\r\n          throw new Error(errors.TWEAK_ADD)\r\n      }\r\n    },\r\n\r\n    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {\r\n      isUint8Array('public key', pubkey, [33, 65])\r\n      isUint8Array('tweak', tweak, 32)\r\n      isCompressed(compressed)\r\n      output = getAssertedOutput(output, compressed ? 33 : 65)\r\n\r\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\r\n        case 0:\r\n          return output\r\n        case 1:\r\n          throw new Error(errors.PUBKEY_PARSE)\r\n        case 2:\r\n          throw new Error(errors.TWEAK_MUL)\r\n      }\r\n    },\r\n\r\n    signatureNormalize (sig) {\r\n      isUint8Array('signature', sig, 64)\r\n\r\n      switch (secp256k1.signatureNormalize(sig)) {\r\n        case 0:\r\n          return sig\r\n        case 1:\r\n          throw new Error(errors.SIG_PARSE)\r\n      }\r\n    },\r\n\r\n    signatureExport (sig, output) {\r\n      isUint8Array('signature', sig, 64)\r\n      output = getAssertedOutput(output, 72)\r\n\r\n      const obj = { output, outputlen: 72 }\r\n      switch (secp256k1.signatureExport(obj, sig)) {\r\n        case 0:\r\n          return output.slice(0, obj.outputlen)\r\n        case 1:\r\n          throw new Error(errors.SIG_PARSE)\r\n        case 2:\r\n          throw new Error(errors.IMPOSSIBLE_CASE)\r\n      }\r\n    },\r\n\r\n    signatureImport (sig, output) {\r\n      isUint8Array('signature', sig)\r\n      output = getAssertedOutput(output, 64)\r\n\r\n      switch (secp256k1.signatureImport(output, sig)) {\r\n        case 0:\r\n          return output\r\n        case 1:\r\n          throw new Error(errors.SIG_PARSE)\r\n        case 2:\r\n          throw new Error(errors.IMPOSSIBLE_CASE)\r\n      }\r\n    },\r\n\r\n    ecdsaSign (msg32, seckey, options = {}, output) {\r\n      isUint8Array('message', msg32, 32)\r\n      isUint8Array('private key', seckey, 32)\r\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\r\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\r\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')\r\n      output = getAssertedOutput(output, 64)\r\n\r\n      const obj = { signature: output, recid: null }\r\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\r\n        case 0:\r\n          return obj\r\n        case 1:\r\n          throw new Error(errors.SIGN)\r\n        case 2:\r\n          throw new Error(errors.IMPOSSIBLE_CASE)\r\n      }\r\n    },\r\n\r\n    ecdsaVerify (sig, msg32, pubkey) {\r\n      isUint8Array('signature', sig, 64)\r\n      isUint8Array('message', msg32, 32)\r\n      isUint8Array('public key', pubkey, [33, 65])\r\n\r\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\r\n        case 0:\r\n          return true\r\n        case 3:\r\n          return false\r\n        case 1:\r\n          throw new Error(errors.SIG_PARSE)\r\n        case 2:\r\n          throw new Error(errors.PUBKEY_PARSE)\r\n      }\r\n    },\r\n\r\n    ecdsaRecover (sig, recid, msg32, compressed = true, output) {\r\n      isUint8Array('signature', sig, 64)\r\n      assert(\r\n        toTypeString(recid) === 'Number' &&\r\n          recid >= 0 &&\r\n          recid <= 3,\r\n        'Expected recovery id to be a Number within interval [0, 3]'\r\n      )\r\n      isUint8Array('message', msg32, 32)\r\n      isCompressed(compressed)\r\n      output = getAssertedOutput(output, compressed ? 33 : 65)\r\n\r\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\r\n        case 0:\r\n          return output\r\n        case 1:\r\n          throw new Error(errors.SIG_PARSE)\r\n        case 2:\r\n          throw new Error(errors.RECOVER)\r\n        case 3:\r\n          throw new Error(errors.IMPOSSIBLE_CASE)\r\n      }\r\n    },\r\n\r\n    ecdh (pubkey, seckey, options = {}, output) {\r\n      isUint8Array('public key', pubkey, [33, 65])\r\n      isUint8Array('private key', seckey, 32)\r\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\r\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\r\n      if (options.hashfn !== undefined) {\r\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')\r\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)\r\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)\r\n        isUint8Array('output', output)\r\n      } else {\r\n        output = getAssertedOutput(output, 32)\r\n      }\r\n\r\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\r\n        case 0:\r\n          return output\r\n        case 1:\r\n          throw new Error(errors.PUBKEY_PARSE)\r\n        case 2:\r\n          throw new Error(errors.ECDH)\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}