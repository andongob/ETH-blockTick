{"ast":null,"code":"'use strict';\n\n/* jshint maxparams:5 */\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar Output = require('./output');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\n\n/**\r\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\r\n * for witness programs as defined by:\r\n * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki\r\n *\r\n * @name Signing.sighash\r\n * @param {Transaction} transaction the transaction to sign\r\n * @param {number} sighashType the type of the hash\r\n * @param {number} inputNumber the input index for the signature\r\n * @param {Buffer} scriptCode\r\n * @param {Buffer} satoshisBuffer\r\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {\n  /* jshint maxstatements: 50 */\n\n  var hashPrevouts;\n  var hashSequence;\n  var hashOutputs;\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    var buffers = [];\n    for (var n = 0; n < transaction.inputs.length; n++) {\n      var input = transaction.inputs[n];\n      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();\n      buffers.push(prevTxIdBuffer);\n      var outputIndexBuffer = Buffer.alloc(4);\n      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);\n      buffers.push(outputIndexBuffer);\n    }\n    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));\n  }\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) && (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    var sequenceBuffers = [];\n    for (var m = 0; m < transaction.inputs.length; m++) {\n      var sequenceBuffer = Buffer.alloc(4);\n      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);\n      sequenceBuffers.push(sequenceBuffer);\n    }\n    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));\n  }\n  var outputWriter = new BufferWriter();\n  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    for (var p = 0; p < transaction.outputs.length; p++) {\n      transaction.outputs[p].toBufferWriter(outputWriter);\n    }\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    transaction.outputs[inputNumber].toBufferWriter(outputWriter);\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  }\n\n  // Version\n  var writer = new BufferWriter();\n  writer.writeUInt32LE(transaction.version);\n\n  // Input prevouts/nSequence (none/all, depending on flags)\n  writer.write(hashPrevouts);\n  writer.write(hashSequence);\n\n  // The input being signed (replacing the scriptSig with scriptCode + amount)\n  // The prevout may already be contained in hashPrevout, and the nSequence\n  // may already be contain in hashSequence.\n  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();\n  writer.write(outpointId);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);\n  writer.write(scriptCode);\n  writer.write(satoshisBuffer);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);\n\n  // Outputs (none/one/all, depending on flags)\n  writer.write(hashOutputs);\n\n  // Locktime\n  writer.writeUInt32LE(transaction.nLockTime);\n\n  // Sighash type\n  writer.writeInt32LE(sighashType);\n  return Hash.sha256sha256(writer.toBuffer());\n};\n\n/**\r\n * Create a signature\r\n *\r\n * @name Signing.sign\r\n * @param {Transaction} transaction\r\n * @param {PrivateKey} privateKey\r\n * @param {number} sighash\r\n * @param {number} inputIndex\r\n * @param {Script} subscript\r\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\r\n * @return {Signature}\r\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa';\n  var sig;\n  if (signingMethod === 'ecdsa') {\n    let hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);\n    sig = ECDSA.sign(hashbuf, privateKey).set({\n      nhashtype: sighashType\n    });\n    return sig;\n  }\n  throw new Error(\"signingMethod not supported \", signingMethod);\n}\n\n/**\r\n * Verify a signature\r\n *\r\n * @name Signing.verify\r\n * @param {Transaction} transaction\r\n * @param {Signature} signature\r\n * @param {PublicKey} publicKey\r\n * @param {number} inputIndex\r\n * @param {Script} subscript\r\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\r\n * @return {boolean}\r\n */\nfunction verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer, signingMethod) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  signingMethod = signingMethod || 'ecdsa';\n  if (signingMethod === 'ecdsa') {\n    let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);\n    return ECDSA.verify(hashbuf, signature, publicKey);\n  }\n  throw new Error(\"signingMethod not supported \", signingMethod);\n}\n\n/**\r\n * @namespace Signing\r\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};","map":{"version":3,"names":["Signature","require","Script","Output","BufferReader","BufferWriter","BN","Hash","ECDSA","$","_","sighash","transaction","sighashType","inputNumber","scriptCode","satoshisBuffer","hashPrevouts","hashSequence","hashOutputs","SIGHASH_ANYONECANPAY","buffers","n","inputs","length","input","prevTxIdBuffer","prevTxId","readReverse","push","outputIndexBuffer","Buffer","alloc","writeUInt32LE","outputIndex","sha256sha256","concat","SIGHASH_SINGLE","SIGHASH_NONE","sequenceBuffers","m","sequenceBuffer","sequenceNumber","outputWriter","p","outputs","toBufferWriter","toBuffer","writer","version","write","outpointId","nLockTime","writeInt32LE","sign","privateKey","inputIndex","signingMethod","sig","hashbuf","set","nhashtype","Error","verify","signature","publicKey","checkArgument","isUndefined","module","exports"],"sources":["C:/Users/Ndongo/Desktop/noborrar/Ethereum-Blocktick/node_modules/bitcore-lib/lib/transaction/sighashwitness.js"],"sourcesContent":["'use strict';\r\n\r\n/* jshint maxparams:5 */\r\n\r\nvar Signature = require('../crypto/signature');\r\nvar Script = require('../script');\r\nvar Output = require('./output');\r\nvar BufferReader = require('../encoding/bufferreader');\r\nvar BufferWriter = require('../encoding/bufferwriter');\r\nvar BN = require('../crypto/bn');\r\nvar Hash = require('../crypto/hash');\r\nvar ECDSA = require('../crypto/ecdsa');\r\nvar $ = require('../util/preconditions');\r\nvar _ = require('lodash');\r\n\r\n/**\r\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\r\n * for witness programs as defined by:\r\n * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki\r\n *\r\n * @name Signing.sighash\r\n * @param {Transaction} transaction the transaction to sign\r\n * @param {number} sighashType the type of the hash\r\n * @param {number} inputNumber the input index for the signature\r\n * @param {Buffer} scriptCode\r\n * @param {Buffer} satoshisBuffer\r\n */\r\nvar sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {\r\n  /* jshint maxstatements: 50 */\r\n\r\n  var hashPrevouts;\r\n  var hashSequence;\r\n  var hashOutputs;\r\n\r\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\r\n    var buffers = [];\r\n    for (var n = 0; n < transaction.inputs.length; n++) {\r\n      var input = transaction.inputs[n];\r\n      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();\r\n      buffers.push(prevTxIdBuffer);\r\n      var outputIndexBuffer = Buffer.alloc(4);\r\n      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);\r\n      buffers.push(outputIndexBuffer);\r\n    }\r\n    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));\r\n  }\r\n\r\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&\r\n      (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\r\n\r\n    var sequenceBuffers = [];\r\n    for (var m = 0; m < transaction.inputs.length; m++) {\r\n      var sequenceBuffer = Buffer.alloc(4);\r\n      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);\r\n      sequenceBuffers.push(sequenceBuffer);\r\n    }\r\n    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));\r\n  }\r\n\r\n  var outputWriter = new BufferWriter();\r\n  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\r\n    for (var p = 0; p < transaction.outputs.length; p++) {\r\n      transaction.outputs[p].toBufferWriter(outputWriter);\r\n    }\r\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\r\n  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\r\n    transaction.outputs[inputNumber].toBufferWriter(outputWriter);\r\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\r\n  }\r\n\r\n  // Version\r\n  var writer = new BufferWriter();\r\n  writer.writeUInt32LE(transaction.version);\r\n\r\n  // Input prevouts/nSequence (none/all, depending on flags)\r\n  writer.write(hashPrevouts);\r\n  writer.write(hashSequence);\r\n\r\n  // The input being signed (replacing the scriptSig with scriptCode + amount)\r\n  // The prevout may already be contained in hashPrevout, and the nSequence\r\n  // may already be contain in hashSequence.\r\n  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();\r\n  writer.write(outpointId);\r\n  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);\r\n\r\n  writer.write(scriptCode);\r\n\r\n  writer.write(satoshisBuffer);\r\n\r\n  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);\r\n\r\n  // Outputs (none/one/all, depending on flags)\r\n  writer.write(hashOutputs);\r\n\r\n  // Locktime\r\n  writer.writeUInt32LE(transaction.nLockTime);\r\n\r\n  // Sighash type\r\n  writer.writeInt32LE(sighashType);\r\n\r\n  return Hash.sha256sha256(writer.toBuffer());\r\n\r\n};\r\n\r\n/**\r\n * Create a signature\r\n *\r\n * @name Signing.sign\r\n * @param {Transaction} transaction\r\n * @param {PrivateKey} privateKey\r\n * @param {number} sighash\r\n * @param {number} inputIndex\r\n * @param {Script} subscript\r\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\r\n * @return {Signature}\r\n */\r\nfunction sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer, signingMethod) {\r\n  signingMethod = signingMethod || 'ecdsa';\r\n  var sig;\r\n\r\n  if (signingMethod === 'ecdsa') {\r\n    let hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);\r\n    sig = ECDSA.sign(hashbuf, privateKey).set({\r\n      nhashtype: sighashType\r\n    });\r\n    return sig;\r\n  }\r\n  throw new Error(\"signingMethod not supported \", signingMethod);\r\n}\r\n\r\n/**\r\n * Verify a signature\r\n *\r\n * @name Signing.verify\r\n * @param {Transaction} transaction\r\n * @param {Signature} signature\r\n * @param {PublicKey} publicKey\r\n * @param {number} inputIndex\r\n * @param {Script} subscript\r\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\r\n * @return {boolean}\r\n */\r\nfunction verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer, signingMethod) {\r\n  $.checkArgument(!_.isUndefined(transaction));\r\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\r\n  signingMethod = signingMethod || 'ecdsa';\r\n\r\n  if (signingMethod === 'ecdsa') {\r\n    let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);\r\n    return ECDSA.verify(hashbuf, signature, publicKey);\r\n  }\r\n  throw new Error(\"signingMethod not supported \", signingMethod);\r\n}\r\n\r\n/**\r\n * @namespace Signing\r\n */\r\nmodule.exports = {\r\n  sighash: sighash,\r\n  sign: sign,\r\n  verify: verify\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}