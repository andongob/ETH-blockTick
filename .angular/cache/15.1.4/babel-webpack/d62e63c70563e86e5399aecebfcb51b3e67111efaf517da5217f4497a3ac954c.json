{"ast":null,"code":"'use strict';\n\n/* jshint maxparams:5 */\nvar _ = require('lodash');\nvar inherits = require('inherits');\nvar Input = require('./input');\nvar Output = require('../output');\nvar $ = require('../../util/preconditions');\nvar Address = require('../../address');\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar Sighash = require('../sighash');\nvar SighashWitness = require('../sighashwitness');\nvar BufferWriter = require('../../encoding/bufferwriter');\nvar BufferUtil = require('../../util/buffer');\nvar TransactionSignature = require('../signature');\n\n/**\n * @constructor\n */\nfunction MultiSigScriptHashInput(input, pubkeys, threshold, signatures, opts) {\n  /* jshint maxstatements:20 */\n  opts = opts || {};\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys;\n  } else {\n    this.publicKeys = _.sortBy(pubkeys, function (publicKey) {\n      return publicKey.toString('hex');\n    });\n  }\n  this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold, opts);\n  var nested = Script.buildWitnessMultisigOutFromScript(this.redeemScript);\n  if (nested.equals(this.output.script)) {\n    this.nestedWitness = false;\n    this.type = Address.PayToWitnessScriptHash;\n  } else if (Script.buildScriptHashOut(nested).equals(this.output.script)) {\n    this.nestedWitness = true;\n    this.type = Address.PayToScriptHash;\n  } else if (Script.buildScriptHashOut(this.redeemScript).equals(this.output.script)) {\n    this.nestedWitness = false;\n    this.type = Address.PayToScriptHash;\n  } else {\n    throw new Error('Provided public keys don\\'t hash to the provided output');\n  }\n  if (this.nestedWitness) {\n    var scriptSig = new Script();\n    scriptSig.add(nested.toBuffer());\n    this.setScript(scriptSig);\n  }\n  this.publicKeyIndex = {};\n  _.each(this.publicKeys, function (publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n  this.threshold = threshold;\n  // Empty array of signatures\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\ninherits(MultiSigScriptHashInput, Input);\nMultiSigScriptHashInput.prototype.toObject = function () {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function (publicKey) {\n    return publicKey.toString();\n  });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\nMultiSigScriptHashInput.prototype._deserializeSignatures = function (signatures) {\n  return _.map(signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return new TransactionSignature(signature);\n  });\n};\nMultiSigScriptHashInput.prototype._serializeSignatures = function () {\n  return _.map(this.signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return signature.toObject();\n  });\n};\nMultiSigScriptHashInput.prototype.getScriptCode = function () {\n  var writer = new BufferWriter();\n  if (!this.redeemScript.hasCodeseparators()) {\n    var redeemScriptBuffer = this.redeemScript.toBuffer();\n    writer.writeVarintNum(redeemScriptBuffer.length);\n    writer.write(redeemScriptBuffer);\n  } else {\n    throw new Error('@TODO');\n  }\n  return writer.toBuffer();\n};\nMultiSigScriptHashInput.prototype.getSighash = function (transaction, privateKey, index, sigtype) {\n  var self = this;\n  var hash;\n  if (self.nestedWitness || self.type === Address.PayToWitnessScriptHash) {\n    var scriptCode = self.getScriptCode();\n    var satoshisBuffer = self.getSatoshisBuffer();\n    hash = SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);\n  } else {\n    hash = Sighash.sighash(transaction, sigtype, index, self.redeemScript);\n  }\n  return hash;\n};\nMultiSigScriptHashInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa';\n  var self = this;\n  var results = [];\n  _.each(this.publicKeys, function (publicKey) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      var signature;\n      if (self.nestedWitness || self.type === Address.PayToWitnessScriptHash) {\n        var scriptCode = self.getScriptCode();\n        var satoshisBuffer = self.getSatoshisBuffer();\n        signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer, signingMethod);\n      } else {\n        signature = Sighash.sign(transaction, privateKey, sigtype, index, self.redeemScript, signingMethod);\n      }\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: self.prevTxId,\n        outputIndex: self.outputIndex,\n        inputIndex: index,\n        signature: signature,\n        sigtype: sigtype\n      }));\n    }\n  });\n  return results;\n};\nMultiSigScriptHashInput.prototype.addSignature = function (transaction, signature, signingMethod) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]), 'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), \"Invalid Signature!\");\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n  this._updateScript();\n  return this;\n};\nMultiSigScriptHashInput.prototype._updateScript = function () {\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n    var stack = [Buffer.alloc(0)];\n    var signatures = this._createSignatures();\n    for (var i = 0; i < signatures.length; i++) {\n      stack.push(signatures[i]);\n    }\n    stack.push(this.redeemScript.toBuffer());\n    this.setWitnesses(stack);\n  } else {\n    var scriptSig = Script.buildP2SHMultisigIn(this.publicKeys, this.threshold, this._createSignatures(), {\n      cachedMultisig: this.redeemScript\n    });\n    this.setScript(scriptSig);\n  }\n  return this;\n};\nMultiSigScriptHashInput.prototype._createSignatures = function () {\n  return _.map(_.filter(this.signatures, function (signature) {\n    return !_.isUndefined(signature);\n  }), function (signature) {\n    return BufferUtil.concat([signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]);\n  });\n};\nMultiSigScriptHashInput.prototype.clearSignatures = function () {\n  this.signatures = new Array(this.publicKeys.length);\n  this._updateScript();\n};\nMultiSigScriptHashInput.prototype.isFullySigned = function () {\n  return this.countSignatures() === this.threshold;\n};\nMultiSigScriptHashInput.prototype.countMissingSignatures = function () {\n  return this.threshold - this.countSignatures();\n};\nMultiSigScriptHashInput.prototype.countSignatures = function () {\n  return _.reduce(this.signatures, function (sum, signature) {\n    return sum + !!signature;\n  }, 0);\n};\nMultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function () {\n  var self = this;\n  return _.filter(this.publicKeys, function (publicKey) {\n    return !self.signatures[self.publicKeyIndex[publicKey.toString()]];\n  });\n};\nMultiSigScriptHashInput.prototype.isValidSignature = function (transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa';\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n    signature.signature.nhashtype = signature.sigtype;\n    var scriptCode = this.getScriptCode();\n    var satoshisBuffer = this.getSatoshisBuffer();\n    return SighashWitness.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, scriptCode, satoshisBuffer, signingMethod);\n  } else {\n    // FIXME: Refactor signature so this is not necessary\n    signature.signature.nhashtype = signature.sigtype;\n    return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.redeemScript, signingMethod);\n  }\n};\nMultiSigScriptHashInput.OPCODES_SIZE = 7; // serialized size (<=3) + 0 .. N .. M OP_CHECKMULTISIG\nMultiSigScriptHashInput.SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)\nMultiSigScriptHashInput.PUBKEY_SIZE = 34; // size (1) + DER (<=33)\nMultiSigScriptHashInput.REDEEM_SCRIPT_SIZE = 34; // OP_0 (1) + scriptHash (1 + 32)\n\nMultiSigScriptHashInput.prototype._estimateSize = function () {\n  var WITNESS_DISCOUNT = 4;\n  var witnessSize = MultiSigScriptHashInput.OPCODES_SIZE + this.threshold * MultiSigScriptHashInput.SIGNATURE_SIZE + this.publicKeys.length * MultiSigScriptHashInput.PUBKEY_SIZE;\n  if (this.type === Address.PayToWitnessScriptHash) {\n    return witnessSize / WITNESS_DISCOUNT;\n  } else if (this.nestedWitness) {\n    return witnessSize / WITNESS_DISCOUNT + MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE;\n  } else {\n    return witnessSize;\n  }\n};\nmodule.exports = MultiSigScriptHashInput;","map":{"version":3,"names":["_","require","inherits","Input","Output","$","Address","Script","Signature","Sighash","SighashWitness","BufferWriter","BufferUtil","TransactionSignature","MultiSigScriptHashInput","input","pubkeys","threshold","signatures","opts","apply","arguments","self","publicKeys","noSorting","sortBy","publicKey","toString","redeemScript","buildMultisigOut","nested","buildWitnessMultisigOutFromScript","equals","output","script","nestedWitness","type","PayToWitnessScriptHash","buildScriptHashOut","PayToScriptHash","Error","scriptSig","add","toBuffer","setScript","publicKeyIndex","each","index","_deserializeSignatures","Array","length","prototype","toObject","obj","map","_serializeSignatures","signature","undefined","getScriptCode","writer","hasCodeseparators","redeemScriptBuffer","writeVarintNum","write","getSighash","transaction","privateKey","sigtype","hash","scriptCode","satoshisBuffer","getSatoshisBuffer","sighash","getSignatures","hashData","signingMethod","checkState","SIGHASH_ALL","results","sign","push","prevTxId","outputIndex","inputIndex","addSignature","isFullySigned","checkArgument","isUndefined","isValidSignature","_updateScript","stack","Buffer","alloc","_createSignatures","i","setWitnesses","buildP2SHMultisigIn","cachedMultisig","filter","concat","toDER","integerAsSingleByteBuffer","clearSignatures","countSignatures","countMissingSignatures","reduce","sum","publicKeysWithoutSignature","nhashtype","verify","OPCODES_SIZE","SIGNATURE_SIZE","PUBKEY_SIZE","REDEEM_SCRIPT_SIZE","_estimateSize","WITNESS_DISCOUNT","witnessSize","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/bitcore-lib/lib/transaction/input/multisigscripthash.js"],"sourcesContent":["'use strict';\n\n/* jshint maxparams:5 */\n\nvar _ = require('lodash');\nvar inherits = require('inherits');\nvar Input = require('./input');\nvar Output = require('../output');\nvar $ = require('../../util/preconditions');\n\nvar Address = require('../../address');\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar Sighash = require('../sighash');\nvar SighashWitness = require('../sighashwitness');\nvar BufferWriter = require('../../encoding/bufferwriter');\nvar BufferUtil = require('../../util/buffer');\nvar TransactionSignature = require('../signature');\n\n/**\n * @constructor\n */\nfunction MultiSigScriptHashInput(input, pubkeys, threshold, signatures, opts) {\n  /* jshint maxstatements:20 */\n  opts = opts || {};\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys;\n  } else  {\n    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });\n  }\n  this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold, opts);\n  var nested = Script.buildWitnessMultisigOutFromScript(this.redeemScript);\n  if (nested.equals(this.output.script)) {\n    this.nestedWitness = false;\n    this.type = Address.PayToWitnessScriptHash;\n  } else if (Script.buildScriptHashOut(nested).equals(this.output.script)) {\n    this.nestedWitness = true;\n    this.type = Address.PayToScriptHash;\n  } else if (Script.buildScriptHashOut(this.redeemScript).equals(this.output.script)) {\n    this.nestedWitness = false;\n    this.type = Address.PayToScriptHash;\n  } else {\n    throw new Error('Provided public keys don\\'t hash to the provided output');\n  }\n\n  if (this.nestedWitness) {\n    var scriptSig = new Script();\n    scriptSig.add(nested.toBuffer());\n    this.setScript(scriptSig);\n  }\n\n  this.publicKeyIndex = {};\n  _.each(this.publicKeys, function(publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n  this.threshold = threshold;\n  // Empty array of signatures\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\ninherits(MultiSigScriptHashInput, Input);\n\nMultiSigScriptHashInput.prototype.toObject = function() {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigScriptHashInput.prototype._deserializeSignatures = function(signatures) {\n  return _.map(signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigScriptHashInput.prototype._serializeSignatures = function() {\n  return _.map(this.signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return signature.toObject();\n  });\n};\n\nMultiSigScriptHashInput.prototype.getScriptCode = function() {\n  var writer = new BufferWriter();\n  if (!this.redeemScript.hasCodeseparators()) {\n    var redeemScriptBuffer = this.redeemScript.toBuffer();\n    writer.writeVarintNum(redeemScriptBuffer.length);\n    writer.write(redeemScriptBuffer);\n  } else {\n    throw new Error('@TODO');\n  }\n  return writer.toBuffer();\n};\n\nMultiSigScriptHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {\n  var self = this;\n  var hash;\n  if (self.nestedWitness || self.type === Address.PayToWitnessScriptHash) {\n    var scriptCode = self.getScriptCode();\n    var satoshisBuffer = self.getSatoshisBuffer();\n    hash = SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);\n  } else  {\n    hash = Sighash.sighash(transaction, sigtype, index, self.redeemScript);\n  }\n  return hash;\n};\n\nMultiSigScriptHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa';\n\n  var self = this;\n  var results = [];\n  _.each(this.publicKeys, function(publicKey) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      var signature;\n      if (self.nestedWitness || self.type === Address.PayToWitnessScriptHash) {\n        var scriptCode = self.getScriptCode();\n        var satoshisBuffer = self.getSatoshisBuffer();\n        signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer, signingMethod);\n      } else  {\n        signature = Sighash.sign(transaction, privateKey, sigtype, index, self.redeemScript, signingMethod);\n      }\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: self.prevTxId,\n        outputIndex: self.outputIndex,\n        inputIndex: index,\n        signature: signature,\n        sigtype: sigtype\n      }));\n    }\n  });\n  return results;\n};\n\nMultiSigScriptHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]),\n                  'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), \"Invalid Signature!\");\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n  this._updateScript();\n  return this;\n};\n\nMultiSigScriptHashInput.prototype._updateScript = function() {\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n    var stack = [\n      Buffer.alloc(0),\n    ];\n    var signatures = this._createSignatures();\n    for (var i = 0; i < signatures.length; i++) {\n      stack.push(signatures[i]);\n    }\n    stack.push(this.redeemScript.toBuffer());\n    this.setWitnesses(stack);\n  } else {\n    var scriptSig = Script.buildP2SHMultisigIn(\n      this.publicKeys,\n      this.threshold,\n      this._createSignatures(),\n      { cachedMultisig: this.redeemScript }\n    );\n    this.setScript(scriptSig);\n  }\n  return this;\n};\n\nMultiSigScriptHashInput.prototype._createSignatures = function() {\n  return _.map(\n    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),\n    function(signature) {\n      return BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]);\n    }\n  );\n};\n\nMultiSigScriptHashInput.prototype.clearSignatures = function() {\n  this.signatures = new Array(this.publicKeys.length);\n  this._updateScript();\n};\n\nMultiSigScriptHashInput.prototype.isFullySigned = function() {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigScriptHashInput.prototype.countMissingSignatures = function() {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigScriptHashInput.prototype.countSignatures = function() {\n  return _.reduce(this.signatures, function(sum, signature) {\n    return sum + (!!signature);\n  }, 0);\n};\n\nMultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function() {\n  var self = this;\n  return _.filter(this.publicKeys, function(publicKey) {\n    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);\n  });\n};\n\nMultiSigScriptHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa';\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n    signature.signature.nhashtype = signature.sigtype;\n    var scriptCode = this.getScriptCode();\n    var satoshisBuffer = this.getSatoshisBuffer();\n    return SighashWitness.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      scriptCode,\n      satoshisBuffer,\n      signingMethod\n    );\n  } else {\n    // FIXME: Refactor signature so this is not necessary\n    signature.signature.nhashtype = signature.sigtype;\n    return Sighash.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      this.redeemScript, \n      signingMethod\n    );\n  }\n};\n\nMultiSigScriptHashInput.OPCODES_SIZE = 7; // serialized size (<=3) + 0 .. N .. M OP_CHECKMULTISIG\nMultiSigScriptHashInput.SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)\nMultiSigScriptHashInput.PUBKEY_SIZE = 34; // size (1) + DER (<=33)\nMultiSigScriptHashInput.REDEEM_SCRIPT_SIZE = 34; // OP_0 (1) + scriptHash (1 + 32)\n\nMultiSigScriptHashInput.prototype._estimateSize = function() {\n  var WITNESS_DISCOUNT = 4;\n  var witnessSize = MultiSigScriptHashInput.OPCODES_SIZE +\n    this.threshold * MultiSigScriptHashInput.SIGNATURE_SIZE +\n    this.publicKeys.length * MultiSigScriptHashInput.PUBKEY_SIZE;\n  if (this.type === Address.PayToWitnessScriptHash) {\n    return witnessSize / WITNESS_DISCOUNT;\n  } else if (this.nestedWitness) {\n    return witnessSize / WITNESS_DISCOUNT + MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE;\n  } else {\n    return witnessSize;\n  }\n};\n\nmodule.exports = MultiSigScriptHashInput;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}