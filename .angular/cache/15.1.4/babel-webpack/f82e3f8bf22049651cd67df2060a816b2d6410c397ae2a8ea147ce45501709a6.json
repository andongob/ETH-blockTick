{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\nvar PrivateKey = require('./privatekey');\nvar PublicKey = require('./publickey');\nvar Address = require('./address');\nvar BufferWriter = require('./encoding/bufferwriter');\nvar ECDSA = require('./crypto/ecdsa');\nvar Signature = require('./crypto/signature');\nvar sha256sha256 = require('./crypto/hash').sha256sha256;\nvar JSUtil = require('./util/js');\nvar $ = require('./util/preconditions');\nfunction Message(message) {\n  if (!(this instanceof Message)) {\n    return new Message(message);\n  }\n  $.checkArgument(_.isString(message), 'First argument should be a string');\n  this.message = message;\n  return this;\n}\nMessage.MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\\n');\nMessage.prototype.magicHash = function magicHash() {\n  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\n  var messageBuffer = Buffer.from(this.message);\n  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\n  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\n  var hash = sha256sha256(buf);\n  return hash;\n};\nMessage.prototype._sign = function _sign(privateKey) {\n  $.checkArgument(privateKey instanceof PrivateKey, 'First argument should be an instance of PrivateKey');\n  var hash = this.magicHash();\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = hash;\n  ecdsa.privkey = privateKey;\n  ecdsa.pubkey = privateKey.toPublicKey();\n  ecdsa.signRandomK();\n  ecdsa.calci();\n  return ecdsa.sig;\n};\n\n/**\r\n * Will sign a message with a given bitcoin private key.\r\n *\r\n * @param {PrivateKey} privateKey - An instance of PrivateKey\r\n * @returns {String} A base64 encoded compact signature\r\n */\nMessage.prototype.sign = function sign(privateKey) {\n  var signature = this._sign(privateKey);\n  return signature.toCompact().toString('base64');\n};\nMessage.prototype._verify = function _verify(publicKey, signature) {\n  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');\n  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');\n  var hash = this.magicHash();\n  var verified = ECDSA.verify(hash, signature, publicKey);\n  if (!verified) {\n    this.error = 'The signature was invalid';\n  }\n  return verified;\n};\n\n/**\r\n * Will return a boolean of the signature is valid for a given bitcoin address.\r\n * If it isn't the specific reason is accessible via the \"error\" member.\r\n *\r\n * @param {Address|String} bitcoinAddress - A bitcoin address\r\n * @param {String} signatureString - A base64 encoded compact signature\r\n * @returns {Boolean}\r\n */\nMessage.prototype.verify = function verify(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\n\n  // recover the public key\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = this.magicHash();\n  ecdsa.sig = signature;\n  var publicKey = ecdsa.toPublicKey();\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n    return false;\n  }\n  return this._verify(publicKey, signature);\n};\n\n/**\r\n * Will return a public key string if the provided signature and the message digest is correct\r\n * If it isn't the specific reason is accessible via the \"error\" member.\r\n *\r\n * @param {Address|String} bitcoinAddress - A bitcoin address\r\n * @param {String} signatureString - A base64 encoded compact signature\r\n * @returns {String}\r\n */\nMessage.prototype.recoverPublicKey = function recoverPublicKey(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\n\n  // recover the public key\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = this.magicHash();\n  ecdsa.sig = signature;\n  var publicKey = ecdsa.toPublicKey();\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n  }\n  return publicKey.toString();\n};\n\n/**\r\n * Instantiate a message from a message string\r\n *\r\n * @param {String} str - A string of the message\r\n * @returns {Message} A new instance of a Message\r\n */\nMessage.fromString = function (str) {\n  return new Message(str);\n};\n\n/**\r\n * Instantiate a message from JSON\r\n *\r\n * @param {String} json - An JSON string or Object with keys: message\r\n * @returns {Message} A new instance of a Message\r\n */\nMessage.fromJSON = function fromJSON(json) {\n  if (JSUtil.isValidJSON(json)) {\n    json = JSON.parse(json);\n  }\n  return new Message(json.message);\n};\n\n/**\r\n * @returns {Object} A plain object with the message information\r\n */\nMessage.prototype.toObject = function toObject() {\n  return {\n    message: this.message\n  };\n};\n\n/**\r\n * @returns {String} A JSON representation of the message information\r\n */\nMessage.prototype.toJSON = function toJSON() {\n  return JSON.stringify(this.toObject());\n};\n\n/**\r\n * Will return a the string representation of the message\r\n *\r\n * @returns {String} Message\r\n */\nMessage.prototype.toString = function () {\n  return this.message;\n};\n\n/**\r\n * Will return a string formatted for the console\r\n *\r\n * @returns {String} Message\r\n */\nMessage.prototype.inspect = function () {\n  return '<Message: ' + this.toString() + '>';\n};\nmodule.exports = Message;\nvar Script = require('./script');","map":{"version":3,"names":["_","require","PrivateKey","PublicKey","Address","BufferWriter","ECDSA","Signature","sha256sha256","JSUtil","$","Message","message","checkArgument","isString","MAGIC_BYTES","Buffer","from","prototype","magicHash","prefix1","varintBufNum","length","messageBuffer","prefix2","buf","concat","hash","_sign","privateKey","ecdsa","hashbuf","privkey","pubkey","toPublicKey","signRandomK","calci","sig","sign","signature","toCompact","toString","_verify","publicKey","verified","verify","error","bitcoinAddress","signatureString","fromString","fromCompact","signatureAddress","fromPublicKey","network","recoverPublicKey","str","fromJSON","json","isValidJSON","JSON","parse","toObject","toJSON","stringify","inspect","module","exports","Script"],"sources":["C:/Users/Ndongo/Desktop/noborrar/Ethereum-Blocktick/node_modules/bitcore-lib/lib/message.js"],"sourcesContent":["'use strict';\r\n\r\nvar _ = require('lodash');\r\nvar PrivateKey = require('./privatekey');\r\nvar PublicKey = require('./publickey');\r\nvar Address = require('./address');\r\nvar BufferWriter = require('./encoding/bufferwriter');\r\nvar ECDSA = require('./crypto/ecdsa');\r\nvar Signature = require('./crypto/signature');\r\nvar sha256sha256 = require('./crypto/hash').sha256sha256;\r\nvar JSUtil = require('./util/js');\r\nvar $ = require('./util/preconditions');\r\n\r\nfunction Message(message) {\r\n  if (!(this instanceof Message)) {\r\n    return new Message(message);\r\n  }\r\n  $.checkArgument(_.isString(message), 'First argument should be a string');\r\n  this.message = message;\r\n\r\n  return this;\r\n}\r\n\r\nMessage.MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\\n');\r\n\r\nMessage.prototype.magicHash = function magicHash() {\r\n  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\r\n  var messageBuffer = Buffer.from(this.message);\r\n  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\r\n  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\r\n  var hash = sha256sha256(buf);\r\n  return hash;\r\n};\r\n\r\nMessage.prototype._sign = function _sign(privateKey) {\r\n  $.checkArgument(privateKey instanceof PrivateKey, 'First argument should be an instance of PrivateKey');\r\n  var hash = this.magicHash();\r\n  var ecdsa = new ECDSA();\r\n  ecdsa.hashbuf = hash;\r\n  ecdsa.privkey = privateKey;\r\n  ecdsa.pubkey = privateKey.toPublicKey();\r\n  ecdsa.signRandomK();\r\n  ecdsa.calci();\r\n  return ecdsa.sig;\r\n};\r\n\r\n/**\r\n * Will sign a message with a given bitcoin private key.\r\n *\r\n * @param {PrivateKey} privateKey - An instance of PrivateKey\r\n * @returns {String} A base64 encoded compact signature\r\n */\r\nMessage.prototype.sign = function sign(privateKey) {\r\n  var signature = this._sign(privateKey);\r\n  return signature.toCompact().toString('base64');\r\n};\r\n\r\nMessage.prototype._verify = function _verify(publicKey, signature) {\r\n  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');\r\n  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');\r\n  var hash = this.magicHash();\r\n  var verified = ECDSA.verify(hash, signature, publicKey);\r\n  if (!verified) {\r\n    this.error = 'The signature was invalid';\r\n  }\r\n  return verified;\r\n};\r\n\r\n/**\r\n * Will return a boolean of the signature is valid for a given bitcoin address.\r\n * If it isn't the specific reason is accessible via the \"error\" member.\r\n *\r\n * @param {Address|String} bitcoinAddress - A bitcoin address\r\n * @param {String} signatureString - A base64 encoded compact signature\r\n * @returns {Boolean}\r\n */\r\nMessage.prototype.verify = function verify(bitcoinAddress, signatureString) {\r\n  $.checkArgument(bitcoinAddress);\r\n  $.checkArgument(signatureString && _.isString(signatureString));\r\n\r\n  if (_.isString(bitcoinAddress)) {\r\n    bitcoinAddress = Address.fromString(bitcoinAddress);\r\n  }\r\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\r\n\r\n  // recover the public key\r\n  var ecdsa = new ECDSA();\r\n  ecdsa.hashbuf = this.magicHash();\r\n  ecdsa.sig = signature;\r\n  var publicKey = ecdsa.toPublicKey();\r\n\r\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\r\n\r\n  // check that the recovered address and specified address match\r\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\r\n    this.error = 'The signature did not match the message digest';\r\n    return false;\r\n  }\r\n\r\n  return this._verify(publicKey, signature);\r\n};\r\n\r\n/**\r\n * Will return a public key string if the provided signature and the message digest is correct\r\n * If it isn't the specific reason is accessible via the \"error\" member.\r\n *\r\n * @param {Address|String} bitcoinAddress - A bitcoin address\r\n * @param {String} signatureString - A base64 encoded compact signature\r\n * @returns {String}\r\n */\r\nMessage.prototype.recoverPublicKey = function recoverPublicKey(bitcoinAddress, signatureString) {\r\n  $.checkArgument(bitcoinAddress);\r\n  $.checkArgument(signatureString && _.isString(signatureString));\r\n\r\n  if (_.isString(bitcoinAddress)) {\r\n    bitcoinAddress = Address.fromString(bitcoinAddress);\r\n  }\r\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\r\n\r\n  // recover the public key\r\n  var ecdsa = new ECDSA();\r\n  ecdsa.hashbuf = this.magicHash();\r\n  ecdsa.sig = signature;\r\n  var publicKey = ecdsa.toPublicKey();\r\n\r\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\r\n\r\n  // check that the recovered address and specified address match\r\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\r\n    this.error = 'The signature did not match the message digest';\r\n  }\r\n\r\n  return publicKey.toString();\r\n};\r\n\r\n/**\r\n * Instantiate a message from a message string\r\n *\r\n * @param {String} str - A string of the message\r\n * @returns {Message} A new instance of a Message\r\n */\r\nMessage.fromString = function(str) {\r\n  return new Message(str);\r\n};\r\n\r\n/**\r\n * Instantiate a message from JSON\r\n *\r\n * @param {String} json - An JSON string or Object with keys: message\r\n * @returns {Message} A new instance of a Message\r\n */\r\nMessage.fromJSON = function fromJSON(json) {\r\n  if (JSUtil.isValidJSON(json)) {\r\n    json = JSON.parse(json);\r\n  }\r\n  return new Message(json.message);\r\n};\r\n\r\n/**\r\n * @returns {Object} A plain object with the message information\r\n */\r\nMessage.prototype.toObject = function toObject() {\r\n  return {\r\n    message: this.message\r\n  };\r\n};\r\n\r\n/**\r\n * @returns {String} A JSON representation of the message information\r\n */\r\nMessage.prototype.toJSON = function toJSON() {\r\n  return JSON.stringify(this.toObject());\r\n};\r\n\r\n/**\r\n * Will return a the string representation of the message\r\n *\r\n * @returns {String} Message\r\n */\r\nMessage.prototype.toString = function() {\r\n  return this.message;\r\n};\r\n\r\n/**\r\n * Will return a string formatted for the console\r\n *\r\n * @returns {String} Message\r\n */\r\nMessage.prototype.inspect = function() {\r\n  return '<Message: ' + this.toString() + '>';\r\n};\r\n\r\nmodule.exports = Message;\r\n\r\nvar Script = require('./script');\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}