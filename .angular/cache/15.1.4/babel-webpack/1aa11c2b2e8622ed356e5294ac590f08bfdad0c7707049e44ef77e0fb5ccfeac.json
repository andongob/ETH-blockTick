{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;\nvar ethjsUtil = require('ethjs-util');\nvar BN = require(\"bn.js\");\n/**\r\n * Returns a buffer filled with 0s.\r\n * @param bytes the number of bytes the buffer should be\r\n */\nexports.zeros = function (bytes) {\n  return Buffer.allocUnsafe(bytes).fill(0);\n};\n/**\r\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\r\n * Or it truncates the beginning if it exceeds.\r\n * @param msg the value to pad (Buffer|Array)\r\n * @param length the number of bytes the output should be\r\n * @param right whether to start padding form the left or right\r\n * @return (Buffer|Array)\r\n */\nexports.setLengthLeft = function (msg, length, right) {\n  if (right === void 0) {\n    right = false;\n  }\n  var buf = exports.zeros(length);\n  msg = exports.toBuffer(msg);\n  if (right) {\n    if (msg.length < length) {\n      msg.copy(buf);\n      return buf;\n    }\n    return msg.slice(0, length);\n  } else {\n    if (msg.length < length) {\n      msg.copy(buf, length - msg.length);\n      return buf;\n    }\n    return msg.slice(-length);\n  }\n};\nexports.setLength = exports.setLengthLeft;\n/**\r\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\r\n * Or it truncates the beginning if it exceeds.\r\n * @param msg the value to pad (Buffer|Array)\r\n * @param length the number of bytes the output should be\r\n * @return (Buffer|Array)\r\n */\nexports.setLengthRight = function (msg, length) {\n  return exports.setLength(msg, length, true);\n};\n/**\r\n * Trims leading zeros from a `Buffer` or an `Array`.\r\n * @param a (Buffer|Array|String)\r\n * @return (Buffer|Array|String)\r\n */\nexports.unpad = function (a) {\n  a = ethjsUtil.stripHexPrefix(a);\n  var first = a[0];\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1);\n    first = a[0];\n  }\n  return a;\n};\nexports.stripZeros = exports.unpad;\n/**\r\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.\r\n * @param v the value\r\n */\nexports.toBuffer = function (v) {\n  if (!Buffer.isBuffer(v)) {\n    if (Array.isArray(v)) {\n      v = Buffer.from(v);\n    } else if (typeof v === 'string') {\n      if (ethjsUtil.isHexString(v)) {\n        v = Buffer.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(v)), 'hex');\n      } else {\n        throw new Error(\"Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: \" + v);\n      }\n    } else if (typeof v === 'number') {\n      v = ethjsUtil.intToBuffer(v);\n    } else if (v === null || v === undefined) {\n      v = Buffer.allocUnsafe(0);\n    } else if (BN.isBN(v)) {\n      v = v.toArrayLike(Buffer);\n    } else if (v.toArray) {\n      // converts a BN to a Buffer\n      v = Buffer.from(v.toArray());\n    } else {\n      throw new Error('invalid type');\n    }\n  }\n  return v;\n};\n/**\r\n * Converts a `Buffer` to a `Number`.\r\n * @param buf `Buffer` object to convert\r\n * @throws If the input number exceeds 53 bits.\r\n */\nexports.bufferToInt = function (buf) {\n  return new BN(exports.toBuffer(buf)).toNumber();\n};\n/**\r\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\r\n * @param buf `Buffer` object to convert\r\n */\nexports.bufferToHex = function (buf) {\n  buf = exports.toBuffer(buf);\n  return '0x' + buf.toString('hex');\n};\n/**\r\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\r\n * @param num Signed integer value\r\n */\nexports.fromSigned = function (num) {\n  return new BN(num).fromTwos(256);\n};\n/**\r\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\r\n * @param num\r\n */\nexports.toUnsigned = function (num) {\n  return Buffer.from(num.toTwos(256).toArray());\n};\n/**\r\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\r\n */\nexports.addHexPrefix = function (str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  return ethjsUtil.isHexPrefixed(str) ? str : '0x' + str;\n};\n/**\r\n * Converts a `Buffer` or `Array` to JSON.\r\n * @param ba (Buffer|Array)\r\n * @return (Array|String|null)\r\n */\nexports.baToJSON = function (ba) {\n  if (Buffer.isBuffer(ba)) {\n    return \"0x\" + ba.toString('hex');\n  } else if (ba instanceof Array) {\n    var array = [];\n    for (var i = 0; i < ba.length; i++) {\n      array.push(exports.baToJSON(ba[i]));\n    }\n    return array;\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","baToJSON","addHexPrefix","toUnsigned","fromSigned","bufferToHex","bufferToInt","toBuffer","stripZeros","unpad","setLengthRight","setLength","setLengthLeft","zeros","ethjsUtil","require","BN","bytes","Buffer","allocUnsafe","fill","msg","length","right","buf","copy","slice","a","stripHexPrefix","first","toString","v","isBuffer","Array","isArray","from","isHexString","padToEven","Error","intToBuffer","undefined","isBN","toArrayLike","toArray","toNumber","num","fromTwos","toTwos","str","isHexPrefixed","ba","array","i","push"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/bytes.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;\r\nvar ethjsUtil = require('ethjs-util');\r\nvar BN = require(\"bn.js\");\r\n/**\r\n * Returns a buffer filled with 0s.\r\n * @param bytes the number of bytes the buffer should be\r\n */\r\nexports.zeros = function (bytes) {\r\n    return Buffer.allocUnsafe(bytes).fill(0);\r\n};\r\n/**\r\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\r\n * Or it truncates the beginning if it exceeds.\r\n * @param msg the value to pad (Buffer|Array)\r\n * @param length the number of bytes the output should be\r\n * @param right whether to start padding form the left or right\r\n * @return (Buffer|Array)\r\n */\r\nexports.setLengthLeft = function (msg, length, right) {\r\n    if (right === void 0) { right = false; }\r\n    var buf = exports.zeros(length);\r\n    msg = exports.toBuffer(msg);\r\n    if (right) {\r\n        if (msg.length < length) {\r\n            msg.copy(buf);\r\n            return buf;\r\n        }\r\n        return msg.slice(0, length);\r\n    }\r\n    else {\r\n        if (msg.length < length) {\r\n            msg.copy(buf, length - msg.length);\r\n            return buf;\r\n        }\r\n        return msg.slice(-length);\r\n    }\r\n};\r\nexports.setLength = exports.setLengthLeft;\r\n/**\r\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\r\n * Or it truncates the beginning if it exceeds.\r\n * @param msg the value to pad (Buffer|Array)\r\n * @param length the number of bytes the output should be\r\n * @return (Buffer|Array)\r\n */\r\nexports.setLengthRight = function (msg, length) {\r\n    return exports.setLength(msg, length, true);\r\n};\r\n/**\r\n * Trims leading zeros from a `Buffer` or an `Array`.\r\n * @param a (Buffer|Array|String)\r\n * @return (Buffer|Array|String)\r\n */\r\nexports.unpad = function (a) {\r\n    a = ethjsUtil.stripHexPrefix(a);\r\n    var first = a[0];\r\n    while (a.length > 0 && first.toString() === '0') {\r\n        a = a.slice(1);\r\n        first = a[0];\r\n    }\r\n    return a;\r\n};\r\nexports.stripZeros = exports.unpad;\r\n/**\r\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.\r\n * @param v the value\r\n */\r\nexports.toBuffer = function (v) {\r\n    if (!Buffer.isBuffer(v)) {\r\n        if (Array.isArray(v)) {\r\n            v = Buffer.from(v);\r\n        }\r\n        else if (typeof v === 'string') {\r\n            if (ethjsUtil.isHexString(v)) {\r\n                v = Buffer.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(v)), 'hex');\r\n            }\r\n            else {\r\n                throw new Error(\"Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: \" + v);\r\n            }\r\n        }\r\n        else if (typeof v === 'number') {\r\n            v = ethjsUtil.intToBuffer(v);\r\n        }\r\n        else if (v === null || v === undefined) {\r\n            v = Buffer.allocUnsafe(0);\r\n        }\r\n        else if (BN.isBN(v)) {\r\n            v = v.toArrayLike(Buffer);\r\n        }\r\n        else if (v.toArray) {\r\n            // converts a BN to a Buffer\r\n            v = Buffer.from(v.toArray());\r\n        }\r\n        else {\r\n            throw new Error('invalid type');\r\n        }\r\n    }\r\n    return v;\r\n};\r\n/**\r\n * Converts a `Buffer` to a `Number`.\r\n * @param buf `Buffer` object to convert\r\n * @throws If the input number exceeds 53 bits.\r\n */\r\nexports.bufferToInt = function (buf) {\r\n    return new BN(exports.toBuffer(buf)).toNumber();\r\n};\r\n/**\r\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\r\n * @param buf `Buffer` object to convert\r\n */\r\nexports.bufferToHex = function (buf) {\r\n    buf = exports.toBuffer(buf);\r\n    return '0x' + buf.toString('hex');\r\n};\r\n/**\r\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\r\n * @param num Signed integer value\r\n */\r\nexports.fromSigned = function (num) {\r\n    return new BN(num).fromTwos(256);\r\n};\r\n/**\r\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\r\n * @param num\r\n */\r\nexports.toUnsigned = function (num) {\r\n    return Buffer.from(num.toTwos(256).toArray());\r\n};\r\n/**\r\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\r\n */\r\nexports.addHexPrefix = function (str) {\r\n    if (typeof str !== 'string') {\r\n        return str;\r\n    }\r\n    return ethjsUtil.isHexPrefixed(str) ? str : '0x' + str;\r\n};\r\n/**\r\n * Converts a `Buffer` or `Array` to JSON.\r\n * @param ba (Buffer|Array)\r\n * @return (Array|String|null)\r\n */\r\nexports.baToJSON = function (ba) {\r\n    if (Buffer.isBuffer(ba)) {\r\n        return \"0x\" + ba.toString('hex');\r\n    }\r\n    else if (ba instanceof Array) {\r\n        var array = [];\r\n        for (var i = 0; i < ba.length; i++) {\r\n            array.push(exports.baToJSON(ba[i]));\r\n        }\r\n        return array;\r\n    }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}