{"ast":null,"code":"'use strict';\n\nvar BN = require('./bn');\nvar BufferUtil = require('../util/buffer');\nvar EC = require('elliptic').ec;\nvar ec = new EC('secp256k1');\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n\n/**\r\n *\r\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\r\n *\r\n * @param {BN|String} x - The X coordinate\r\n * @param {BN|String} y - The Y coordinate\r\n * @link https://github.com/indutny/elliptic\r\n * @augments elliptic.curve.point\r\n * @throws {Error} A validation error if exists\r\n * @returns {Point} An instance of Point\r\n * @constructor\r\n */\nvar Point = function Point(x, y, isRed) {\n  try {\n    var point = ecPoint(x, y, isRed);\n  } catch (e) {\n    throw new Error('Invalid Point');\n  }\n  point.validate();\n  return point;\n};\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n\n/**\r\n *\r\n * Instantiate a valid secp256k1 Point from only the X coordinate\r\n *\r\n * @param {boolean} odd - If the Y coordinate is odd\r\n * @param {BN|String} x - The X coordinate\r\n * @throws {Error} A validation error if exists\r\n * @returns {Point} An instance of Point\r\n */\nPoint.fromX = function fromX(odd, x) {\n  try {\n    var point = ecPointFromX(x, odd);\n  } catch (e) {\n    throw new Error('Invalid X');\n  }\n  point.validate();\n  return point;\n};\n\n/**\r\n *\r\n * Will return a secp256k1 ECDSA base point.\r\n *\r\n * @link https://en.bitcoin.it/wiki/Secp256k1\r\n * @returns {Point} An instance of the base point.\r\n */\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n\n/**\r\n *\r\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\r\n *\r\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\r\n * @returns {BN} A BN instance of the number of points on the curve\r\n */\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\nPoint.prototype._getX = Point.prototype.getX;\n\n/**\r\n *\r\n * Will return the X coordinate of the Point\r\n *\r\n * @returns {BN} A BN instance of the X coordinate\r\n */\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\nPoint.prototype._getY = Point.prototype.getY;\n\n/**\r\n *\r\n * Will return the Y coordinate of the Point\r\n *\r\n * @returns {BN} A BN instance of the Y coordinate\r\n */\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n\n/**\r\n *\r\n * Will determine if the point is valid\r\n *\r\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\r\n * @param {Point} An instance of Point\r\n * @throws {Error} A validation error if exists\r\n * @returns {Point} An instance of the same Point\r\n */\nPoint.prototype.validate = function validate() {\n  if (this.isInfinity()) {\n    throw new Error('Point cannot be equal to Infinity');\n  }\n  var p2;\n  try {\n    p2 = ecPointFromX(this.getX(), this.getY().isOdd());\n  } catch (e) {\n    throw new Error('Point does not lie on the curve');\n  }\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  }\n\n  //todo: needs test case\n  if (!this.mul(Point.getN()).isInfinity()) {\n    throw new Error('Point times N must be infinity');\n  }\n  return this;\n};\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({\n    size: 32\n  });\n  var ybuf = point.getY().toBuffer({\n    size: 32\n  });\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n  if (odd) {\n    prefix = Buffer.from([0x03]);\n  } else {\n    prefix = Buffer.from([0x02]);\n  }\n  return BufferUtil.concat([prefix, xbuf]);\n};\nmodule.exports = Point;","map":{"version":3,"names":["BN","require","BufferUtil","EC","ec","ecPoint","curve","point","bind","ecPointFromX","pointFromX","Point","x","y","isRed","e","Error","validate","prototype","Object","getPrototypeOf","fromX","odd","getG","g","getN","n","toArray","_getX","getX","_getY","getY","isInfinity","p2","isOdd","cmp","mul","pointToCompressed","xbuf","toBuffer","size","ybuf","prefix","length","Buffer","from","concat","module","exports"],"sources":["C:/Users/Ndongo/Desktop/noborrar/Ethereum-Blocktick/node_modules/bitcore-lib/lib/crypto/point.js"],"sourcesContent":["'use strict';\r\n\r\nvar BN = require('./bn');\r\nvar BufferUtil = require('../util/buffer');\r\n\r\nvar EC = require('elliptic').ec;\r\nvar ec = new EC('secp256k1');\r\nvar ecPoint = ec.curve.point.bind(ec.curve);\r\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\r\n\r\n/**\r\n *\r\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\r\n *\r\n * @param {BN|String} x - The X coordinate\r\n * @param {BN|String} y - The Y coordinate\r\n * @link https://github.com/indutny/elliptic\r\n * @augments elliptic.curve.point\r\n * @throws {Error} A validation error if exists\r\n * @returns {Point} An instance of Point\r\n * @constructor\r\n */\r\nvar Point = function Point(x, y, isRed) {\r\n  try {\r\n    var point = ecPoint(x, y, isRed);\r\n  } catch (e) {\r\n    throw new Error('Invalid Point');\r\n  }\r\n  point.validate();\r\n  return point;\r\n};\r\n\r\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\r\n\r\n/**\r\n *\r\n * Instantiate a valid secp256k1 Point from only the X coordinate\r\n *\r\n * @param {boolean} odd - If the Y coordinate is odd\r\n * @param {BN|String} x - The X coordinate\r\n * @throws {Error} A validation error if exists\r\n * @returns {Point} An instance of Point\r\n */\r\nPoint.fromX = function fromX(odd, x){\r\n  try {\r\n    var point = ecPointFromX(x, odd);\r\n  } catch (e) {\r\n    throw new Error('Invalid X');\r\n  }\r\n  point.validate();\r\n  return point;\r\n};\r\n\r\n/**\r\n *\r\n * Will return a secp256k1 ECDSA base point.\r\n *\r\n * @link https://en.bitcoin.it/wiki/Secp256k1\r\n * @returns {Point} An instance of the base point.\r\n */\r\nPoint.getG = function getG() {\r\n  return ec.curve.g;\r\n};\r\n\r\n/**\r\n *\r\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\r\n *\r\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\r\n * @returns {BN} A BN instance of the number of points on the curve\r\n */\r\nPoint.getN = function getN() {\r\n  return new BN(ec.curve.n.toArray());\r\n};\r\n\r\nPoint.prototype._getX = Point.prototype.getX;\r\n\r\n/**\r\n *\r\n * Will return the X coordinate of the Point\r\n *\r\n * @returns {BN} A BN instance of the X coordinate\r\n */\r\nPoint.prototype.getX = function getX() {\r\n  return new BN(this._getX().toArray());\r\n};\r\n\r\nPoint.prototype._getY = Point.prototype.getY;\r\n\r\n/**\r\n *\r\n * Will return the Y coordinate of the Point\r\n *\r\n * @returns {BN} A BN instance of the Y coordinate\r\n */\r\nPoint.prototype.getY = function getY() {\r\n  return new BN(this._getY().toArray());\r\n};\r\n\r\n/**\r\n *\r\n * Will determine if the point is valid\r\n *\r\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\r\n * @param {Point} An instance of Point\r\n * @throws {Error} A validation error if exists\r\n * @returns {Point} An instance of the same Point\r\n */\r\nPoint.prototype.validate = function validate() {\r\n\r\n  if (this.isInfinity()){\r\n    throw new Error('Point cannot be equal to Infinity');\r\n  }\r\n\r\n  var p2;\r\n  try {\r\n    p2 = ecPointFromX(this.getX(), this.getY().isOdd());\r\n  } catch (e) {\r\n    throw new Error('Point does not lie on the curve');\r\n  }\r\n\r\n  if (p2.y.cmp(this.y) !== 0) {\r\n    throw new Error('Invalid y value for curve.');\r\n  }\r\n\r\n\r\n  //todo: needs test case\r\n  if (!(this.mul(Point.getN()).isInfinity())) {\r\n    throw new Error('Point times N must be infinity');\r\n  }\r\n\r\n  return this;\r\n\r\n};\r\n\r\nPoint.pointToCompressed = function pointToCompressed(point) {\r\n  var xbuf = point.getX().toBuffer({size: 32});\r\n  var ybuf = point.getY().toBuffer({size: 32});\r\n\r\n  var prefix;\r\n  var odd = ybuf[ybuf.length - 1] % 2;\r\n  if (odd) {\r\n    prefix = Buffer.from([0x03]);\r\n  } else {\r\n    prefix = Buffer.from([0x02]);\r\n  }\r\n  return BufferUtil.concat([prefix, xbuf]);\r\n};\r\n\r\nmodule.exports = Point;\r\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,EAAE,GAAGC,OAAO,CAAC,MAAM,CAAC;AACxB,IAAIC,UAAU,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAE1C,IAAIE,EAAE,GAAGF,OAAO,CAAC,UAAU,CAAC,CAACG,EAAE;AAC/B,IAAIA,EAAE,GAAG,IAAID,EAAE,CAAC,WAAW,CAAC;AAC5B,IAAIE,OAAO,GAAGD,EAAE,CAACE,KAAK,CAACC,KAAK,CAACC,IAAI,CAACJ,EAAE,CAACE,KAAK,CAAC;AAC3C,IAAIG,YAAY,GAAGL,EAAE,CAACE,KAAK,CAACI,UAAU,CAACF,IAAI,CAACJ,EAAE,CAACE,KAAK,CAAC;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIK,KAAK,GAAG,SAASA,KAAK,CAACC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAE;EACtC,IAAI;IACF,IAAIP,KAAK,GAAGF,OAAO,CAACO,CAAC,EAAEC,CAAC,EAAEC,KAAK,CAAC;EAClC,CAAC,CAAC,OAAOC,CAAC,EAAE;IACV,MAAM,IAAIC,KAAK,CAAC,eAAe,CAAC;EAClC;EACAT,KAAK,CAACU,QAAQ,EAAE;EAChB,OAAOV,KAAK;AACd,CAAC;AAEDI,KAAK,CAACO,SAAS,GAAGC,MAAM,CAACC,cAAc,CAAChB,EAAE,CAACE,KAAK,CAACC,KAAK,EAAE,CAAC;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAI,KAAK,CAACU,KAAK,GAAG,SAASA,KAAK,CAACC,GAAG,EAAEV,CAAC,EAAC;EAClC,IAAI;IACF,IAAIL,KAAK,GAAGE,YAAY,CAACG,CAAC,EAAEU,GAAG,CAAC;EAClC,CAAC,CAAC,OAAOP,CAAC,EAAE;IACV,MAAM,IAAIC,KAAK,CAAC,WAAW,CAAC;EAC9B;EACAT,KAAK,CAACU,QAAQ,EAAE;EAChB,OAAOV,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAI,KAAK,CAACY,IAAI,GAAG,SAASA,IAAI,GAAG;EAC3B,OAAOnB,EAAE,CAACE,KAAK,CAACkB,CAAC;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAb,KAAK,CAACc,IAAI,GAAG,SAASA,IAAI,GAAG;EAC3B,OAAO,IAAIzB,EAAE,CAACI,EAAE,CAACE,KAAK,CAACoB,CAAC,CAACC,OAAO,EAAE,CAAC;AACrC,CAAC;AAEDhB,KAAK,CAACO,SAAS,CAACU,KAAK,GAAGjB,KAAK,CAACO,SAAS,CAACW,IAAI;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACAlB,KAAK,CAACO,SAAS,CAACW,IAAI,GAAG,SAASA,IAAI,GAAG;EACrC,OAAO,IAAI7B,EAAE,CAAC,IAAI,CAAC4B,KAAK,EAAE,CAACD,OAAO,EAAE,CAAC;AACvC,CAAC;AAEDhB,KAAK,CAACO,SAAS,CAACY,KAAK,GAAGnB,KAAK,CAACO,SAAS,CAACa,IAAI;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACApB,KAAK,CAACO,SAAS,CAACa,IAAI,GAAG,SAASA,IAAI,GAAG;EACrC,OAAO,IAAI/B,EAAE,CAAC,IAAI,CAAC8B,KAAK,EAAE,CAACH,OAAO,EAAE,CAAC;AACvC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAhB,KAAK,CAACO,SAAS,CAACD,QAAQ,GAAG,SAASA,QAAQ,GAAG;EAE7C,IAAI,IAAI,CAACe,UAAU,EAAE,EAAC;IACpB,MAAM,IAAIhB,KAAK,CAAC,mCAAmC,CAAC;EACtD;EAEA,IAAIiB,EAAE;EACN,IAAI;IACFA,EAAE,GAAGxB,YAAY,CAAC,IAAI,CAACoB,IAAI,EAAE,EAAE,IAAI,CAACE,IAAI,EAAE,CAACG,KAAK,EAAE,CAAC;EACrD,CAAC,CAAC,OAAOnB,CAAC,EAAE;IACV,MAAM,IAAIC,KAAK,CAAC,iCAAiC,CAAC;EACpD;EAEA,IAAIiB,EAAE,CAACpB,CAAC,CAACsB,GAAG,CAAC,IAAI,CAACtB,CAAC,CAAC,KAAK,CAAC,EAAE;IAC1B,MAAM,IAAIG,KAAK,CAAC,4BAA4B,CAAC;EAC/C;;EAGA;EACA,IAAI,CAAE,IAAI,CAACoB,GAAG,CAACzB,KAAK,CAACc,IAAI,EAAE,CAAC,CAACO,UAAU,EAAG,EAAE;IAC1C,MAAM,IAAIhB,KAAK,CAAC,gCAAgC,CAAC;EACnD;EAEA,OAAO,IAAI;AAEb,CAAC;AAEDL,KAAK,CAAC0B,iBAAiB,GAAG,SAASA,iBAAiB,CAAC9B,KAAK,EAAE;EAC1D,IAAI+B,IAAI,GAAG/B,KAAK,CAACsB,IAAI,EAAE,CAACU,QAAQ,CAAC;IAACC,IAAI,EAAE;EAAE,CAAC,CAAC;EAC5C,IAAIC,IAAI,GAAGlC,KAAK,CAACwB,IAAI,EAAE,CAACQ,QAAQ,CAAC;IAACC,IAAI,EAAE;EAAE,CAAC,CAAC;EAE5C,IAAIE,MAAM;EACV,IAAIpB,GAAG,GAAGmB,IAAI,CAACA,IAAI,CAACE,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC;EACnC,IAAIrB,GAAG,EAAE;IACPoB,MAAM,GAAGE,MAAM,CAACC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;EAC9B,CAAC,MAAM;IACLH,MAAM,GAAGE,MAAM,CAACC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;EAC9B;EACA,OAAO3C,UAAU,CAAC4C,MAAM,CAAC,CAACJ,MAAM,EAAEJ,IAAI,CAAC,CAAC;AAC1C,CAAC;AAEDS,MAAM,CAACC,OAAO,GAAGrC,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}