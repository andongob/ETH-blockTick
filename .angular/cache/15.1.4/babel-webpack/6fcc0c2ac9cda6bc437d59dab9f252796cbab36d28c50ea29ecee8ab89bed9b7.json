{"ast":null,"code":"'use strict';\n\nvar BN = require('./bn');\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\nvar BufferUtil = require('../util/buffer');\nvar JSUtil = require('../util/js');\nvar Signature = function Signature(r, s) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s);\n  }\n  if (r instanceof BN) {\n    this.set({\n      r: r,\n      s: s\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n\n/* jshint maxcomplexity: 7 */\nSignature.prototype.set = function (obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; //public key recovery parameter in range [0, 3]\n  this.compressed = typeof obj.compressed !== 'undefined' ? obj.compressed : this.compressed; //whether the recovered pubkey is compressed\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\nSignature.fromCompact = function (buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n  var sig = new Signature();\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n  if (i < 0) {\n    compressed = false;\n    i = i + 4;\n  }\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n  return sig;\n};\nSignature.fromDER = Signature.fromBuffer = function (buf, strict) {\n  var obj = Signature.parseDER(buf, strict);\n  var sig = new Signature();\n  sig.r = obj.r;\n  sig.s = obj.s;\n  return sig;\n};\n\n// The format used in a tx\nSignature.fromTxFormat = function (buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = new Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n};\nSignature.fromString = function (str) {\n  var buf = Buffer.from(str, 'hex');\n  return Signature.fromDER(buf);\n};\n\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\nSignature.parseDER = function (buf, strict) {\n  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n  var header = buf[0];\n  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));\n  length = length < buflength ? length : buflength;\n  var rheader = buf[2 + 0];\n  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;\n  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));\n  var sheader = buf[2 + 2 + rlength + 0];\n  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;\n  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));\n  var obj = {\n    header: header,\n    length: length,\n    rheader: rheader,\n    rlength: rlength,\n    rneg: rneg,\n    rbuf: rbuf,\n    r: r,\n    sheader: sheader,\n    slength: slength,\n    sneg: sneg,\n    sbuf: sbuf,\n    s: s\n  };\n  return obj;\n};\nSignature.prototype.toCompact = function (i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n  var val = i + 27 + 4;\n  if (compressed === false) {\n    val = val - 4;\n  }\n  var b1 = Buffer.from([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\nSignature.prototype.toBuffer = Signature.prototype.toDER = function () {\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n  var rneg = rnbuf[0] & 0x80 ? true : false;\n  var sneg = snbuf[0] & 0x80 ? true : false;\n  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);\n  return der;\n};\nSignature.prototype.toString = function () {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\nSignature.isTxDER = function (buf) {\n  if (buf.length < 9) {\n    //  Non-canonical signature: too short\n    return false;\n  }\n  if (buf.length > 73) {\n    // Non-canonical signature: too long\n    return false;\n  }\n  if (buf[0] !== 0x30) {\n    //  Non-canonical signature: wrong type\n    return false;\n  }\n  if (buf[1] !== buf.length - 3) {\n    //  Non-canonical signature: wrong length marker\n    return false;\n  }\n  var nLenR = buf[3];\n  if (5 + nLenR >= buf.length) {\n    //  Non-canonical signature: S length misplaced\n    return false;\n  }\n  var nLenS = buf[5 + nLenR];\n  if (nLenR + nLenS + 7 !== buf.length) {\n    //  Non-canonical signature: R+S length mismatch\n    return false;\n  }\n  var R = buf.slice(4);\n  if (buf[4 - 2] !== 0x02) {\n    //  Non-canonical signature: R value type mismatch\n    return false;\n  }\n  if (nLenR === 0) {\n    //  Non-canonical signature: R length is zero\n    return false;\n  }\n  if (R[0] & 0x80) {\n    //  Non-canonical signature: R value negative\n    return false;\n  }\n  if (nLenR > 1 && R[0] === 0x00 && !(R[1] & 0x80)) {\n    //  Non-canonical signature: R value excessively padded\n    return false;\n  }\n  var S = buf.slice(6 + nLenR);\n  if (buf[6 + nLenR - 2] !== 0x02) {\n    //  Non-canonical signature: S value type mismatch\n    return false;\n  }\n  if (nLenS === 0) {\n    //  Non-canonical signature: S length is zero\n    return false;\n  }\n  if (S[0] & 0x80) {\n    //  Non-canonical signature: S value negative\n    return false;\n  }\n  if (nLenS > 1 && S[0] === 0x00 && !(S[1] & 0x80)) {\n    //  Non-canonical signature: S value excessively padded\n    return false;\n  }\n  return true;\n};\n\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\nSignature.prototype.hasLowS = function () {\n  if (this.s.lt(new BN(1)) || this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.\n * Translated from bitcoind's IsDefinedHashtypeSignature\n */\nSignature.prototype.hasDefinedHashtype = function () {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  }\n  // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n  return true;\n};\nSignature.prototype.toTxFormat = function () {\n  var derbuf = this.toDER();\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\nSignature.SIGHASH_ALL = 0x01;\nSignature.SIGHASH_NONE = 0x02;\nSignature.SIGHASH_SINGLE = 0x03;\nSignature.SIGHASH_ANYONECANPAY = 0x80;\nmodule.exports = Signature;","map":{"version":3,"names":["BN","require","_","$","BufferUtil","JSUtil","Signature","r","s","set","obj","prototype","undefined","i","compressed","nhashtype","fromCompact","buf","checkArgument","isBuffer","sig","slice","b2","b3","Error","length","fromBuffer","fromDER","strict","parseDER","fromTxFormat","readUInt8","derbuf","fromString","str","Buffer","from","isUndefined","header","buflength","rheader","rlength","rbuf","rneg","sheader","slength","sbuf","sneg","sumlength","toCompact","val","b1","toBuffer","size","concat","toDER","rnbuf","snbuf","der","toString","isTxDER","nLenR","nLenS","R","S","hasLowS","lt","gt","hasDefinedHashtype","isNaturalNumber","temp","SIGHASH_ANYONECANPAY","SIGHASH_ALL","SIGHASH_SINGLE","toTxFormat","alloc","writeUInt8","SIGHASH_NONE","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/bitcore-lib/lib/crypto/signature.js"],"sourcesContent":["'use strict';\n\nvar BN = require('./bn');\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\nvar BufferUtil = require('../util/buffer');\nvar JSUtil = require('../util/js');\n\nvar Signature = function Signature(r, s) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s);\n  }\n  if (r instanceof BN) {\n    this.set({\n      r: r,\n      s: s\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n\n/* jshint maxcomplexity: 7 */\nSignature.prototype.set = function(obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n\n  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; //public key recovery parameter in range [0, 3]\n  this.compressed = typeof obj.compressed !== 'undefined' ?\n    obj.compressed : this.compressed; //whether the recovered pubkey is compressed\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\n\nSignature.fromCompact = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n\n  var sig = new Signature();\n\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n  if (i < 0) {\n    compressed = false;\n    i = i + 4;\n  }\n\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n\n  return sig;\n};\n\nSignature.fromDER = Signature.fromBuffer = function(buf, strict) {\n  var obj = Signature.parseDER(buf, strict);\n  var sig = new Signature();\n\n  sig.r = obj.r;\n  sig.s = obj.s;\n\n  return sig;\n};\n\n// The format used in a tx\nSignature.fromTxFormat = function(buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = new Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n};\n\nSignature.fromString = function(str) {\n  var buf = Buffer.from(str, 'hex');\n  return Signature.fromDER(buf);\n};\n\n\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\nSignature.parseDER = function(buf, strict) {\n  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n\n  var header = buf[0];\n  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));\n\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));\n\n  length = length < buflength ? length : buflength;\n\n  var rheader = buf[2 + 0];\n  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));\n\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;\n  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));\n\n  var sheader = buf[2 + 2 + rlength + 0];\n  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));\n\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;\n  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));\n\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));\n\n  var obj = {\n    header: header,\n    length: length,\n    rheader: rheader,\n    rlength: rlength,\n    rneg: rneg,\n    rbuf: rbuf,\n    r: r,\n    sheader: sheader,\n    slength: slength,\n    sneg: sneg,\n    sbuf: sbuf,\n    s: s\n  };\n\n  return obj;\n};\n\n\nSignature.prototype.toCompact = function(i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n\n  var val = i + 27 + 4;\n  if (compressed === false) {\n    val = val - 4;\n  }\n  var b1 = Buffer.from([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\n\nSignature.prototype.toBuffer = Signature.prototype.toDER = function() {\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n\n  var rneg = rnbuf[0] & 0x80 ? true : false;\n  var sneg = snbuf[0] & 0x80 ? true : false;\n\n  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;\n\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n\n  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);\n  return der;\n};\n\nSignature.prototype.toString = function() {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\nSignature.isTxDER = function(buf) {\n  if (buf.length < 9) {\n    //  Non-canonical signature: too short\n    return false;\n  }\n  if (buf.length > 73) {\n    // Non-canonical signature: too long\n    return false;\n  }\n  if (buf[0] !== 0x30) {\n    //  Non-canonical signature: wrong type\n    return false;\n  }\n  if (buf[1] !== buf.length - 3) {\n    //  Non-canonical signature: wrong length marker\n    return false;\n  }\n  var nLenR = buf[3];\n  if (5 + nLenR >= buf.length) {\n    //  Non-canonical signature: S length misplaced\n    return false;\n  }\n  var nLenS = buf[5 + nLenR];\n  if ((nLenR + nLenS + 7) !== buf.length) {\n    //  Non-canonical signature: R+S length mismatch\n    return false;\n  }\n\n  var R = buf.slice(4);\n  if (buf[4 - 2] !== 0x02) {\n    //  Non-canonical signature: R value type mismatch\n    return false;\n  }\n  if (nLenR === 0) {\n    //  Non-canonical signature: R length is zero\n    return false;\n  }\n  if (R[0] & 0x80) {\n    //  Non-canonical signature: R value negative\n    return false;\n  }\n  if (nLenR > 1 && (R[0] === 0x00) && !(R[1] & 0x80)) {\n    //  Non-canonical signature: R value excessively padded\n    return false;\n  }\n\n  var S = buf.slice(6 + nLenR);\n  if (buf[6 + nLenR - 2] !== 0x02) {\n    //  Non-canonical signature: S value type mismatch\n    return false;\n  }\n  if (nLenS === 0) {\n    //  Non-canonical signature: S length is zero\n    return false;\n  }\n  if (S[0] & 0x80) {\n    //  Non-canonical signature: S value negative\n    return false;\n  }\n  if (nLenS > 1 && (S[0] === 0x00) && !(S[1] & 0x80)) {\n    //  Non-canonical signature: S value excessively padded\n    return false;\n  }\n  return true;\n};\n\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\nSignature.prototype.hasLowS = function() {\n  if (this.s.lt(new BN(1)) ||\n    this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.\n * Translated from bitcoind's IsDefinedHashtypeSignature\n */\nSignature.prototype.hasDefinedHashtype = function() {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  }\n  // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n  return true;\n};\n\nSignature.prototype.toTxFormat = function() {\n  var derbuf = this.toDER();\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\n\nSignature.SIGHASH_ALL = 0x01;\nSignature.SIGHASH_NONE = 0x02;\nSignature.SIGHASH_SINGLE = 0x03;\nSignature.SIGHASH_ANYONECANPAY = 0x80;\n\nmodule.exports = Signature;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}