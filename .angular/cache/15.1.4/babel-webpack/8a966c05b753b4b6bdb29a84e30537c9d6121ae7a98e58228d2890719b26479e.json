{"ast":null,"code":"'use strict';\n\nvar Address = require('../address');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar Opcode = require('../opcode');\nvar PublicKey = require('../publickey');\nvar Signature = require('../crypto/signature');\nvar Networks = require('../networks');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\nvar errors = require('../errors');\nvar buffer = require('buffer');\nvar BufferUtil = require('../util/buffer');\nvar JSUtil = require('../util/js');\n\n/**\n * A bitcoin transaction script. Each transaction's inputs and outputs\n * has a script that is evaluated to validate it's spending.\n *\n * See https://en.bitcoin.it/wiki/Script\n *\n * @constructor\n * @param {Object|string|Buffer=} from optional data to populate script\n */\nvar Script = function Script(from) {\n  if (!(this instanceof Script)) {\n    return new Script(from);\n  }\n  this.chunks = [];\n  if (BufferUtil.isBuffer(from)) {\n    return Script.fromBuffer(from);\n  } else if (from instanceof Address) {\n    return Script.fromAddress(from);\n  } else if (from instanceof Script) {\n    return Script.fromBuffer(from.toBuffer());\n  } else if (_.isString(from)) {\n    return Script.fromString(from);\n  } else if (_.isObject(from) && _.isArray(from.chunks)) {\n    this.set(from);\n  }\n};\nScript.VERIFY_TAPROOT = 1 << 17;\nScript.prototype.set = function (obj) {\n  $.checkArgument(_.isObject(obj));\n  $.checkArgument(_.isArray(obj.chunks));\n  this.chunks = obj.chunks;\n  return this;\n};\nScript.fromBuffer = function (buffer) {\n  var script = new Script();\n  script.chunks = [];\n  var br = new BufferReader(buffer);\n  while (!br.finished()) {\n    try {\n      var opcodenum = br.readUInt8();\n      var len, buf;\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        len = opcodenum;\n        script.chunks.push({\n          buf: br.read(len),\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        len = br.readUInt8();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        len = br.readUInt16LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        len = br.readUInt32LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else {\n        script.chunks.push({\n          opcodenum: opcodenum\n        });\n      }\n    } catch (e) {\n      if (e instanceof RangeError) {\n        throw new errors.Script.InvalidBuffer(buffer.toString('hex'));\n      }\n      throw e;\n    }\n  }\n  return script;\n};\nScript.prototype.toBuffer = function () {\n  var bw = new BufferWriter();\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    var opcodenum = chunk.opcodenum;\n    bw.writeUInt8(chunk.opcodenum);\n    if (chunk.buf) {\n      if (opcodenum < Opcode.OP_PUSHDATA1) {\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        bw.writeUInt8(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        bw.writeUInt16LE(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        bw.writeUInt32LE(chunk.len);\n        bw.write(chunk.buf);\n      }\n    }\n  }\n  return bw.concat();\n};\nScript.fromASM = function (str) {\n  var script = new Script();\n  script.chunks = [];\n  var tokens = str.split(' ');\n  var i = 0;\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n    if (_.isUndefined(opcodenum)) {\n      var buf = Buffer.from(tokens[i], 'hex');\n      script.chunks.push({\n        buf: buf,\n        len: buf.length,\n        opcodenum: buf.length\n      });\n      i = i + 1;\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2], 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n  return script;\n};\nScript.fromHex = function (str) {\n  return new Script(Buffer.from(str, 'hex'));\n};\nScript.fromString = function (str) {\n  if (JSUtil.isHexa(str) || str.length === 0) {\n    return new Script(Buffer.from(str, 'hex'));\n  }\n  var script = new Script();\n  script.chunks = [];\n  var tokens = str.split(' ');\n  var i = 0;\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n    if (_.isUndefined(opcodenum)) {\n      opcodenum = parseInt(token);\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        script.chunks.push({\n          buf: Buffer.from(tokens[i + 1].slice(2), 'hex'),\n          len: opcodenum,\n          opcodenum: opcodenum\n        });\n        i = i + 2;\n      } else {\n        throw new Error('Invalid script: ' + JSON.stringify(str));\n      }\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {\n      if (tokens[i + 2].slice(0, 2) !== '0x') {\n        throw new Error('Pushdata data must start with 0x');\n      }\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2].slice(2), 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n  return script;\n};\nScript.prototype._chunkToString = function (chunk, type) {\n  var opcodenum = chunk.opcodenum;\n  var asm = type === 'asm';\n  var str = '';\n  if (!chunk.buf) {\n    // no data chunk\n    if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {\n      if (asm) {\n        // A few cases where the opcode name differs from reverseMap\n        // aside from 1 to 16 data pushes.\n        if (opcodenum === 0) {\n          // OP_0 -> 0\n          str = str + ' 0';\n        } else if (opcodenum === 79) {\n          // OP_1NEGATE -> 1\n          str = str + ' -1';\n        } else {\n          str = str + ' ' + Opcode(opcodenum).toString();\n        }\n      } else {\n        str = str + ' ' + Opcode(opcodenum).toString();\n      }\n    } else {\n      var numstr = opcodenum.toString(16);\n      if (numstr.length % 2 !== 0) {\n        numstr = '0' + numstr;\n      }\n      if (asm) {\n        str = str + ' ' + numstr;\n      } else {\n        str = str + ' ' + '0x' + numstr;\n      }\n    }\n  } else {\n    // data chunk\n    if (!asm && opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {\n      str = str + ' ' + Opcode(opcodenum).toString();\n    }\n    if (chunk.len > 0) {\n      if (asm) {\n        str = str + ' ' + chunk.buf.toString('hex');\n      } else {\n        str = str + ' ' + chunk.len + ' ' + '0x' + chunk.buf.toString('hex');\n      }\n    }\n  }\n  return str;\n};\nScript.prototype.toASM = function () {\n  var str = '';\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk, 'asm');\n  }\n  return str.substr(1);\n};\nScript.prototype.toString = function () {\n  var str = '';\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk);\n  }\n  return str.substr(1);\n};\nScript.prototype.toHex = function () {\n  return this.toBuffer().toString('hex');\n};\nScript.prototype.inspect = function () {\n  return '<Script: ' + this.toString() + '>';\n};\n\n// script classification methods\n\n/**\n * @returns {boolean} if this is a pay to pubkey hash output script\n */\nScript.prototype.isPublicKeyHashOut = function () {\n  return !!(this.chunks.length === 5 && this.chunks[0].opcodenum === Opcode.OP_DUP && this.chunks[1].opcodenum === Opcode.OP_HASH160 && this.chunks[2].buf && this.chunks[2].buf.length === 20 && this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY && this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);\n};\n\n/**\n * @returns {boolean} if this is a pay to public key hash input script\n */\nScript.prototype.isPublicKeyHashIn = function () {\n  if (this.chunks.length === 2) {\n    var signatureBuf = this.chunks[0].buf;\n    var pubkeyBuf = this.chunks[1].buf;\n    if (signatureBuf && signatureBuf.length && signatureBuf[0] === 0x30 && pubkeyBuf && pubkeyBuf.length) {\n      var version = pubkeyBuf[0];\n      if ((version === 0x04 || version === 0x06 || version === 0x07) && pubkeyBuf.length === 65) {\n        return true;\n      } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\nScript.prototype.getPublicKey = function () {\n  $.checkState(this.isPublicKeyOut(), 'Can\\'t retrieve PublicKey from a non-PK output');\n  return this.chunks[0].buf;\n};\nScript.prototype.getPublicKeyHash = function () {\n  if (this.isPublicKeyHashOut()) {\n    return this.chunks[2].buf;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    return this.chunks[1].buf;\n  } else {\n    throw new Error('Can\\'t retrieve PublicKeyHash from a non-PKH output');\n  }\n};\n\n/**\n * @returns {boolean} if this is a public key output script\n */\nScript.prototype.isPublicKeyOut = function () {\n  if (this.chunks.length === 2 && this.chunks[0].buf && this.chunks[0].buf.length && this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {\n    var pubkeyBuf = this.chunks[0].buf;\n    var version = pubkeyBuf[0];\n    var isVersion = false;\n    if ((version === 0x04 || version === 0x06 || version === 0x07) && pubkeyBuf.length === 65) {\n      isVersion = true;\n    } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n      isVersion = true;\n    }\n    if (isVersion) {\n      return PublicKey.isValid(pubkeyBuf);\n    }\n  }\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a pay to public key input script\n */\nScript.prototype.isPublicKeyIn = function () {\n  if (this.chunks.length === 1) {\n    var signatureBuf = this.chunks[0].buf;\n    if (signatureBuf && signatureBuf.length && signatureBuf[0] === 0x30) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a p2sh output script\n */\nScript.prototype.isScriptHashOut = function () {\n  var buf = this.toBuffer();\n  return buf.length === 23 && buf[0] === Opcode.OP_HASH160 && buf[1] === 0x14 && buf[buf.length - 1] === Opcode.OP_EQUAL;\n};\n\n/**\n * @returns {boolean} if this is a p2wsh output script\n */\nScript.prototype.isWitnessScriptHashOut = function () {\n  var buf = this.toBuffer();\n  return buf.length === 34 && buf[0] === Opcode.OP_0 && buf[1] === 32;\n};\n\n/**\n * @returns {boolean} if this is a p2wpkh output script\n */\nScript.prototype.isWitnessPublicKeyHashOut = function () {\n  var buf = this.toBuffer();\n  return buf.length === 22 && buf[0] === Opcode.OP_0 && buf[1] === 20;\n};\n\n/**\n * @returns {boolean} if this is a p2tr output script\n */\nScript.prototype.isTaproot = function () {\n  var buf = this.toBuffer();\n  return buf.length === 34 && buf[0] === Opcode.OP_1 && buf[1] === 32;\n};\n\n/**\n * @param {Object=} values - The return values\n * @param {Number} values.version - Set with the witness version\n * @param {Buffer} values.program - Set with the witness program\n * @returns {boolean} if this is a p2wpkh output script\n */\nScript.prototype.isWitnessProgram = function (values) {\n  if (!values) {\n    values = {};\n  }\n  var buf = this.toBuffer();\n  if (buf.length < 4 || buf.length > 42) {\n    return false;\n  }\n  if (buf[0] !== Opcode.OP_0 && !(buf[0] >= Opcode.OP_1 && buf[0] <= Opcode.OP_16)) {\n    return false;\n  }\n  if (buf.length === buf[1] + 2) {\n    values.version = buf[0];\n    values.program = buf.slice(2, buf.length);\n    return true;\n  }\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a p2sh input script\n * Note that these are frequently indistinguishable from pubkeyhashin\n */\nScript.prototype.isScriptHashIn = function () {\n  if (this.chunks.length <= 1) {\n    return false;\n  }\n  var redeemChunk = this.chunks[this.chunks.length - 1];\n  var redeemBuf = redeemChunk.buf;\n  if (!redeemBuf) {\n    return false;\n  }\n  var redeemScript;\n  try {\n    redeemScript = Script.fromBuffer(redeemBuf);\n  } catch (e) {\n    if (e instanceof errors.Script.InvalidBuffer) {\n      return false;\n    }\n    throw e;\n  }\n  var type = redeemScript.classify();\n  return type !== Script.types.UNKNOWN;\n};\n\n/**\n * @returns {boolean} if this is a mutlsig output script\n */\nScript.prototype.isMultisigOut = function () {\n  return this.chunks.length > 3 && Opcode.isSmallIntOp(this.chunks[0].opcodenum) && this.chunks.slice(1, this.chunks.length - 2).every(function (obj) {\n    return obj.buf && BufferUtil.isBuffer(obj.buf);\n  }) && Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) && this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG;\n};\n\n/**\n * @returns {boolean} if this is a multisig input script\n */\nScript.prototype.isMultisigIn = function () {\n  return this.chunks.length >= 2 && this.chunks[0].opcodenum === 0 && this.chunks.slice(1, this.chunks.length).every(function (obj) {\n    return obj.buf && BufferUtil.isBuffer(obj.buf) && Signature.isTxDER(obj.buf);\n  });\n};\n\n/**\n * @returns {boolean} true if this is a valid standard OP_RETURN output\n */\nScript.prototype.isDataOut = function () {\n  return this.chunks.length >= 1 && this.chunks[0].opcodenum === Opcode.OP_RETURN && (this.chunks.length === 1 || this.chunks.length === 2 && this.chunks[1].buf && this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE && this.chunks[1].length === this.chunks.len);\n};\n\n/**\n * Retrieve the associated data for this script.\n * In the case of a pay to public key hash, P2SH, P2WSH, or P2WPKH, return the hash.\n * In the case of a standard OP_RETURN, return the data\n * @returns {Buffer}\n */\nScript.prototype.getData = function () {\n  if (this.isDataOut() || this.isScriptHashOut() || this.isWitnessScriptHashOut() || this.isWitnessPublicKeyHashOut() || this.isTaproot()) {\n    if (_.isUndefined(this.chunks[1])) {\n      return Buffer.alloc(0);\n    } else {\n      return Buffer.from(this.chunks[1].buf);\n    }\n  }\n  if (this.isPublicKeyHashOut()) {\n    return Buffer.from(this.chunks[2].buf);\n  }\n  throw new Error('Unrecognized script type to get data from');\n};\n\n/**\n * @returns {boolean} if the script is only composed of data pushing\n * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)\n */\nScript.prototype.isPushOnly = function () {\n  return _.every(this.chunks, function (chunk) {\n    return chunk.opcodenum <= Opcode.OP_16;\n  });\n};\nScript.types = {};\nScript.types.UNKNOWN = 'Unknown';\nScript.types.PUBKEY_OUT = 'Pay to public key';\nScript.types.PUBKEY_IN = 'Spend from public key';\nScript.types.PUBKEYHASH_OUT = 'Pay to public key hash';\nScript.types.PUBKEYHASH_IN = 'Spend from public key hash';\nScript.types.SCRIPTHASH_OUT = 'Pay to script hash';\nScript.types.SCRIPTHASH_IN = 'Spend from script hash';\nScript.types.MULTISIG_OUT = 'Pay to multisig';\nScript.types.MULTISIG_IN = 'Spend from multisig';\nScript.types.DATA_OUT = 'Data push';\nScript.OP_RETURN_STANDARD_SIZE = 80;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classify = function () {\n  if (this._isInput) {\n    return this.classifyInput();\n  } else if (this._isOutput) {\n    return this.classifyOutput();\n  } else {\n    var outputType = this.classifyOutput();\n    return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput();\n  }\n};\nScript.outputIdentifiers = {};\nScript.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;\nScript.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;\nScript.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;\nScript.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;\nScript.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classifyOutput = function () {\n  for (var type in Script.outputIdentifiers) {\n    if (Script.outputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n  return Script.types.UNKNOWN;\n};\nScript.inputIdentifiers = {};\nScript.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;\nScript.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;\nScript.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;\nScript.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classifyInput = function () {\n  for (var type in Script.inputIdentifiers) {\n    if (Script.inputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n  return Script.types.UNKNOWN;\n};\n\n/**\n * @returns {boolean} if script is one of the known types\n */\nScript.prototype.isStandard = function () {\n  // TODO: Add BIP62 compliance\n  return this.classify() !== Script.types.UNKNOWN;\n};\n\n// Script construction methods\n\n/**\n * Adds a script element at the start of the script.\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n */\nScript.prototype.prepend = function (obj) {\n  this._addByType(obj, true);\n  return this;\n};\n\n/**\n * Compares a script with another script\n */\nScript.prototype.equals = function (script) {\n  $.checkState(script instanceof Script, 'Must provide another script');\n  if (this.chunks.length !== script.chunks.length) {\n    return false;\n  }\n  var i;\n  for (i = 0; i < this.chunks.length; i++) {\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {\n      return false;\n    }\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {\n      return false;\n    } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Adds a script element to the end of the script.\n *\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n *\n */\nScript.prototype.add = function (obj) {\n  this._addByType(obj, false);\n  return this;\n};\nScript.prototype._addByType = function (obj, prepend) {\n  if (typeof obj === 'string') {\n    this._addOpcode(obj, prepend);\n  } else if (typeof obj === 'number') {\n    this._addOpcode(obj, prepend);\n  } else if (obj instanceof Opcode) {\n    this._addOpcode(obj, prepend);\n  } else if (BufferUtil.isBuffer(obj)) {\n    this._addBuffer(obj, prepend);\n  } else if (obj instanceof Script) {\n    this.chunks = this.chunks.concat(obj.chunks);\n  } else if (typeof obj === 'object') {\n    this._insertAtPosition(obj, prepend);\n  } else {\n    throw new Error('Invalid script chunk');\n  }\n};\nScript.prototype._insertAtPosition = function (op, prepend) {\n  if (prepend) {\n    this.chunks.unshift(op);\n  } else {\n    this.chunks.push(op);\n  }\n};\nScript.prototype._addOpcode = function (opcode, prepend) {\n  var op;\n  if (typeof opcode === 'number') {\n    op = opcode;\n  } else if (opcode instanceof Opcode) {\n    op = opcode.toNumber();\n  } else {\n    op = Opcode(opcode).toNumber();\n  }\n  this._insertAtPosition({\n    opcodenum: op\n  }, prepend);\n  return this;\n};\nScript.prototype._addBuffer = function (buf, prepend) {\n  var opcodenum;\n  var len = buf.length;\n  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {\n    opcodenum = len;\n  } else if (len < Math.pow(2, 8)) {\n    opcodenum = Opcode.OP_PUSHDATA1;\n  } else if (len < Math.pow(2, 16)) {\n    opcodenum = Opcode.OP_PUSHDATA2;\n  } else if (len < Math.pow(2, 32)) {\n    opcodenum = Opcode.OP_PUSHDATA4;\n  } else {\n    throw new Error('You can\\'t push that much data');\n  }\n  this._insertAtPosition({\n    buf: buf,\n    len: len,\n    opcodenum: opcodenum\n  }, prepend);\n  return this;\n};\nScript.prototype.hasCodeseparators = function () {\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum === Opcode.OP_CODESEPARATOR) {\n      return true;\n    }\n  }\n  return false;\n};\nScript.prototype.removeCodeseparators = function () {\n  var chunks = [];\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {\n      chunks.push(this.chunks[i]);\n    }\n  }\n  this.chunks = chunks;\n  return this;\n};\n\n// high level script builder methods\n\n/**\n * @returns {Script} a new Multisig output script for given public keys,\n * requiring m of those public keys to spend\n * @param {PublicKey[]} publicKeys - list of all public keys controlling the output\n * @param {number} threshold - amount of required signatures to spend the output\n * @param {Object=} opts - Several options:\n *        - noSorting: defaults to false, if true, don't sort the given\n *                      public keys before creating the script\n */\nScript.buildMultisigOut = function (publicKeys, threshold, opts) {\n  $.checkArgument(threshold <= publicKeys.length, 'Number of required signatures must be less than or equal to the number of public keys');\n  opts = opts || {};\n  var script = new Script();\n  script.add(Opcode.smallInt(threshold));\n  publicKeys = _.map(publicKeys, PublicKey);\n  var sorted = publicKeys;\n  if (!opts.noSorting) {\n    sorted = _.sortBy(publicKeys, function (publicKey) {\n      return publicKey.toString('hex');\n    });\n  }\n  for (var i = 0; i < sorted.length; i++) {\n    var publicKey = sorted[i];\n    script.add(publicKey.toBuffer());\n  }\n  script.add(Opcode.smallInt(publicKeys.length));\n  script.add(Opcode.OP_CHECKMULTISIG);\n  return script;\n};\nScript.buildWitnessMultisigOutFromScript = function (script) {\n  if (script instanceof Script) {\n    var s = new Script();\n    s.add(Opcode.OP_0);\n    s.add(Hash.sha256(script.toBuffer()));\n    return s;\n  } else {\n    throw new TypeError('First argument is expected to be a p2sh script');\n  }\n};\n\n/**\n * A new Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\nScript.buildMultisigIn = function (pubkeys, threshold, signatures, opts) {\n  $.checkArgument(_.isArray(pubkeys));\n  $.checkArgument(_.isNumber(threshold));\n  $.checkArgument(_.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n  _.each(signatures, function (signature) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\n    // TODO: allow signatures to be an array of Signature objects\n    s.add(signature);\n  });\n  return s;\n};\n\n/**\n * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\nScript.buildP2SHMultisigIn = function (pubkeys, threshold, signatures, opts) {\n  $.checkArgument(_.isArray(pubkeys));\n  $.checkArgument(_.isNumber(threshold));\n  $.checkArgument(_.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n  _.each(signatures, function (signature) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\n    // TODO: allow signatures to be an array of Signature objects\n    s.add(signature);\n  });\n  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to public key hash output for the given\n * address or public key\n * @param {(Address|PublicKey)} to - destination address or public key\n */\nScript.buildPublicKeyHashOut = function (to) {\n  $.checkArgument(!_.isUndefined(to));\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));\n  if (to instanceof PublicKey) {\n    to = to.toAddress();\n  } else if (_.isString(to)) {\n    to = new Address(to);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_DUP).add(Opcode.OP_HASH160).add(to.hashBuffer).add(Opcode.OP_EQUALVERIFY).add(Opcode.OP_CHECKSIG);\n  s._network = to.network;\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to witness v0 output for the given\n * address\n * @param {(Address|PublicKey)} to - destination address\n */\nScript.buildWitnessV0Out = function (to) {\n  $.checkArgument(!_.isUndefined(to));\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));\n  if (to instanceof PublicKey) {\n    to = to.toAddress(null, Address.PayToWitnessPublicKeyHash);\n  } else if (_.isString(to)) {\n    to = new Address(to);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_0).add(to.hashBuffer);\n  s._network = to.network;\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to public key output for the given\n *  public key\n */\nScript.buildPublicKeyOut = function (pubkey) {\n  $.checkArgument(pubkey instanceof PublicKey);\n  var s = new Script();\n  s.add(pubkey.toBuffer()).add(Opcode.OP_CHECKSIG);\n  return s;\n};\n\n/**\n * @returns {Script} a new OP_RETURN script with data\n * @param {(string|Buffer)} data - the data to embed in the output\n * @param {(string)} encoding - the type of encoding of the string\n */\nScript.buildDataOut = function (data, encoding) {\n  $.checkArgument(_.isUndefined(data) || _.isString(data) || BufferUtil.isBuffer(data));\n  if (_.isString(data)) {\n    data = Buffer.from(data, encoding);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_RETURN);\n  if (!_.isUndefined(data)) {\n    s.add(data);\n  }\n  return s;\n};\n\n/**\n * @param {Script|Address} script - the redeemScript for the new p2sh output.\n *    It can also be a p2sh address\n * @returns {Script} new pay to script hash script for given script\n */\nScript.buildScriptHashOut = function (script) {\n  $.checkArgument(script instanceof Script || script instanceof Address && script.isPayToScriptHash());\n  var s = new Script();\n  s.add(Opcode.OP_HASH160).add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer())).add(Opcode.OP_EQUAL);\n  s._network = script._network || script.network;\n  return s;\n};\n\n/**\n * Builds a scriptSig (a script for an input) that signs a public key output script.\n *\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\nScript.buildPublicKeyIn = function (signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n  var script = new Script();\n  script.add(BufferUtil.concat([signature, BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)]));\n  return script;\n};\n\n/**\n * Builds a scriptSig (a script for an input) that signs a public key hash\n * output script.\n *\n * @param {Buffer|string|PublicKey} publicKey\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\nScript.buildPublicKeyHashIn = function (publicKey, signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n  var script = new Script().add(BufferUtil.concat([signature, BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)])).add(new PublicKey(publicKey).toBuffer());\n  return script;\n};\n\n/**\n * @returns {Script} an empty script\n */\nScript.empty = function () {\n  return new Script();\n};\n\n/**\n * @returns {Script} a new pay to script hash script that pays to this script\n */\nScript.prototype.toScriptHashOut = function () {\n  return Script.buildScriptHashOut(this);\n};\n\n/**\n * @return {Script} an output script built from the address\n */\nScript.fromAddress = function (address) {\n  address = Address(address);\n  if (address.isPayToScriptHash()) {\n    return Script.buildScriptHashOut(address);\n  } else if (address.isPayToPublicKeyHash()) {\n    return Script.buildPublicKeyHashOut(address);\n  } else if (address.isPayToWitnessPublicKeyHash()) {\n    return Script.buildWitnessV0Out(address);\n  } else if (address.isPayToWitnessScriptHash()) {\n    return Script.buildWitnessV0Out(address);\n  }\n  throw new errors.Script.UnrecognizedAddress(address);\n};\n\n/**\n * Will return the associated address information object\n * @return {Address|boolean}\n */\nScript.prototype.getAddressInfo = function (opts) {\n  if (this._isInput) {\n    return this._getInputAddressInfo();\n  } else if (this._isOutput) {\n    return this._getOutputAddressInfo();\n  } else {\n    var info = this._getOutputAddressInfo();\n    if (!info) {\n      return this._getInputAddressInfo();\n    }\n    return info;\n  }\n};\n\n/**\n * Will return the associated output scriptPubKey address information object\n * @return {Address|boolean}\n * @private\n */\nScript.prototype._getOutputAddressInfo = function () {\n  var info = {};\n  if (this.isScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToScriptHash;\n  } else if (this.isPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isWitnessScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessScriptHash;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessPublicKeyHash;\n  } else if (this.isTaproot()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToTaproot;\n  } else {\n    return false;\n  }\n  return info;\n};\n\n/**\n * Will return the associated input scriptSig address information object\n * @return {Address|boolean}\n * @private\n */\nScript.prototype._getInputAddressInfo = function () {\n  var info = {};\n  if (this.isPublicKeyHashIn()) {\n    // hash the publickey found in the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isScriptHashIn()) {\n    // hash the redeemscript found at the end of the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);\n    info.type = Address.PayToScriptHash;\n  } else {\n    return false;\n  }\n  return info;\n};\n\n/**\n * @param {Network=} network\n * @return {Address|boolean} the associated address for this script if possible, or false\n */\nScript.prototype.toAddress = function (network) {\n  var info = this.getAddressInfo();\n  if (!info) {\n    return false;\n  }\n  info.network = Networks.get(network) || this._network || Networks.defaultNetwork;\n  return new Address(info);\n};\n\n/**\n * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks,\n * typically used with push data chunks.  Note that this will find and delete\n * not just the same data, but the same data with the same push data op as\n * produced by default. i.e., if a pushdata in a tx does not use the minimal\n * pushdata op, then when you try to remove the data it is pushing, it will not\n * be removed, because they do not use the same pushdata op.\n */\nScript.prototype.findAndDelete = function (script) {\n  var buf = script.toBuffer();\n  var hex = buf.toString('hex');\n  for (var i = 0; i < this.chunks.length; i++) {\n    var script2 = Script({\n      chunks: [this.chunks[i]]\n    });\n    var buf2 = script2.toBuffer();\n    var hex2 = buf2.toString('hex');\n    if (hex === hex2) {\n      this.chunks.splice(i, 1);\n    }\n  }\n  return this;\n};\n\n/**\n * Comes from bitcoind's script interpreter CheckMinimalPush function\n * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.\n */\nScript.prototype.checkMinimalPush = function (i) {\n  var chunk = this.chunks[i];\n  var buf = chunk.buf;\n  var opcodenum = chunk.opcodenum;\n  if (!buf) {\n    return true;\n  }\n  if (buf.length === 0) {\n    // Could have used OP_0.\n    return opcodenum === Opcode.OP_0;\n  } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {\n    // Could have used OP_1 .. OP_16.\n    return opcodenum === Opcode.OP_1 + (buf[0] - 1);\n  } else if (buf.length === 1 && buf[0] === 0x81) {\n    // Could have used OP_1NEGATE\n    return opcodenum === Opcode.OP_1NEGATE;\n  } else if (buf.length <= 75) {\n    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).\n    return opcodenum === buf.length;\n  } else if (buf.length <= 255) {\n    // Could have used OP_PUSHDATA.\n    return opcodenum === Opcode.OP_PUSHDATA1;\n  } else if (buf.length <= 65535) {\n    // Could have used OP_PUSHDATA2.\n    return opcodenum === Opcode.OP_PUSHDATA2;\n  }\n  return true;\n};\n\n/**\n * Comes from bitcoind's script DecodeOP_N function\n * @param {number} opcode\n * @returns {number} numeric value in range of 0 to 16\n */\nScript.prototype._decodeOP_N = function (opcode) {\n  if (opcode === Opcode.OP_0) {\n    return 0;\n  } else if (opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16) {\n    return opcode - (Opcode.OP_1 - 1);\n  } else {\n    throw new Error('Invalid opcode: ' + JSON.stringify(opcode));\n  }\n};\n\n/**\n * Comes from bitcoind's script GetSigOpCount(boolean) function\n * @param {boolean} use current (true) or pre-version-0.6 (false) logic\n * @returns {number} number of signature operations required by this script\n */\nScript.prototype.getSignatureOperationsCount = function (accurate) {\n  accurate = _.isUndefined(accurate) ? true : accurate;\n  var self = this;\n  var n = 0;\n  var lastOpcode = Opcode.OP_INVALIDOPCODE;\n  _.each(self.chunks, function getChunk(chunk) {\n    var opcode = chunk.opcodenum;\n    if (opcode == Opcode.OP_CHECKSIG || opcode == Opcode.OP_CHECKSIGVERIFY) {\n      n++;\n    } else if (opcode == Opcode.OP_CHECKMULTISIG || opcode == Opcode.OP_CHECKMULTISIGVERIFY) {\n      if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {\n        n += self._decodeOP_N(lastOpcode);\n      } else {\n        n += 20;\n      }\n    }\n    lastOpcode = opcode;\n  });\n  return n;\n};\nmodule.exports = Script;","map":{"version":3,"names":["Address","require","BufferReader","BufferWriter","Hash","Opcode","PublicKey","Signature","Networks","$","_","errors","buffer","BufferUtil","JSUtil","Script","from","chunks","isBuffer","fromBuffer","fromAddress","toBuffer","isString","fromString","isObject","isArray","set","VERIFY_TAPROOT","prototype","obj","checkArgument","script","br","finished","opcodenum","readUInt8","len","buf","OP_PUSHDATA1","push","read","OP_PUSHDATA2","readUInt16LE","OP_PUSHDATA4","readUInt32LE","e","RangeError","InvalidBuffer","toString","bw","i","length","chunk","writeUInt8","write","writeUInt16LE","writeUInt32LE","concat","fromASM","str","tokens","split","token","opcode","toNumber","isUndefined","Buffer","parseInt","fromHex","isHexa","slice","Error","JSON","stringify","_chunkToString","type","asm","reverseMap","numstr","toASM","substr","toHex","inspect","isPublicKeyHashOut","OP_DUP","OP_HASH160","OP_EQUALVERIFY","OP_CHECKSIG","isPublicKeyHashIn","signatureBuf","pubkeyBuf","version","getPublicKey","checkState","isPublicKeyOut","getPublicKeyHash","isWitnessPublicKeyHashOut","isVersion","isValid","isPublicKeyIn","isScriptHashOut","OP_EQUAL","isWitnessScriptHashOut","OP_0","isTaproot","OP_1","isWitnessProgram","values","OP_16","program","isScriptHashIn","redeemChunk","redeemBuf","redeemScript","classify","types","UNKNOWN","isMultisigOut","isSmallIntOp","every","OP_CHECKMULTISIG","isMultisigIn","isTxDER","isDataOut","OP_RETURN","OP_RETURN_STANDARD_SIZE","getData","alloc","isPushOnly","PUBKEY_OUT","PUBKEY_IN","PUBKEYHASH_OUT","PUBKEYHASH_IN","SCRIPTHASH_OUT","SCRIPTHASH_IN","MULTISIG_OUT","MULTISIG_IN","DATA_OUT","_isInput","classifyInput","_isOutput","classifyOutput","outputType","outputIdentifiers","bind","inputIdentifiers","isStandard","prepend","_addByType","equals","add","_addOpcode","_addBuffer","_insertAtPosition","op","unshift","Math","pow","hasCodeseparators","OP_CODESEPARATOR","removeCodeseparators","buildMultisigOut","publicKeys","threshold","opts","smallInt","map","sorted","noSorting","sortBy","publicKey","buildWitnessMultisigOutFromScript","s","sha256","TypeError","buildMultisigIn","pubkeys","signatures","isNumber","each","signature","buildP2SHMultisigIn","cachedMultisig","buildPublicKeyHashOut","to","toAddress","hashBuffer","_network","network","buildWitnessV0Out","PayToWitnessPublicKeyHash","buildPublicKeyOut","pubkey","buildDataOut","data","encoding","buildScriptHashOut","isPayToScriptHash","sha256ripemd160","buildPublicKeyIn","sigtype","integerAsSingleByteBuffer","SIGHASH_ALL","buildPublicKeyHashIn","empty","toScriptHashOut","address","isPayToPublicKeyHash","isPayToWitnessPublicKeyHash","isPayToWitnessScriptHash","UnrecognizedAddress","getAddressInfo","_getInputAddressInfo","_getOutputAddressInfo","info","PayToScriptHash","PayToPublicKeyHash","PayToWitnessScriptHash","PayToTaproot","get","defaultNetwork","findAndDelete","hex","script2","buf2","hex2","splice","checkMinimalPush","OP_1NEGATE","_decodeOP_N","getSignatureOperationsCount","accurate","self","n","lastOpcode","OP_INVALIDOPCODE","getChunk","OP_CHECKSIGVERIFY","OP_CHECKMULTISIGVERIFY","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/bitcore-lib/lib/script/script.js"],"sourcesContent":["'use strict';\n\nvar Address = require('../address');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar Opcode = require('../opcode');\nvar PublicKey = require('../publickey');\nvar Signature = require('../crypto/signature');\nvar Networks = require('../networks');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\nvar errors = require('../errors');\nvar buffer = require('buffer');\nvar BufferUtil = require('../util/buffer');\nvar JSUtil = require('../util/js');\n\n/**\n * A bitcoin transaction script. Each transaction's inputs and outputs\n * has a script that is evaluated to validate it's spending.\n *\n * See https://en.bitcoin.it/wiki/Script\n *\n * @constructor\n * @param {Object|string|Buffer=} from optional data to populate script\n */\nvar Script = function Script(from) {\n  if (!(this instanceof Script)) {\n    return new Script(from);\n  }\n  this.chunks = [];\n\n  if (BufferUtil.isBuffer(from)) {\n    return Script.fromBuffer(from);\n  } else if (from instanceof Address) {\n    return Script.fromAddress(from);\n  } else if (from instanceof Script) {\n    return Script.fromBuffer(from.toBuffer());\n  } else if (_.isString(from)) {\n    return Script.fromString(from);\n  } else if (_.isObject(from) && _.isArray(from.chunks)) {\n    this.set(from);\n  }\n};\n\nScript.VERIFY_TAPROOT = (1 << 17);\n\n\nScript.prototype.set = function(obj) {\n  $.checkArgument(_.isObject(obj));\n  $.checkArgument(_.isArray(obj.chunks));\n  this.chunks = obj.chunks;\n  return this;\n};\n\nScript.fromBuffer = function(buffer) {\n  var script = new Script();\n  script.chunks = [];\n\n  var br = new BufferReader(buffer);\n  while (!br.finished()) {\n    try {\n      var opcodenum = br.readUInt8();\n\n      var len, buf;\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        len = opcodenum;\n        script.chunks.push({\n          buf: br.read(len),\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        len = br.readUInt8();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        len = br.readUInt16LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        len = br.readUInt32LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else {\n        script.chunks.push({\n          opcodenum: opcodenum\n        });\n      }\n    } catch (e) {\n      if (e instanceof RangeError) {\n        throw new errors.Script.InvalidBuffer(buffer.toString('hex'));\n      }\n      throw e;\n    }\n  }\n\n  return script;\n};\n\nScript.prototype.toBuffer = function() {\n  var bw = new BufferWriter();\n\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    var opcodenum = chunk.opcodenum;\n    bw.writeUInt8(chunk.opcodenum);\n    if (chunk.buf) {\n      if (opcodenum < Opcode.OP_PUSHDATA1) {\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        bw.writeUInt8(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        bw.writeUInt16LE(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        bw.writeUInt32LE(chunk.len);\n        bw.write(chunk.buf);\n      }\n    }\n  }\n\n  return bw.concat();\n};\n\nScript.fromASM = function(str) {\n  var script = new Script();\n  script.chunks = [];\n\n  var tokens = str.split(' ');\n  var i = 0;\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (_.isUndefined(opcodenum)) {\n      var buf = Buffer.from(tokens[i], 'hex');\n      script.chunks.push({\n        buf: buf,\n        len: buf.length,\n        opcodenum: buf.length\n      });\n      i = i + 1;\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2], 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n  return script;\n};\n\nScript.fromHex = function(str) {\n  return new Script(Buffer.from(str, 'hex'));\n};\n\nScript.fromString = function(str) {\n  if (JSUtil.isHexa(str) || str.length === 0) {\n    return new Script(Buffer.from(str, 'hex'));\n  }\n  var script = new Script();\n  script.chunks = [];\n\n  var tokens = str.split(' ');\n  var i = 0;\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (_.isUndefined(opcodenum)) {\n      opcodenum = parseInt(token);\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        script.chunks.push({\n          buf: Buffer.from(tokens[i + 1].slice(2), 'hex'),\n          len: opcodenum,\n          opcodenum: opcodenum\n        });\n        i = i + 2;\n      } else {\n        throw new Error('Invalid script: ' + JSON.stringify(str));\n      }\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      if (tokens[i + 2].slice(0, 2) !== '0x') {\n        throw new Error('Pushdata data must start with 0x');\n      }\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2].slice(2), 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n  return script;\n};\n\nScript.prototype._chunkToString = function(chunk, type) {\n  var opcodenum = chunk.opcodenum;\n  var asm = (type === 'asm');\n  var str = '';\n  if (!chunk.buf) {\n    // no data chunk\n    if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {\n      if (asm) {\n        // A few cases where the opcode name differs from reverseMap\n        // aside from 1 to 16 data pushes.\n        if (opcodenum === 0) {\n          // OP_0 -> 0\n          str = str + ' 0';\n        } else if(opcodenum === 79) {\n          // OP_1NEGATE -> 1\n          str = str + ' -1';\n        } else {\n          str = str + ' ' + Opcode(opcodenum).toString();\n        }\n      } else {\n        str = str + ' ' + Opcode(opcodenum).toString();\n      }\n    } else {\n      var numstr = opcodenum.toString(16);\n      if (numstr.length % 2 !== 0) {\n        numstr = '0' + numstr;\n      }\n      if (asm) {\n        str = str + ' ' + numstr;\n      } else {\n        str = str + ' ' + '0x' + numstr;\n      }\n    }\n  } else {\n    // data chunk\n    if (!asm && opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      str = str + ' ' + Opcode(opcodenum).toString();\n    }\n    if (chunk.len > 0) {\n      if (asm) {\n        str = str + ' ' + chunk.buf.toString('hex');\n      } else {\n        str = str + ' ' + chunk.len + ' ' + '0x' + chunk.buf.toString('hex');\n      }\n    }\n  }\n  return str;\n};\n\nScript.prototype.toASM = function() {\n  var str = '';\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk, 'asm');\n  }\n\n  return str.substr(1);\n};\n\nScript.prototype.toString = function() {\n  var str = '';\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk);\n  }\n\n  return str.substr(1);\n};\n\nScript.prototype.toHex = function() {\n  return this.toBuffer().toString('hex');\n};\n\nScript.prototype.inspect = function() {\n  return '<Script: ' + this.toString() + '>';\n};\n\n// script classification methods\n\n/**\n * @returns {boolean} if this is a pay to pubkey hash output script\n */\nScript.prototype.isPublicKeyHashOut = function() {\n  return !!(this.chunks.length === 5 &&\n    this.chunks[0].opcodenum === Opcode.OP_DUP &&\n    this.chunks[1].opcodenum === Opcode.OP_HASH160 &&\n    this.chunks[2].buf &&\n    this.chunks[2].buf.length === 20 &&\n    this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY &&\n    this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);\n};\n\n/**\n * @returns {boolean} if this is a pay to public key hash input script\n */\nScript.prototype.isPublicKeyHashIn = function() {\n  if (this.chunks.length === 2) {\n    var signatureBuf = this.chunks[0].buf;\n    var pubkeyBuf = this.chunks[1].buf;\n    if (signatureBuf &&\n        signatureBuf.length &&\n        signatureBuf[0] === 0x30 &&\n        pubkeyBuf &&\n        pubkeyBuf.length\n       ) {\n      var version = pubkeyBuf[0];\n      if ((version === 0x04 ||\n           version === 0x06 ||\n           version === 0x07) && pubkeyBuf.length === 65) {\n        return true;\n      } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nScript.prototype.getPublicKey = function() {\n  $.checkState(this.isPublicKeyOut(), 'Can\\'t retrieve PublicKey from a non-PK output');\n  return this.chunks[0].buf;\n};\n\nScript.prototype.getPublicKeyHash = function() {\n  if (this.isPublicKeyHashOut()) {\n    return this.chunks[2].buf;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    return this.chunks[1].buf;\n  } else {\n    throw new Error('Can\\'t retrieve PublicKeyHash from a non-PKH output');\n  }\n};\n\n/**\n * @returns {boolean} if this is a public key output script\n */\nScript.prototype.isPublicKeyOut = function() {\n  if (this.chunks.length === 2 &&\n      this.chunks[0].buf &&\n      this.chunks[0].buf.length &&\n      this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {\n    var pubkeyBuf = this.chunks[0].buf;\n    var version = pubkeyBuf[0];\n    var isVersion = false;\n    if ((version === 0x04 ||\n         version === 0x06 ||\n         version === 0x07) && pubkeyBuf.length === 65) {\n      isVersion = true;\n    } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n      isVersion = true;\n    }\n    if (isVersion) {\n      return PublicKey.isValid(pubkeyBuf);\n    }\n  }\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a pay to public key input script\n */\nScript.prototype.isPublicKeyIn = function() {\n  if (this.chunks.length === 1) {\n    var signatureBuf = this.chunks[0].buf;\n    if (signatureBuf &&\n        signatureBuf.length &&\n        signatureBuf[0] === 0x30) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a p2sh output script\n */\nScript.prototype.isScriptHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 23 &&\n    buf[0] === Opcode.OP_HASH160 &&\n    buf[1] === 0x14 &&\n    buf[buf.length - 1] === Opcode.OP_EQUAL);\n};\n\n/**\n * @returns {boolean} if this is a p2wsh output script\n */\nScript.prototype.isWitnessScriptHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 34 && buf[0] === Opcode.OP_0 && buf[1] === 32);\n};\n\n/**\n * @returns {boolean} if this is a p2wpkh output script\n */\nScript.prototype.isWitnessPublicKeyHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 22 && buf[0] === Opcode.OP_0 && buf[1] === 20);\n};\n\n/**\n * @returns {boolean} if this is a p2tr output script\n */\nScript.prototype.isTaproot = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 34 && buf[0] === Opcode.OP_1 && buf[1] === 32);\n}\n\n/**\n * @param {Object=} values - The return values\n * @param {Number} values.version - Set with the witness version\n * @param {Buffer} values.program - Set with the witness program\n * @returns {boolean} if this is a p2wpkh output script\n */\nScript.prototype.isWitnessProgram = function(values) {\n  if (!values) {\n    values = {};\n  }\n  var buf = this.toBuffer();\n  if (buf.length < 4 || buf.length > 42) {\n    return false;\n  }\n  if (buf[0] !== Opcode.OP_0 && !(buf[0] >= Opcode.OP_1 && buf[0] <= Opcode.OP_16)) {\n    return false;\n  }\n\n  if (buf.length === buf[1] + 2) {\n    values.version = buf[0];\n    values.program = buf.slice(2, buf.length);\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a p2sh input script\n * Note that these are frequently indistinguishable from pubkeyhashin\n */\nScript.prototype.isScriptHashIn = function() {\n  if (this.chunks.length <= 1) {\n    return false;\n  }\n  var redeemChunk = this.chunks[this.chunks.length - 1];\n  var redeemBuf = redeemChunk.buf;\n  if (!redeemBuf) {\n    return false;\n  }\n\n  var redeemScript;\n  try {\n    redeemScript = Script.fromBuffer(redeemBuf);\n  } catch (e) {\n    if (e instanceof errors.Script.InvalidBuffer) {\n      return false;\n    }\n    throw e;\n  }\n  var type = redeemScript.classify();\n  return type !== Script.types.UNKNOWN;\n};\n\n/**\n * @returns {boolean} if this is a mutlsig output script\n */\nScript.prototype.isMultisigOut = function() {\n  return (this.chunks.length > 3 &&\n    Opcode.isSmallIntOp(this.chunks[0].opcodenum) &&\n    this.chunks.slice(1, this.chunks.length - 2).every(function(obj) {\n      return obj.buf && BufferUtil.isBuffer(obj.buf);\n    }) &&\n    Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) &&\n    this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG);\n};\n\n\n/**\n * @returns {boolean} if this is a multisig input script\n */\nScript.prototype.isMultisigIn = function() {\n  return this.chunks.length >= 2 &&\n    this.chunks[0].opcodenum === 0 &&\n    this.chunks.slice(1, this.chunks.length).every(function(obj) {\n      return obj.buf &&\n        BufferUtil.isBuffer(obj.buf) &&\n        Signature.isTxDER(obj.buf);\n    });\n};\n\n/**\n * @returns {boolean} true if this is a valid standard OP_RETURN output\n */\nScript.prototype.isDataOut = function() {\n  return this.chunks.length >= 1 &&\n    this.chunks[0].opcodenum === Opcode.OP_RETURN &&\n    (this.chunks.length === 1 ||\n      (this.chunks.length === 2 &&\n        this.chunks[1].buf &&\n        this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE &&\n        this.chunks[1].length === this.chunks.len));\n};\n\n/**\n * Retrieve the associated data for this script.\n * In the case of a pay to public key hash, P2SH, P2WSH, or P2WPKH, return the hash.\n * In the case of a standard OP_RETURN, return the data\n * @returns {Buffer}\n */\nScript.prototype.getData = function() {\n  if (this.isDataOut() || this.isScriptHashOut() || this.isWitnessScriptHashOut() || this.isWitnessPublicKeyHashOut() || this.isTaproot()) {\n    if (_.isUndefined(this.chunks[1])) {\n      return Buffer.alloc(0);\n    } else {\n      return Buffer.from(this.chunks[1].buf);\n    }\n  }\n  if (this.isPublicKeyHashOut()) {\n    return Buffer.from(this.chunks[2].buf);\n  }\n  throw new Error('Unrecognized script type to get data from');\n};\n\n/**\n * @returns {boolean} if the script is only composed of data pushing\n * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)\n */\nScript.prototype.isPushOnly = function() {\n  return _.every(this.chunks, function(chunk) {\n    return chunk.opcodenum <= Opcode.OP_16;\n  });\n};\n\n\nScript.types = {};\nScript.types.UNKNOWN = 'Unknown';\nScript.types.PUBKEY_OUT = 'Pay to public key';\nScript.types.PUBKEY_IN = 'Spend from public key';\nScript.types.PUBKEYHASH_OUT = 'Pay to public key hash';\nScript.types.PUBKEYHASH_IN = 'Spend from public key hash';\nScript.types.SCRIPTHASH_OUT = 'Pay to script hash';\nScript.types.SCRIPTHASH_IN = 'Spend from script hash';\nScript.types.MULTISIG_OUT = 'Pay to multisig';\nScript.types.MULTISIG_IN = 'Spend from multisig';\nScript.types.DATA_OUT = 'Data push';\n\nScript.OP_RETURN_STANDARD_SIZE = 80;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classify = function() {\n  if (this._isInput) {\n    return this.classifyInput();\n  } else if (this._isOutput) {\n    return this.classifyOutput();\n  } else {\n    var outputType = this.classifyOutput();\n    return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput();\n  }\n};\n\nScript.outputIdentifiers = {};\nScript.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;\nScript.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;\nScript.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;\nScript.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;\nScript.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classifyOutput = function() {\n  for (var type in Script.outputIdentifiers) {\n    if (Script.outputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n  return Script.types.UNKNOWN;\n};\n\nScript.inputIdentifiers = {};\nScript.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;\nScript.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;\nScript.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;\nScript.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classifyInput = function() {\n  for (var type in Script.inputIdentifiers) {\n    if (Script.inputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n  return Script.types.UNKNOWN;\n};\n\n\n/**\n * @returns {boolean} if script is one of the known types\n */\nScript.prototype.isStandard = function() {\n  // TODO: Add BIP62 compliance\n  return this.classify() !== Script.types.UNKNOWN;\n};\n\n\n// Script construction methods\n\n/**\n * Adds a script element at the start of the script.\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n */\nScript.prototype.prepend = function(obj) {\n  this._addByType(obj, true);\n  return this;\n};\n\n/**\n * Compares a script with another script\n */\nScript.prototype.equals = function(script) {\n  $.checkState(script instanceof Script, 'Must provide another script');\n  if (this.chunks.length !== script.chunks.length) {\n    return false;\n  }\n  var i;\n  for (i = 0; i < this.chunks.length; i++) {\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {\n      return false;\n    }\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {\n      return false;\n    } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Adds a script element to the end of the script.\n *\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n *\n */\nScript.prototype.add = function(obj) {\n  this._addByType(obj, false);\n  return this;\n};\n\nScript.prototype._addByType = function(obj, prepend) {\n  if (typeof obj === 'string') {\n    this._addOpcode(obj, prepend);\n  } else if (typeof obj === 'number') {\n    this._addOpcode(obj, prepend);\n  } else if (obj instanceof Opcode) {\n    this._addOpcode(obj, prepend);\n  } else if (BufferUtil.isBuffer(obj)) {\n    this._addBuffer(obj, prepend);\n  } else if (obj instanceof Script) {\n    this.chunks = this.chunks.concat(obj.chunks);\n  } else if (typeof obj === 'object') {\n    this._insertAtPosition(obj, prepend);\n  } else {\n    throw new Error('Invalid script chunk');\n  }\n};\n\nScript.prototype._insertAtPosition = function(op, prepend) {\n  if (prepend) {\n    this.chunks.unshift(op);\n  } else {\n    this.chunks.push(op);\n  }\n};\n\nScript.prototype._addOpcode = function(opcode, prepend) {\n  var op;\n  if (typeof opcode === 'number') {\n    op = opcode;\n  } else if (opcode instanceof Opcode) {\n    op = opcode.toNumber();\n  } else {\n    op = Opcode(opcode).toNumber();\n  }\n  this._insertAtPosition({\n    opcodenum: op\n  }, prepend);\n  return this;\n};\n\nScript.prototype._addBuffer = function(buf, prepend) {\n  var opcodenum;\n  var len = buf.length;\n  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {\n    opcodenum = len;\n  } else if (len < Math.pow(2, 8)) {\n    opcodenum = Opcode.OP_PUSHDATA1;\n  } else if (len < Math.pow(2, 16)) {\n    opcodenum = Opcode.OP_PUSHDATA2;\n  } else if (len < Math.pow(2, 32)) {\n    opcodenum = Opcode.OP_PUSHDATA4;\n  } else {\n    throw new Error('You can\\'t push that much data');\n  }\n  this._insertAtPosition({\n    buf: buf,\n    len: len,\n    opcodenum: opcodenum\n  }, prepend);\n  return this;\n};\n\nScript.prototype.hasCodeseparators = function() {\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum === Opcode.OP_CODESEPARATOR) {\n      return true;\n    }\n  }\n  return false;\n};\n\nScript.prototype.removeCodeseparators = function() {\n  var chunks = [];\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {\n      chunks.push(this.chunks[i]);\n    }\n  }\n  this.chunks = chunks;\n  return this;\n};\n\n// high level script builder methods\n\n/**\n * @returns {Script} a new Multisig output script for given public keys,\n * requiring m of those public keys to spend\n * @param {PublicKey[]} publicKeys - list of all public keys controlling the output\n * @param {number} threshold - amount of required signatures to spend the output\n * @param {Object=} opts - Several options:\n *        - noSorting: defaults to false, if true, don't sort the given\n *                      public keys before creating the script\n */\nScript.buildMultisigOut = function(publicKeys, threshold, opts) {\n  $.checkArgument(threshold <= publicKeys.length,\n    'Number of required signatures must be less than or equal to the number of public keys');\n  opts = opts || {};\n  var script = new Script();\n  script.add(Opcode.smallInt(threshold));\n  publicKeys = _.map(publicKeys, PublicKey);\n  var sorted = publicKeys;\n  if (!opts.noSorting) {\n    sorted = _.sortBy(publicKeys, function(publicKey) {\n      return publicKey.toString('hex');\n    });\n  }\n  for (var i = 0; i < sorted.length; i++) {\n    var publicKey = sorted[i];\n    script.add(publicKey.toBuffer());\n  }\n  script.add(Opcode.smallInt(publicKeys.length));\n  script.add(Opcode.OP_CHECKMULTISIG);\n  return script;\n};\n\nScript.buildWitnessMultisigOutFromScript = function(script) {\n  if (script instanceof Script) {\n    var s = new Script();\n    s.add(Opcode.OP_0);\n    s.add(Hash.sha256(script.toBuffer()));\n    return s;\n  } else {\n    throw new TypeError('First argument is expected to be a p2sh script');\n  }\n};\n\n/**\n * A new Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\nScript.buildMultisigIn = function(pubkeys, threshold, signatures, opts) {\n  $.checkArgument(_.isArray(pubkeys));\n  $.checkArgument(_.isNumber(threshold));\n  $.checkArgument(_.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n  _.each(signatures, function(signature) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\n    // TODO: allow signatures to be an array of Signature objects\n    s.add(signature);\n  });\n  return s;\n};\n\n/**\n * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\nScript.buildP2SHMultisigIn = function(pubkeys, threshold, signatures, opts) {\n  $.checkArgument(_.isArray(pubkeys));\n  $.checkArgument(_.isNumber(threshold));\n  $.checkArgument(_.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n  _.each(signatures, function(signature) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\n    // TODO: allow signatures to be an array of Signature objects\n    s.add(signature);\n  });\n  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to public key hash output for the given\n * address or public key\n * @param {(Address|PublicKey)} to - destination address or public key\n */\nScript.buildPublicKeyHashOut = function(to) {\n  $.checkArgument(!_.isUndefined(to));\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));\n  if (to instanceof PublicKey) {\n    to = to.toAddress();\n  } else if (_.isString(to)) {\n    to = new Address(to);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_DUP)\n    .add(Opcode.OP_HASH160)\n    .add(to.hashBuffer)\n    .add(Opcode.OP_EQUALVERIFY)\n    .add(Opcode.OP_CHECKSIG);\n  s._network = to.network;\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to witness v0 output for the given\n * address\n * @param {(Address|PublicKey)} to - destination address\n */\nScript.buildWitnessV0Out = function(to) {\n  $.checkArgument(!_.isUndefined(to));\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));\n  if (to instanceof PublicKey) {\n    to = to.toAddress(null, Address.PayToWitnessPublicKeyHash);\n  } else if (_.isString(to)) {\n    to = new Address(to);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_0)\n    .add(to.hashBuffer);\n  s._network = to.network;\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to public key output for the given\n *  public key\n */\nScript.buildPublicKeyOut = function(pubkey) {\n  $.checkArgument(pubkey instanceof PublicKey);\n  var s = new Script();\n  s.add(pubkey.toBuffer())\n    .add(Opcode.OP_CHECKSIG);\n  return s;\n};\n\n/**\n * @returns {Script} a new OP_RETURN script with data\n * @param {(string|Buffer)} data - the data to embed in the output\n * @param {(string)} encoding - the type of encoding of the string\n */\nScript.buildDataOut = function(data, encoding) {\n  $.checkArgument(_.isUndefined(data) || _.isString(data) || BufferUtil.isBuffer(data));\n  if (_.isString(data)) {\n    data = Buffer.from(data, encoding);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_RETURN);\n  if (!_.isUndefined(data)) {\n    s.add(data);\n  }\n  return s;\n};\n\n/**\n * @param {Script|Address} script - the redeemScript for the new p2sh output.\n *    It can also be a p2sh address\n * @returns {Script} new pay to script hash script for given script\n */\nScript.buildScriptHashOut = function(script) {\n  $.checkArgument(script instanceof Script ||\n    (script instanceof Address && script.isPayToScriptHash()));\n  var s = new Script();\n  s.add(Opcode.OP_HASH160)\n    .add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer()))\n    .add(Opcode.OP_EQUAL);\n\n  s._network = script._network || script.network;\n  return s;\n};\n\n/**\n * Builds a scriptSig (a script for an input) that signs a public key output script.\n *\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\nScript.buildPublicKeyIn = function(signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n  var script = new Script();\n  script.add(BufferUtil.concat([\n    signature,\n    BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)\n  ]));\n  return script;\n};\n\n/**\n * Builds a scriptSig (a script for an input) that signs a public key hash\n * output script.\n *\n * @param {Buffer|string|PublicKey} publicKey\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\nScript.buildPublicKeyHashIn = function(publicKey, signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n  var script = new Script()\n    .add(BufferUtil.concat([\n      signature,\n      BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)\n    ]))\n    .add(new PublicKey(publicKey).toBuffer());\n  return script;\n};\n\n/**\n * @returns {Script} an empty script\n */\nScript.empty = function() {\n  return new Script();\n};\n\n/**\n * @returns {Script} a new pay to script hash script that pays to this script\n */\nScript.prototype.toScriptHashOut = function() {\n  return Script.buildScriptHashOut(this);\n};\n\n/**\n * @return {Script} an output script built from the address\n */\nScript.fromAddress = function(address) {\n  address = Address(address);\n  if (address.isPayToScriptHash()) {\n    return Script.buildScriptHashOut(address);\n  } else if (address.isPayToPublicKeyHash()) {\n    return Script.buildPublicKeyHashOut(address);\n  } else if (address.isPayToWitnessPublicKeyHash()) {\n    return Script.buildWitnessV0Out(address);\n  } else if (address.isPayToWitnessScriptHash()) {\n    return Script.buildWitnessV0Out(address);\n  }\n  throw new errors.Script.UnrecognizedAddress(address);\n};\n\n/**\n * Will return the associated address information object\n * @return {Address|boolean}\n */\nScript.prototype.getAddressInfo = function(opts) {\n  if (this._isInput) {\n    return this._getInputAddressInfo();\n  } else if (this._isOutput) {\n    return this._getOutputAddressInfo();\n  } else {\n    var info = this._getOutputAddressInfo();\n    if (!info) {\n      return this._getInputAddressInfo();\n    }\n    return info;\n  }\n};\n\n/**\n * Will return the associated output scriptPubKey address information object\n * @return {Address|boolean}\n * @private\n */\nScript.prototype._getOutputAddressInfo = function() {\n  var info = {};\n  if (this.isScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToScriptHash;\n  } else if (this.isPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isWitnessScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessScriptHash;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessPublicKeyHash;\n  } else if (this.isTaproot()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToTaproot;\n  } else {\n    return false;\n  }\n  return info;\n};\n\n/**\n * Will return the associated input scriptSig address information object\n * @return {Address|boolean}\n * @private\n */\nScript.prototype._getInputAddressInfo = function() {\n  var info = {};\n  if (this.isPublicKeyHashIn()) {\n    // hash the publickey found in the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isScriptHashIn()) {\n    // hash the redeemscript found at the end of the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);\n    info.type = Address.PayToScriptHash;\n  } else {\n    return false;\n  }\n  return info;\n};\n\n/**\n * @param {Network=} network\n * @return {Address|boolean} the associated address for this script if possible, or false\n */\nScript.prototype.toAddress = function(network) {\n  var info = this.getAddressInfo();\n  if (!info) {\n    return false;\n  }\n  info.network = Networks.get(network) || this._network || Networks.defaultNetwork;\n  return new Address(info);\n};\n\n/**\n * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks,\n * typically used with push data chunks.  Note that this will find and delete\n * not just the same data, but the same data with the same push data op as\n * produced by default. i.e., if a pushdata in a tx does not use the minimal\n * pushdata op, then when you try to remove the data it is pushing, it will not\n * be removed, because they do not use the same pushdata op.\n */\nScript.prototype.findAndDelete = function(script) {\n  var buf = script.toBuffer();\n  var hex = buf.toString('hex');\n  for (var i = 0; i < this.chunks.length; i++) {\n    var script2 = Script({\n      chunks: [this.chunks[i]]\n    });\n    var buf2 = script2.toBuffer();\n    var hex2 = buf2.toString('hex');\n    if (hex === hex2) {\n      this.chunks.splice(i, 1);\n    }\n  }\n  return this;\n};\n\n/**\n * Comes from bitcoind's script interpreter CheckMinimalPush function\n * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.\n */\nScript.prototype.checkMinimalPush = function(i) {\n  var chunk = this.chunks[i];\n  var buf = chunk.buf;\n  var opcodenum = chunk.opcodenum;\n  if (!buf) {\n    return true;\n  }\n  if (buf.length === 0) {\n    // Could have used OP_0.\n    return opcodenum === Opcode.OP_0;\n  } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {\n    // Could have used OP_1 .. OP_16.\n    return opcodenum === Opcode.OP_1 + (buf[0] - 1);\n  } else if (buf.length === 1 && buf[0] === 0x81) {\n    // Could have used OP_1NEGATE\n    return opcodenum === Opcode.OP_1NEGATE;\n  } else if (buf.length <= 75) {\n    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).\n    return opcodenum === buf.length;\n  } else if (buf.length <= 255) {\n    // Could have used OP_PUSHDATA.\n    return opcodenum === Opcode.OP_PUSHDATA1;\n  } else if (buf.length <= 65535) {\n    // Could have used OP_PUSHDATA2.\n    return opcodenum === Opcode.OP_PUSHDATA2;\n  }\n  return true;\n};\n\n/**\n * Comes from bitcoind's script DecodeOP_N function\n * @param {number} opcode\n * @returns {number} numeric value in range of 0 to 16\n */\nScript.prototype._decodeOP_N = function(opcode) {\n  if (opcode === Opcode.OP_0) {\n    return 0;\n  } else if (opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16) {\n    return opcode - (Opcode.OP_1 - 1);\n  } else {\n    throw new Error('Invalid opcode: ' + JSON.stringify(opcode));\n  }\n};\n\n/**\n * Comes from bitcoind's script GetSigOpCount(boolean) function\n * @param {boolean} use current (true) or pre-version-0.6 (false) logic\n * @returns {number} number of signature operations required by this script\n */\nScript.prototype.getSignatureOperationsCount = function(accurate) {\n  accurate = (_.isUndefined(accurate) ? true : accurate);\n  var self = this;\n  var n = 0;\n  var lastOpcode = Opcode.OP_INVALIDOPCODE;\n  _.each(self.chunks, function getChunk(chunk) {\n    var opcode = chunk.opcodenum;\n    if (opcode == Opcode.OP_CHECKSIG || opcode == Opcode.OP_CHECKSIGVERIFY) {\n      n++;\n    } else if (opcode == Opcode.OP_CHECKMULTISIG || opcode == Opcode.OP_CHECKMULTISIGVERIFY) {\n      if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {\n        n += self._decodeOP_N(lastOpcode);\n      } else {\n        n += 20;\n      }\n    }\n    lastOpcode = opcode;\n  });\n  return n;\n};\n\nmodule.exports = Script;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}