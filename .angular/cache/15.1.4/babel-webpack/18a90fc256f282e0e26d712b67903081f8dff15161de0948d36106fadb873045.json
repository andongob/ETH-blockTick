{"ast":null,"code":"'use strict';\n\nvar BN = require('./crypto/bn');\nvar Point = require('./crypto/point');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar Network = require('./networks');\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\nfunction PublicKey(data, extra) {\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n  $.checkArgument(data, 'First argument is required, please include public key data.');\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n  extra = extra || {};\n  var info = this._classifyArgs(data, extra);\n\n  // validation\n  info.point.validate();\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Network.defaultNetwork\n  });\n  return this;\n}\n;\n\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\nPublicKey.prototype._classifyArgs = function (data, extra) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  };\n\n  // detect type of data\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof data === 'string') {\n    info = PublicKey._transformDER(Buffer.from(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);\n  }\n  return info;\n};\n\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isPrivateKey = function (param) {\n  var PrivateKey = require('./privatekey');\n  return param instanceof PrivateKey;\n};\n\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isBuffer = function (param) {\n  return param instanceof Buffer || param instanceof Uint8Array;\n};\n\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformPrivateKey = function (privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformDER = function (buf, strict) {\n  /* jshint maxstatements: 30 */\n  /* jshint maxcomplexity: 12 */\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n  strict = _.isUndefined(strict) ? true : strict;\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n  if (buf[0] === 0x04 || !strict && (buf[0] === 0x06 || buf[0] === 0x07)) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n  return info;\n};\n\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformX = function (odd, x) {\n  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformObject = function (json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPrivateKey = function (privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = PublicKey._transformPrivateKey(privkey);\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromDER = PublicKey.fromBuffer = function (buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = PublicKey._transformDER(buf, strict);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPoint = function (point, compressed) {\n  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed: compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromString = function (str, encoding) {\n  var buf = Buffer.from(str, encoding || 'hex');\n  var info = PublicKey._transformDER(buf);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromX = function (odd, x) {\n  var info = PublicKey._transformX(odd, x);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\nPublicKey.getValidationError = function (data) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\nPublicKey.isValid = function (data) {\n  return !PublicKey.getValidationError(data);\n};\n\n/**\n * @returns {Object} A plain object of the PublicKey\n */\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function () {\n  var x = this.point.getX();\n  var y = this.point.getY();\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n  var prefix;\n  if (!this.compressed) {\n    prefix = Buffer.from([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  } else {\n    var odd = ybuf[ybuf.length - 1] % 2;\n    if (odd) {\n      prefix = Buffer.from([0x03]);\n    } else {\n      prefix = Buffer.from([0x02]);\n    }\n    return Buffer.concat([prefix, xbuf]);\n  }\n};\n\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Address} An address generated from the public key\n */\nPublicKey.prototype.toAddress = function (network, type) {\n  var Address = require('./address');\n  return Address.fromPublicKey(this, network || this.network, type);\n};\n\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\nPublicKey.prototype.toString = function () {\n  return this.toDER().toString('hex');\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\nPublicKey.prototype.inspect = function () {\n  return '<PublicKey: ' + this.toString() + (this.compressed ? '' : ', uncompressed') + '>';\n};\nmodule.exports = PublicKey;","map":{"version":3,"names":["BN","require","Point","Hash","JSUtil","Network","_","$","PublicKey","data","extra","checkArgument","info","_classifyArgs","point","validate","defineImmutable","compressed","network","defaultNetwork","prototype","isUndefined","x","y","_transformObject","_transformDER","Buffer","from","_isBuffer","_isPrivateKey","_transformPrivateKey","TypeError","undefined","get","param","PrivateKey","Uint8Array","privkey","getG","mul","bn","buf","strict","xbuf","ybuf","slice","length","_transformX","odd","fromX","json","fromPrivateKey","fromDER","fromBuffer","fromPoint","fromString","str","encoding","getValidationError","error","e","isValid","toObject","toJSON","getX","toString","getY","toBuffer","toDER","size","prefix","concat","_getID","sha256ripemd160","toAddress","type","Address","fromPublicKey","inspect","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/bitcore-lib/lib/publickey.js"],"sourcesContent":["'use strict';\n\nvar BN = require('./crypto/bn');\nvar Point = require('./crypto/point');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar Network = require('./networks');\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\nfunction PublicKey(data, extra) {\n\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n\n  $.checkArgument(data, 'First argument is required, please include public key data.');\n\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n  extra = extra || {};\n\n  var info = this._classifyArgs(data, extra);\n\n  // validation\n  info.point.validate();\n\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Network.defaultNetwork\n  });\n\n  return this;\n};\n\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\nPublicKey.prototype._classifyArgs = function(data, extra) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  };\n\n  // detect type of data\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof(data) === 'string') {\n    info = PublicKey._transformDER(Buffer.from(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);\n  }\n  return info;\n};\n\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isPrivateKey = function(param) {\n  var PrivateKey = require('./privatekey');\n  return param instanceof PrivateKey;\n};\n\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isBuffer = function(param) {\n  return (param instanceof Buffer) || (param instanceof Uint8Array);\n};\n\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformDER = function(buf, strict) {\n  /* jshint maxstatements: 30 */\n  /* jshint maxcomplexity: 12 */\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n\n  strict = _.isUndefined(strict) ? true : strict;\n\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n\n  if (buf[0] === 0x04 || (!strict && (buf[0] === 0x06 || buf[0] === 0x07))) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n  return info;\n};\n\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformX = function(odd, x) {\n  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformObject = function(json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = PublicKey._transformPrivateKey(privkey);\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromDER = PublicKey.fromBuffer = function(buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = PublicKey._transformDER(buf, strict);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPoint = function(point, compressed) {\n  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed: compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromString = function(str, encoding) {\n  var buf = Buffer.from(str, encoding || 'hex');\n  var info = PublicKey._transformDER(buf);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromX = function(odd, x) {\n  var info = PublicKey._transformX(odd, x);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\nPublicKey.getValidationError = function(data) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\nPublicKey.isValid = function(data) {\n  return !PublicKey.getValidationError(data);\n};\n\n/**\n * @returns {Object} A plain object of the PublicKey\n */\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() {\n  var x = this.point.getX();\n  var y = this.point.getY();\n\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n\n  var prefix;\n  if (!this.compressed) {\n    prefix = Buffer.from([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  } else {\n    var odd = ybuf[ybuf.length - 1] % 2;\n    if (odd) {\n      prefix = Buffer.from([0x03]);\n    } else {\n      prefix = Buffer.from([0x02]);\n    }\n    return Buffer.concat([prefix, xbuf]);\n  }\n};\n\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Address} An address generated from the public key\n */\nPublicKey.prototype.toAddress = function(network, type) {\n  var Address = require('./address');\n  return Address.fromPublicKey(this, network || this.network, type);\n};\n\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\nPublicKey.prototype.toString = function() {\n  return this.toDER().toString('hex');\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\nPublicKey.prototype.inspect = function() {\n  return '<PublicKey: ' + this.toString() +\n    (this.compressed ? '' : ', uncompressed') + '>';\n};\n\n\nmodule.exports = PublicKey;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}