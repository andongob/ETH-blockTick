{"ast":null,"code":"'use strict';\n\nvar bech32 = require('bech32');\n\n/**\r\n * Decode bech32/bech32m string\r\n * @param {String} str String to decode\r\n * @returns {Object} Decoded string info\r\n */\nvar decode = function (str) {\n  if (typeof str !== 'string') {\n    throw new Error('Input should be a string');\n  }\n  var decoded;\n  let fromWords = bech32.bech32.fromWords;\n  let encoding = encodings.BECH32;\n  try {\n    decoded = bech32.bech32.decode(str);\n  } catch (e) {\n    if (e.message.indexOf('Invalid checksum') > -1) {\n      decoded = bech32.bech32m.decode(str);\n      encoding = encodings.BECH32M;\n      fromWords = bech32.bech32m.fromWords;\n    } else {\n      throw e;\n    }\n  }\n  const version = decoded.words[0];\n  if (version >= 1 && encoding !== encodings.BECH32M) {\n    throw new Error('Version 1+ witness address must use Bech32m checksum');\n  }\n  return {\n    prefix: decoded.prefix,\n    data: Buffer.from(fromWords(decoded.words.slice(1))),\n    version\n  };\n};\n\n/**\r\n * Encode using BECH32 encoding\r\n * @param {String} prefix bech32 prefix\r\n * @param {Number} version\r\n * @param {String|Buffer} data \r\n * @param {String|Number} encoding (optional, default=bech32) Valid encodings are 'bech32', 'bech32m', 0, and 1.\r\n * @returns {String} encoded string\r\n */\nvar encode = function (prefix, version, data, encoding) {\n  if (typeof prefix !== 'string') {\n    throw new Error('Prefix should be a string');\n  }\n  if (typeof version !== 'number') {\n    throw new Error('version should be a number');\n  }\n  // convert string to number\n  if (encoding && typeof encoding == 'string') {\n    encoding = encodings[encoding.toUpperCase()] || -1; // fallback to -1 so it throws invalid encoding below\n  }\n\n  if (encoding && !(encoding == encodings.BECH32 || encoding == encodings.BECH32M)) {\n    throw new Error('Invalid encoding specified');\n  }\n  let b32Variety = encoding == encodings.BECH32M ? bech32.bech32m : bech32.bech32;\n  let words = b32Variety.toWords(data);\n  words.unshift(version);\n  return b32Variety.encode(prefix, words);\n};\nconst encodings = {\n  BECH32: 1,\n  BECH32M: 2\n};\nmodule.exports = {\n  decode: decode,\n  encode: encode,\n  encodings\n};","map":{"version":3,"names":["bech32","require","decode","str","Error","decoded","fromWords","encoding","encodings","BECH32","e","message","indexOf","bech32m","BECH32M","version","words","prefix","data","Buffer","from","slice","encode","toUpperCase","b32Variety","toWords","unshift","module","exports"],"sources":["C:/Users/Ndongo/Desktop/noborrar/Ethereum-Blocktick/node_modules/bitcore-lib/lib/encoding/bech32.js"],"sourcesContent":["'use strict';\r\n\r\nvar bech32 = require('bech32');\r\n\r\n/**\r\n * Decode bech32/bech32m string\r\n * @param {String} str String to decode\r\n * @returns {Object} Decoded string info\r\n */\r\nvar decode = function(str) {\r\n  if (typeof str !== 'string') {\r\n    throw new Error('Input should be a string');\r\n  }\r\n\r\n  var decoded;\r\n  let fromWords = bech32.bech32.fromWords;\r\n  let encoding = encodings.BECH32;\r\n  try {\r\n    decoded = bech32.bech32.decode(str);\r\n  } catch (e) {\r\n    if (e.message.indexOf('Invalid checksum') > -1) {\r\n      decoded = bech32.bech32m.decode(str);\r\n      encoding = encodings.BECH32M;\r\n      fromWords = bech32.bech32m.fromWords;\r\n    } else {\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  const version = decoded.words[0];\r\n  if (version >= 1 && encoding !== encodings.BECH32M) {\r\n    throw new Error('Version 1+ witness address must use Bech32m checksum');\r\n  }\r\n\r\n  return {\r\n    prefix: decoded.prefix,\r\n    data: Buffer.from(fromWords(decoded.words.slice(1))),\r\n    version\r\n  };\r\n};\r\n\r\n/**\r\n * Encode using BECH32 encoding\r\n * @param {String} prefix bech32 prefix\r\n * @param {Number} version\r\n * @param {String|Buffer} data \r\n * @param {String|Number} encoding (optional, default=bech32) Valid encodings are 'bech32', 'bech32m', 0, and 1.\r\n * @returns {String} encoded string\r\n */\r\nvar encode = function(prefix, version, data, encoding) {\r\n\tif (typeof prefix !== 'string') {\r\n\t\tthrow new Error('Prefix should be a string');\r\n\t}\r\n\tif (typeof version !== 'number') {\r\n\t\tthrow new Error('version should be a number');\r\n\t}\r\n  // convert string to number\r\n  if (encoding && typeof encoding == 'string') {\r\n    encoding = encodings[encoding.toUpperCase()] || -1; // fallback to -1 so it throws invalid encoding below\r\n  }\r\n  if (encoding && !(encoding == encodings.BECH32 || encoding == encodings.BECH32M)) {\r\n    throw new Error('Invalid encoding specified');\r\n  }\r\n  \r\n  let b32Variety = encoding == encodings.BECH32M ? bech32.bech32m : bech32.bech32;\r\n  let words = b32Variety.toWords(data);\r\n\r\n  words.unshift(version);\r\n\treturn b32Variety.encode(prefix, words);\r\n}\r\n\r\nconst encodings = {\r\n  BECH32: 1,\r\n  BECH32M: 2\r\n}\r\n\r\nmodule.exports = { decode: decode, encode: encode, encodings };\r\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;;AAE9B;AACA;AACA;AACA;AACA;AACA,IAAIC,MAAM,GAAG,UAASC,GAAG,EAAE;EACzB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAC3B,MAAM,IAAIC,KAAK,CAAC,0BAA0B,CAAC;EAC7C;EAEA,IAAIC,OAAO;EACX,IAAIC,SAAS,GAAGN,MAAM,CAACA,MAAM,CAACM,SAAS;EACvC,IAAIC,QAAQ,GAAGC,SAAS,CAACC,MAAM;EAC/B,IAAI;IACFJ,OAAO,GAAGL,MAAM,CAACA,MAAM,CAACE,MAAM,CAACC,GAAG,CAAC;EACrC,CAAC,CAAC,OAAOO,CAAC,EAAE;IACV,IAAIA,CAAC,CAACC,OAAO,CAACC,OAAO,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,EAAE;MAC9CP,OAAO,GAAGL,MAAM,CAACa,OAAO,CAACX,MAAM,CAACC,GAAG,CAAC;MACpCI,QAAQ,GAAGC,SAAS,CAACM,OAAO;MAC5BR,SAAS,GAAGN,MAAM,CAACa,OAAO,CAACP,SAAS;IACtC,CAAC,MAAM;MACL,MAAMI,CAAC;IACT;EACF;EAEA,MAAMK,OAAO,GAAGV,OAAO,CAACW,KAAK,CAAC,CAAC,CAAC;EAChC,IAAID,OAAO,IAAI,CAAC,IAAIR,QAAQ,KAAKC,SAAS,CAACM,OAAO,EAAE;IAClD,MAAM,IAAIV,KAAK,CAAC,sDAAsD,CAAC;EACzE;EAEA,OAAO;IACLa,MAAM,EAAEZ,OAAO,CAACY,MAAM;IACtBC,IAAI,EAAEC,MAAM,CAACC,IAAI,CAACd,SAAS,CAACD,OAAO,CAACW,KAAK,CAACK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IACpDN;EACF,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIO,MAAM,GAAG,UAASL,MAAM,EAAEF,OAAO,EAAEG,IAAI,EAAEX,QAAQ,EAAE;EACtD,IAAI,OAAOU,MAAM,KAAK,QAAQ,EAAE;IAC/B,MAAM,IAAIb,KAAK,CAAC,2BAA2B,CAAC;EAC7C;EACA,IAAI,OAAOW,OAAO,KAAK,QAAQ,EAAE;IAChC,MAAM,IAAIX,KAAK,CAAC,4BAA4B,CAAC;EAC9C;EACC;EACA,IAAIG,QAAQ,IAAI,OAAOA,QAAQ,IAAI,QAAQ,EAAE;IAC3CA,QAAQ,GAAGC,SAAS,CAACD,QAAQ,CAACgB,WAAW,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;EACtD;;EACA,IAAIhB,QAAQ,IAAI,EAAEA,QAAQ,IAAIC,SAAS,CAACC,MAAM,IAAIF,QAAQ,IAAIC,SAAS,CAACM,OAAO,CAAC,EAAE;IAChF,MAAM,IAAIV,KAAK,CAAC,4BAA4B,CAAC;EAC/C;EAEA,IAAIoB,UAAU,GAAGjB,QAAQ,IAAIC,SAAS,CAACM,OAAO,GAAGd,MAAM,CAACa,OAAO,GAAGb,MAAM,CAACA,MAAM;EAC/E,IAAIgB,KAAK,GAAGQ,UAAU,CAACC,OAAO,CAACP,IAAI,CAAC;EAEpCF,KAAK,CAACU,OAAO,CAACX,OAAO,CAAC;EACvB,OAAOS,UAAU,CAACF,MAAM,CAACL,MAAM,EAAED,KAAK,CAAC;AACxC,CAAC;AAED,MAAMR,SAAS,GAAG;EAChBC,MAAM,EAAE,CAAC;EACTK,OAAO,EAAE;AACX,CAAC;AAEDa,MAAM,CAACC,OAAO,GAAG;EAAE1B,MAAM,EAAEA,MAAM;EAAEoB,MAAM,EAAEA,MAAM;EAAEd;AAAU,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}