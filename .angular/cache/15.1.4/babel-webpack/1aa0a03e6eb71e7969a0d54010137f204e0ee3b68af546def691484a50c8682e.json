{"ast":null,"code":"'use strict';\n\nvar BN = require('bn.js');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\nvar reversebuf = function (buf) {\n  var buf2 = Buffer.alloc(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n  return buf2;\n};\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\nBN.fromNumber = function (n) {\n  $.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\nBN.fromString = function (str, base) {\n  $.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\nBN.fromBuffer = function (buf, opts) {\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\nBN.fromSM = function (buf, opts) {\n  var ret;\n  if (buf.length === 0) {\n    return BN.fromBuffer(Buffer.from([0]));\n  }\n  var endian = 'big';\n  if (opts) {\n    endian = opts.endian;\n  }\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n  return ret;\n};\nBN.prototype.toNumber = function () {\n  return parseInt(this.toString(10), 10);\n};\nBN.prototype.toBuffer = function (opts) {\n  var buf, hex;\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = Buffer.from(hex, 'hex');\n    if (natlen === opts.size) {\n      buf = buf;\n    } else if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = Buffer.from(hex, 'hex');\n  }\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  return buf;\n};\nBN.prototype.toSMBigEndian = function () {\n  var buf;\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x80]), buf]);\n    } else {\n      buf[0] = buf[0] | 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x00]), buf]);\n    }\n  }\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = Buffer.from([]);\n  }\n  return buf;\n};\nBN.prototype.toSM = function (opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  return buf;\n};\n\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\nBN.fromScriptNumBuffer = function (buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\nBN.prototype.toScriptNumBuffer = function () {\n  return this.toSM({\n    endian: 'little'\n  });\n};\nBN.trim = function (buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\nBN.pad = function (buf, natlen, size) {\n  var rbuf = Buffer.alloc(size);\n  for (var i = 0; i < buf.length; i++) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n  for (i = 0; i < size - natlen; i++) {\n    rbuf[i] = 0;\n  }\n  return rbuf;\n};\nmodule.exports = BN;","map":{"version":3,"names":["BN","require","$","_","reversebuf","buf","buf2","Buffer","alloc","length","i","Zero","One","Minus1","fromNumber","n","checkArgument","isNumber","fromString","str","base","isString","fromBuffer","opts","endian","hex","toString","bn","fromSM","ret","from","neg","copy","prototype","toNumber","parseInt","toBuffer","size","natlen","trim","pad","toSMBigEndian","cmp","concat","toSM","fromScriptNumBuffer","fRequireMinimal","nMaxNumSize","Error","toScriptNumBuffer","slice","rbuf","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/bitcore-lib/lib/crypto/bn.js"],"sourcesContent":["'use strict';\n\nvar BN = require('bn.js');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\n\nvar reversebuf = function(buf) {\n  var buf2 = Buffer.alloc(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n  return buf2;\n};\n\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\n\nBN.fromNumber = function(n) {\n  $.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\n\nBN.fromString = function(str, base) {\n  $.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\n\nBN.fromBuffer = function(buf, opts) {\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\nBN.fromSM = function(buf, opts) {\n  var ret;\n  if (buf.length === 0) {\n    return BN.fromBuffer(Buffer.from([0]));\n  }\n\n  var endian = 'big';\n  if (opts) {\n    endian = opts.endian;\n  }\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n  return ret;\n};\n\n\nBN.prototype.toNumber = function() {\n  return parseInt(this.toString(10), 10);\n};\n\nBN.prototype.toBuffer = function(opts) {\n  var buf, hex;\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = Buffer.from(hex, 'hex');\n\n    if (natlen === opts.size) {\n      buf = buf;\n    } else if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = Buffer.from(hex, 'hex');\n  }\n\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSMBigEndian = function() {\n  var buf;\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x80]), buf]);\n    } else {\n      buf[0] = buf[0] | 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x00]), buf]);\n    }\n  }\n\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = Buffer.from([]);\n  }\n  return buf;\n};\n\nBN.prototype.toSM = function(opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  return buf;\n};\n\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\nBN.fromScriptNumBuffer = function(buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\nBN.prototype.toScriptNumBuffer = function() {\n  return this.toSM({\n    endian: 'little'\n  });\n};\n\nBN.trim = function(buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\n\nBN.pad = function(buf, natlen, size) {\n  var rbuf = Buffer.alloc(size);\n  for (var i = 0; i < buf.length; i++) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n  for (i = 0; i < size - natlen; i++) {\n    rbuf[i] = 0;\n  }\n  return rbuf;\n};\n\nmodule.exports = BN;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}