{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;\nvar secp256k1 = require('ethereum-cryptography/secp256k1');\nvar secp256k1v3 = require('./secp256k1v3-lib/index');\nvar der = require('./secp256k1v3-lib/der');\n/**\r\n * Verify an ECDSA privateKey\r\n * @method privateKeyVerify\r\n * @param {Buffer} privateKey\r\n * @return {boolean}\r\n */\nexports.privateKeyVerify = function (privateKey) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    return false;\n  }\n  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\n};\n/**\r\n * Export a privateKey in DER format\r\n * @method privateKeyExport\r\n * @param {Buffer} privateKey\r\n * @param {boolean} compressed\r\n * @return {boolean}\r\n */\nexports.privateKeyExport = function (privateKey, compressed) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\n  return der.privateKeyExport(privateKey, publicKey, compressed);\n};\n/**\r\n * Import a privateKey in DER format\r\n * @method privateKeyImport\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\nexports.privateKeyImport = function (privateKey) {\n  // privateKeyImport method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  privateKey = der.privateKeyImport(privateKey);\n  if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {\n    return privateKey;\n  }\n  throw new Error(\"couldn't import from DER format\");\n};\n/**\r\n * Negate a privateKey by subtracting it from the order of the curve's base point\r\n * @method privateKeyNegate\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\nexports.privateKeyNegate = function (privateKey) {\n  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\n};\n/**\r\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\r\n * @method privateKeyModInverse\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\nexports.privateKeyModInverse = function (privateKey) {\n  if (privateKey.length !== 32) {\n    throw new Error('private key length is invalid');\n  }\n  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\n};\n/**\r\n * Tweak a privateKey by adding tweak to it.\r\n * @method privateKeyTweakAdd\r\n * @param {Buffer} privateKey\r\n * @param {Buffer} tweak\r\n * @return {Buffer}\r\n */\nexports.privateKeyTweakAdd = function (privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\n};\n/**\r\n * Tweak a privateKey by multiplying it by a tweak.\r\n * @method privateKeyTweakMul\r\n * @param {Buffer} privateKey\r\n * @param {Buffer} tweak\r\n * @return {Buffer}\r\n */\nexports.privateKeyTweakMul = function (privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\n};\n/**\r\n * Compute the public key for a privateKey.\r\n * @method publicKeyCreate\r\n * @param {Buffer} privateKey\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\nexports.publicKeyCreate = function (privateKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\n};\n/**\r\n * Convert a publicKey to compressed or uncompressed form.\r\n * @method publicKeyConvert\r\n * @param {Buffer} publicKey\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\nexports.publicKeyConvert = function (publicKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\n};\n/**\r\n * Verify an ECDSA publicKey.\r\n * @method publicKeyVerify\r\n * @param {Buffer} publicKey\r\n * @return {boolean}\r\n */\nexports.publicKeyVerify = function (publicKey) {\n  // secp256k1 v4 version throws when publicKey length is not 33 or 65\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    return false;\n  }\n  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\n};\n/**\r\n * Tweak a publicKey by adding tweak times the generator to it.\r\n * @method publicKeyTweakAdd\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} tweak\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\nexports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\r\n * Tweak a publicKey by multiplying it by a tweak value\r\n * @method publicKeyTweakMul\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} tweak\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\nexports.publicKeyTweakMul = function (publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\r\n * Add a given publicKeys together.\r\n * @method publicKeyCombine\r\n * @param {Array<Buffer>} publicKeys\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\nexports.publicKeyCombine = function (publicKeys, compressed) {\n  var keys = [];\n  publicKeys.forEach(function (publicKey) {\n    keys.push(Uint8Array.from(publicKey));\n  });\n  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\n};\n/**\r\n * Convert a signature to a normalized lower-S form.\r\n * @method signatureNormalize\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\nexports.signatureNormalize = function (signature) {\n  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\n};\n/**\r\n * Serialize an ECDSA signature in DER format.\r\n * @method signatureExport\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\nexports.signatureExport = function (signature) {\n  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\n};\n/**\r\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\r\n * @method signatureImport\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\nexports.signatureImport = function (signature) {\n  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\n};\n/**\r\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\r\n * @method signatureImportLax\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\nexports.signatureImportLax = function (signature) {\n  // signatureImportLax method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure that signature is greater than 0\n  if (signature.length === 0) {\n    throw new RangeError('signature length is invalid');\n  }\n  var sigObj = der.signatureImportLax(signature);\n  if (sigObj === null) {\n    throw new Error(\"couldn't parse DER signature\");\n  }\n  return secp256k1v3.signatureImport(sigObj);\n};\n/**\r\n * Create an ECDSA signature. Always return low-S signature.\r\n * @method sign\r\n * @param {Buffer} message\r\n * @param {Buffer} privateKey\r\n * @param {Object} options\r\n * @return {Buffer}\r\n */\nexports.sign = function (message, privateKey, options) {\n  if (options === null) {\n    throw new TypeError('options should be an Object');\n  }\n  var signOptions = undefined;\n  if (options) {\n    signOptions = {};\n    if (options.data === null) {\n      // validate option.data length\n      throw new TypeError('options.data should be a Buffer');\n    }\n    if (options.data) {\n      if (options.data.length != 32) {\n        throw new RangeError('options.data length is invalid');\n      }\n      signOptions.data = new Uint8Array(options.data);\n    }\n    if (options.noncefn === null) {\n      throw new TypeError('options.noncefn should be a Function');\n    }\n    if (options.noncefn) {\n      // convert option.noncefn function signature\n      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {\n        var bufferAlgo = algo != null ? Buffer.from(algo) : null;\n        var bufferData = data != null ? Buffer.from(data) : null;\n        var buffer = Buffer.from('');\n        if (options.noncefn) {\n          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\n        }\n        return new Uint8Array(buffer);\n      };\n    }\n  }\n  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\n  return {\n    signature: Buffer.from(sig.signature),\n    recovery: sig.recid\n  };\n};\n/**\r\n * Verify an ECDSA signature.\r\n * @method verify\r\n * @param {Buffer} message\r\n * @param {Buffer} signature\r\n * @param {Buffer} publicKey\r\n * @return {boolean}\r\n */\nexports.verify = function (message, signature, publicKey) {\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\n};\n/**\r\n * Recover an ECDSA public key from a signature.\r\n * @method recover\r\n * @param {Buffer} message\r\n * @param {Buffer} signature\r\n * @param {Number} recid\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\nexports.recover = function (message, signature, recid, compressed) {\n  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\n};\n/**\r\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\r\n * @method ecdh\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\nexports.ecdh = function (publicKey, privateKey) {\n  // note: secp256k1 v3 doesn't allow optional parameter\n  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\n};\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n  // ecdhUnsafe method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure valid publicKey length\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    throw new RangeError('public key length is invalid');\n  }\n  // ensure valid privateKey length\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","ecdhUnsafe","ecdh","recover","verify","sign","signatureImportLax","signatureImport","signatureExport","signatureNormalize","publicKeyCombine","publicKeyTweakMul","publicKeyTweakAdd","publicKeyVerify","publicKeyConvert","publicKeyCreate","privateKeyTweakMul","privateKeyTweakAdd","privateKeyModInverse","privateKeyNegate","privateKeyImport","privateKeyExport","privateKeyVerify","secp256k1","require","secp256k1v3","der","privateKey","length","Uint8Array","from","compressed","RangeError","publicKey","Error","Buffer","tweak","publicKeys","keys","forEach","push","signature","sigObj","message","options","TypeError","signOptions","undefined","data","noncefn","algo","attempt","bufferAlgo","bufferData","buffer","sig","ecdsaSign","recovery","recid","ecdsaVerify","ecdsaRecover"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;\r\nvar secp256k1 = require('ethereum-cryptography/secp256k1');\r\nvar secp256k1v3 = require('./secp256k1v3-lib/index');\r\nvar der = require('./secp256k1v3-lib/der');\r\n/**\r\n * Verify an ECDSA privateKey\r\n * @method privateKeyVerify\r\n * @param {Buffer} privateKey\r\n * @return {boolean}\r\n */\r\nexports.privateKeyVerify = function (privateKey) {\r\n    // secp256k1 v4 version throws when privateKey length is not 32\r\n    if (privateKey.length !== 32) {\r\n        return false;\r\n    }\r\n    return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\r\n};\r\n/**\r\n * Export a privateKey in DER format\r\n * @method privateKeyExport\r\n * @param {Buffer} privateKey\r\n * @param {boolean} compressed\r\n * @return {boolean}\r\n */\r\nexports.privateKeyExport = function (privateKey, compressed) {\r\n    // secp256k1 v4 version throws when privateKey length is not 32\r\n    if (privateKey.length !== 32) {\r\n        throw new RangeError('private key length is invalid');\r\n    }\r\n    var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\r\n    return der.privateKeyExport(privateKey, publicKey, compressed);\r\n};\r\n/**\r\n * Import a privateKey in DER format\r\n * @method privateKeyImport\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\r\nexports.privateKeyImport = function (privateKey) {\r\n    // privateKeyImport method is not part of secp256k1 v4 package\r\n    // this implementation is based on v3\r\n    privateKey = der.privateKeyImport(privateKey);\r\n    if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {\r\n        return privateKey;\r\n    }\r\n    throw new Error(\"couldn't import from DER format\");\r\n};\r\n/**\r\n * Negate a privateKey by subtracting it from the order of the curve's base point\r\n * @method privateKeyNegate\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\r\nexports.privateKeyNegate = function (privateKey) {\r\n    return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\r\n};\r\n/**\r\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\r\n * @method privateKeyModInverse\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\r\nexports.privateKeyModInverse = function (privateKey) {\r\n    if (privateKey.length !== 32) {\r\n        throw new Error('private key length is invalid');\r\n    }\r\n    return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\r\n};\r\n/**\r\n * Tweak a privateKey by adding tweak to it.\r\n * @method privateKeyTweakAdd\r\n * @param {Buffer} privateKey\r\n * @param {Buffer} tweak\r\n * @return {Buffer}\r\n */\r\nexports.privateKeyTweakAdd = function (privateKey, tweak) {\r\n    return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\r\n};\r\n/**\r\n * Tweak a privateKey by multiplying it by a tweak.\r\n * @method privateKeyTweakMul\r\n * @param {Buffer} privateKey\r\n * @param {Buffer} tweak\r\n * @return {Buffer}\r\n */\r\nexports.privateKeyTweakMul = function (privateKey, tweak) {\r\n    return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\r\n};\r\n/**\r\n * Compute the public key for a privateKey.\r\n * @method publicKeyCreate\r\n * @param {Buffer} privateKey\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\r\nexports.publicKeyCreate = function (privateKey, compressed) {\r\n    return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\r\n};\r\n/**\r\n * Convert a publicKey to compressed or uncompressed form.\r\n * @method publicKeyConvert\r\n * @param {Buffer} publicKey\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\r\nexports.publicKeyConvert = function (publicKey, compressed) {\r\n    return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\r\n};\r\n/**\r\n * Verify an ECDSA publicKey.\r\n * @method publicKeyVerify\r\n * @param {Buffer} publicKey\r\n * @return {boolean}\r\n */\r\nexports.publicKeyVerify = function (publicKey) {\r\n    // secp256k1 v4 version throws when publicKey length is not 33 or 65\r\n    if (publicKey.length !== 33 && publicKey.length !== 65) {\r\n        return false;\r\n    }\r\n    return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\r\n};\r\n/**\r\n * Tweak a publicKey by adding tweak times the generator to it.\r\n * @method publicKeyTweakAdd\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} tweak\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\r\nexports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {\r\n    return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\r\n};\r\n/**\r\n * Tweak a publicKey by multiplying it by a tweak value\r\n * @method publicKeyTweakMul\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} tweak\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\r\nexports.publicKeyTweakMul = function (publicKey, tweak, compressed) {\r\n    return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\r\n};\r\n/**\r\n * Add a given publicKeys together.\r\n * @method publicKeyCombine\r\n * @param {Array<Buffer>} publicKeys\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\r\nexports.publicKeyCombine = function (publicKeys, compressed) {\r\n    var keys = [];\r\n    publicKeys.forEach(function (publicKey) {\r\n        keys.push(Uint8Array.from(publicKey));\r\n    });\r\n    return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\r\n};\r\n/**\r\n * Convert a signature to a normalized lower-S form.\r\n * @method signatureNormalize\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\r\nexports.signatureNormalize = function (signature) {\r\n    return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\r\n};\r\n/**\r\n * Serialize an ECDSA signature in DER format.\r\n * @method signatureExport\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\r\nexports.signatureExport = function (signature) {\r\n    return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\r\n};\r\n/**\r\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\r\n * @method signatureImport\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\r\nexports.signatureImport = function (signature) {\r\n    return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\r\n};\r\n/**\r\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\r\n * @method signatureImportLax\r\n * @param {Buffer} signature\r\n * @return {Buffer}\r\n */\r\nexports.signatureImportLax = function (signature) {\r\n    // signatureImportLax method is not part of secp256k1 v4 package\r\n    // this implementation is based on v3\r\n    // ensure that signature is greater than 0\r\n    if (signature.length === 0) {\r\n        throw new RangeError('signature length is invalid');\r\n    }\r\n    var sigObj = der.signatureImportLax(signature);\r\n    if (sigObj === null) {\r\n        throw new Error(\"couldn't parse DER signature\");\r\n    }\r\n    return secp256k1v3.signatureImport(sigObj);\r\n};\r\n/**\r\n * Create an ECDSA signature. Always return low-S signature.\r\n * @method sign\r\n * @param {Buffer} message\r\n * @param {Buffer} privateKey\r\n * @param {Object} options\r\n * @return {Buffer}\r\n */\r\nexports.sign = function (message, privateKey, options) {\r\n    if (options === null) {\r\n        throw new TypeError('options should be an Object');\r\n    }\r\n    var signOptions = undefined;\r\n    if (options) {\r\n        signOptions = {};\r\n        if (options.data === null) {\r\n            // validate option.data length\r\n            throw new TypeError('options.data should be a Buffer');\r\n        }\r\n        if (options.data) {\r\n            if (options.data.length != 32) {\r\n                throw new RangeError('options.data length is invalid');\r\n            }\r\n            signOptions.data = new Uint8Array(options.data);\r\n        }\r\n        if (options.noncefn === null) {\r\n            throw new TypeError('options.noncefn should be a Function');\r\n        }\r\n        if (options.noncefn) {\r\n            // convert option.noncefn function signature\r\n            signOptions.noncefn = function (message, privateKey, algo, data, attempt) {\r\n                var bufferAlgo = algo != null ? Buffer.from(algo) : null;\r\n                var bufferData = data != null ? Buffer.from(data) : null;\r\n                var buffer = Buffer.from('');\r\n                if (options.noncefn) {\r\n                    buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\r\n                }\r\n                return new Uint8Array(buffer);\r\n            };\r\n        }\r\n    }\r\n    var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\r\n    return {\r\n        signature: Buffer.from(sig.signature),\r\n        recovery: sig.recid,\r\n    };\r\n};\r\n/**\r\n * Verify an ECDSA signature.\r\n * @method verify\r\n * @param {Buffer} message\r\n * @param {Buffer} signature\r\n * @param {Buffer} publicKey\r\n * @return {boolean}\r\n */\r\nexports.verify = function (message, signature, publicKey) {\r\n    return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\r\n};\r\n/**\r\n * Recover an ECDSA public key from a signature.\r\n * @method recover\r\n * @param {Buffer} message\r\n * @param {Buffer} signature\r\n * @param {Number} recid\r\n * @param {boolean} compressed\r\n * @return {Buffer}\r\n */\r\nexports.recover = function (message, signature, recid, compressed) {\r\n    return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\r\n};\r\n/**\r\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\r\n * @method ecdh\r\n * @param {Buffer} publicKey\r\n * @param {Buffer} privateKey\r\n * @return {Buffer}\r\n */\r\nexports.ecdh = function (publicKey, privateKey) {\r\n    // note: secp256k1 v3 doesn't allow optional parameter\r\n    return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\r\n};\r\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\r\n    // ecdhUnsafe method is not part of secp256k1 v4 package\r\n    // this implementation is based on v3\r\n    // ensure valid publicKey length\r\n    if (publicKey.length !== 33 && publicKey.length !== 65) {\r\n        throw new RangeError('public key length is invalid');\r\n    }\r\n    // ensure valid privateKey length\r\n    if (privateKey.length !== 32) {\r\n        throw new RangeError('private key length is invalid');\r\n    }\r\n    return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}