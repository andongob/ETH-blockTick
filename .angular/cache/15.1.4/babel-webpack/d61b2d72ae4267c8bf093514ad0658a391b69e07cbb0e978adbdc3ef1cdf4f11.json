{"ast":null,"code":"\"use strict\";\n\n// This file is imported from secp256k1 v3\n// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BN = require(\"bn.js\");\nvar EC = require('elliptic').ec;\nvar ec = new EC('secp256k1');\nvar ecparams = ec.curve;\nexports.privateKeyExport = function (privateKey, compressed) {\n  if (compressed === void 0) {\n    compressed = true;\n  }\n  var d = new BN(privateKey);\n  if (d.ucmp(ecparams.n) >= 0) {\n    throw new Error(\"couldn't export to DER format\");\n  }\n  var point = ec.g.mul(d);\n  return toPublicKey(point.getX(), point.getY(), compressed);\n};\nexports.privateKeyModInverse = function (privateKey) {\n  var bn = new BN(privateKey);\n  if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {\n    throw new Error('private key range is invalid');\n  }\n  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);\n};\nexports.signatureImport = function (sigObj) {\n  var r = new BN(sigObj.r);\n  if (r.ucmp(ecparams.n) >= 0) {\n    r = new BN(0);\n  }\n  var s = new BN(sigObj.s);\n  if (s.ucmp(ecparams.n) >= 0) {\n    s = new BN(0);\n  }\n  return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);\n};\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n  if (compressed === void 0) {\n    compressed = true;\n  }\n  var point = ec.keyFromPublic(publicKey);\n  var scalar = new BN(privateKey);\n  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {\n    throw new Error('scalar was invalid (zero or overflow)');\n  }\n  var shared = point.pub.mul(scalar);\n  return toPublicKey(shared.getX(), shared.getY(), compressed);\n};\nvar toPublicKey = function (x, y, compressed) {\n  var publicKey;\n  if (compressed) {\n    publicKey = Buffer.alloc(33);\n    publicKey[0] = y.isOdd() ? 0x03 : 0x02;\n    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n  } else {\n    publicKey = Buffer.alloc(65);\n    publicKey[0] = 0x04;\n    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n    y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);\n  }\n  return publicKey;\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","BN","require","EC","ec","ecparams","curve","privateKeyExport","privateKey","compressed","d","ucmp","n","Error","point","g","mul","toPublicKey","getX","getY","privateKeyModInverse","bn","isZero","invm","toArrayLike","Buffer","signatureImport","sigObj","r","s","concat","ecdhUnsafe","publicKey","keyFromPublic","scalar","shared","pub","x","y","alloc","isOdd","copy"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js"],"sourcesContent":["\"use strict\";\r\n// This file is imported from secp256k1 v3\r\n// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar BN = require(\"bn.js\");\r\nvar EC = require('elliptic').ec;\r\nvar ec = new EC('secp256k1');\r\nvar ecparams = ec.curve;\r\nexports.privateKeyExport = function (privateKey, compressed) {\r\n    if (compressed === void 0) { compressed = true; }\r\n    var d = new BN(privateKey);\r\n    if (d.ucmp(ecparams.n) >= 0) {\r\n        throw new Error(\"couldn't export to DER format\");\r\n    }\r\n    var point = ec.g.mul(d);\r\n    return toPublicKey(point.getX(), point.getY(), compressed);\r\n};\r\nexports.privateKeyModInverse = function (privateKey) {\r\n    var bn = new BN(privateKey);\r\n    if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {\r\n        throw new Error('private key range is invalid');\r\n    }\r\n    return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);\r\n};\r\nexports.signatureImport = function (sigObj) {\r\n    var r = new BN(sigObj.r);\r\n    if (r.ucmp(ecparams.n) >= 0) {\r\n        r = new BN(0);\r\n    }\r\n    var s = new BN(sigObj.s);\r\n    if (s.ucmp(ecparams.n) >= 0) {\r\n        s = new BN(0);\r\n    }\r\n    return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);\r\n};\r\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\r\n    if (compressed === void 0) { compressed = true; }\r\n    var point = ec.keyFromPublic(publicKey);\r\n    var scalar = new BN(privateKey);\r\n    if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {\r\n        throw new Error('scalar was invalid (zero or overflow)');\r\n    }\r\n    var shared = point.pub.mul(scalar);\r\n    return toPublicKey(shared.getX(), shared.getY(), compressed);\r\n};\r\nvar toPublicKey = function (x, y, compressed) {\r\n    var publicKey;\r\n    if (compressed) {\r\n        publicKey = Buffer.alloc(33);\r\n        publicKey[0] = y.isOdd() ? 0x03 : 0x02;\r\n        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\r\n    }\r\n    else {\r\n        publicKey = Buffer.alloc(65);\r\n        publicKey[0] = 0x04;\r\n        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\r\n        y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);\r\n    }\r\n    return publicKey;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}