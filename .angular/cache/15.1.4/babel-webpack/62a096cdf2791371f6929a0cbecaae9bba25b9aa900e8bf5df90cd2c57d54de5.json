{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defineProperties = void 0;\nvar assert = require('assert');\nvar ethjsUtil = require('ethjs-util');\nvar rlp = require(\"rlp\");\nvar bytes_1 = require(\"./bytes\");\n/**\r\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\r\n * @param self the `Object` to define properties on\r\n * @param fields an array fields to define. Fields can contain:\r\n * * `name` - the name of the properties\r\n * * `length` - the number of bytes the field can have\r\n * * `allowLess` - if the field can be less than the length\r\n * * `allowEmpty`\r\n * @param data data to be validated against the definitions\r\n * @deprecated\r\n */\nexports.defineProperties = function (self, fields, data) {\n  self.raw = [];\n  self._fields = [];\n  // attach the `toJSON`\n  self.toJSON = function (label) {\n    if (label === void 0) {\n      label = false;\n    }\n    if (label) {\n      var obj_1 = {};\n      self._fields.forEach(function (field) {\n        obj_1[field] = \"0x\" + self[field].toString('hex');\n      });\n      return obj_1;\n    }\n    return bytes_1.baToJSON(self.raw);\n  };\n  self.serialize = function serialize() {\n    return rlp.encode(self.raw);\n  };\n  fields.forEach(function (field, i) {\n    self._fields.push(field.name);\n    function getter() {\n      return self.raw[i];\n    }\n    function setter(v) {\n      v = bytes_1.toBuffer(v);\n      if (v.toString('hex') === '00' && !field.allowZero) {\n        v = Buffer.allocUnsafe(0);\n      }\n      if (field.allowLess && field.length) {\n        v = bytes_1.stripZeros(v);\n        assert(field.length >= v.length, \"The field \" + field.name + \" must not have more \" + field.length + \" bytes\");\n      } else if (!(field.allowZero && v.length === 0) && field.length) {\n        assert(field.length === v.length, \"The field \" + field.name + \" must have byte length of \" + field.length);\n      }\n      self.raw[i] = v;\n    }\n    Object.defineProperty(self, field.name, {\n      enumerable: true,\n      configurable: true,\n      get: getter,\n      set: setter\n    });\n    if (field.default) {\n      self[field.name] = field.default;\n    }\n    // attach alias\n    if (field.alias) {\n      Object.defineProperty(self, field.alias, {\n        enumerable: false,\n        configurable: true,\n        set: setter,\n        get: getter\n      });\n    }\n  });\n  // if the constuctor is passed data\n  if (data) {\n    if (typeof data === 'string') {\n      data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');\n    }\n    if (Buffer.isBuffer(data)) {\n      data = rlp.decode(data);\n    }\n    if (Array.isArray(data)) {\n      if (data.length > self._fields.length) {\n        throw new Error('wrong number of fields in data');\n      }\n      // make sure all the items are buffers\n      data.forEach(function (d, i) {\n        self[self._fields[i]] = bytes_1.toBuffer(d);\n      });\n    } else if (typeof data === 'object') {\n      var keys_1 = Object.keys(data);\n      fields.forEach(function (field) {\n        if (keys_1.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n        if (keys_1.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n      });\n    } else {\n      throw new Error('invalid data');\n    }\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","defineProperties","assert","require","ethjsUtil","rlp","bytes_1","self","fields","data","raw","_fields","toJSON","label","obj_1","forEach","field","toString","baToJSON","serialize","encode","i","push","name","getter","setter","v","toBuffer","allowZero","Buffer","allocUnsafe","allowLess","length","stripZeros","enumerable","configurable","get","set","default","alias","from","stripHexPrefix","isBuffer","decode","Array","isArray","Error","d","keys_1","keys","indexOf"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/object.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.defineProperties = void 0;\r\nvar assert = require('assert');\r\nvar ethjsUtil = require('ethjs-util');\r\nvar rlp = require(\"rlp\");\r\nvar bytes_1 = require(\"./bytes\");\r\n/**\r\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\r\n * @param self the `Object` to define properties on\r\n * @param fields an array fields to define. Fields can contain:\r\n * * `name` - the name of the properties\r\n * * `length` - the number of bytes the field can have\r\n * * `allowLess` - if the field can be less than the length\r\n * * `allowEmpty`\r\n * @param data data to be validated against the definitions\r\n * @deprecated\r\n */\r\nexports.defineProperties = function (self, fields, data) {\r\n    self.raw = [];\r\n    self._fields = [];\r\n    // attach the `toJSON`\r\n    self.toJSON = function (label) {\r\n        if (label === void 0) { label = false; }\r\n        if (label) {\r\n            var obj_1 = {};\r\n            self._fields.forEach(function (field) {\r\n                obj_1[field] = \"0x\" + self[field].toString('hex');\r\n            });\r\n            return obj_1;\r\n        }\r\n        return bytes_1.baToJSON(self.raw);\r\n    };\r\n    self.serialize = function serialize() {\r\n        return rlp.encode(self.raw);\r\n    };\r\n    fields.forEach(function (field, i) {\r\n        self._fields.push(field.name);\r\n        function getter() {\r\n            return self.raw[i];\r\n        }\r\n        function setter(v) {\r\n            v = bytes_1.toBuffer(v);\r\n            if (v.toString('hex') === '00' && !field.allowZero) {\r\n                v = Buffer.allocUnsafe(0);\r\n            }\r\n            if (field.allowLess && field.length) {\r\n                v = bytes_1.stripZeros(v);\r\n                assert(field.length >= v.length, \"The field \" + field.name + \" must not have more \" + field.length + \" bytes\");\r\n            }\r\n            else if (!(field.allowZero && v.length === 0) && field.length) {\r\n                assert(field.length === v.length, \"The field \" + field.name + \" must have byte length of \" + field.length);\r\n            }\r\n            self.raw[i] = v;\r\n        }\r\n        Object.defineProperty(self, field.name, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: getter,\r\n            set: setter,\r\n        });\r\n        if (field.default) {\r\n            self[field.name] = field.default;\r\n        }\r\n        // attach alias\r\n        if (field.alias) {\r\n            Object.defineProperty(self, field.alias, {\r\n                enumerable: false,\r\n                configurable: true,\r\n                set: setter,\r\n                get: getter,\r\n            });\r\n        }\r\n    });\r\n    // if the constuctor is passed data\r\n    if (data) {\r\n        if (typeof data === 'string') {\r\n            data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');\r\n        }\r\n        if (Buffer.isBuffer(data)) {\r\n            data = rlp.decode(data);\r\n        }\r\n        if (Array.isArray(data)) {\r\n            if (data.length > self._fields.length) {\r\n                throw new Error('wrong number of fields in data');\r\n            }\r\n            // make sure all the items are buffers\r\n            data.forEach(function (d, i) {\r\n                self[self._fields[i]] = bytes_1.toBuffer(d);\r\n            });\r\n        }\r\n        else if (typeof data === 'object') {\r\n            var keys_1 = Object.keys(data);\r\n            fields.forEach(function (field) {\r\n                if (keys_1.indexOf(field.name) !== -1)\r\n                    self[field.name] = data[field.name];\r\n                if (keys_1.indexOf(field.alias) !== -1)\r\n                    self[field.alias] = data[field.alias];\r\n            });\r\n        }\r\n        else {\r\n            throw new Error('invalid data');\r\n        }\r\n    }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}