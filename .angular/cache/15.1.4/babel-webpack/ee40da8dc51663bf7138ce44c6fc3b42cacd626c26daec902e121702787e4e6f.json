{"ast":null,"code":"'use strict';\n\nvar crypto = require(\"crypto\");\n\n/**\n * PDKBF2\n * Credit to: https://github.com/stayradiated/pbkdf2-sha512\n * Copyright (c) 2014, JP Richardson Copyright (c) 2010-2011 Intalio Pte, All Rights Reserved\n */\nfunction pbkdf2(key, salt, iterations, dkLen) {\n  /* jshint maxstatements: 31 */\n  /* jshint maxcomplexity: 9 */\n\n  var hLen = 64; //SHA512 Mac length\n  if (dkLen > (Math.pow(2, 32) - 1) * hLen) {\n    throw Error('Requested key length too long');\n  }\n  if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n    throw new TypeError('key must a string or Buffer');\n  }\n  if (typeof salt !== 'string' && !Buffer.isBuffer(salt)) {\n    throw new TypeError('salt must a string or Buffer');\n  }\n  if (typeof key === 'string') {\n    key = Buffer.from(key);\n  }\n  if (typeof salt === 'string') {\n    salt = Buffer.from(salt);\n  }\n  var DK = Buffer.alloc(dkLen);\n  var U = Buffer.alloc(hLen);\n  var T = Buffer.alloc(hLen);\n  var block1 = Buffer.alloc(salt.length + 4);\n  var l = Math.ceil(dkLen / hLen);\n  var r = dkLen - (l - 1) * hLen;\n  salt.copy(block1, 0, 0, salt.length);\n  for (var i = 1; i <= l; i++) {\n    block1[salt.length + 0] = i >> 24 & 0xff;\n    block1[salt.length + 1] = i >> 16 & 0xff;\n    block1[salt.length + 2] = i >> 8 & 0xff;\n    block1[salt.length + 3] = i >> 0 & 0xff;\n    U = crypto.createHmac('sha512', key).update(block1).digest();\n    U.copy(T, 0, 0, hLen);\n    for (var j = 1; j < iterations; j++) {\n      U = crypto.createHmac('sha512', key).update(U).digest();\n      for (var k = 0; k < hLen; k++) {\n        T[k] ^= U[k];\n      }\n    }\n    var destPos = (i - 1) * hLen;\n    var len = i === l ? r : hLen;\n    T.copy(DK, destPos, 0, len);\n  }\n  return DK;\n}\nmodule.exports = pbkdf2;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}