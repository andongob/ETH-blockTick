{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\nvar BlockHeader = require('./blockheader');\nvar BufferUtil = require('../util/buffer');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar JSUtil = require('../util/js');\nvar Transaction = require('../transaction');\nvar errors = require('../errors');\nvar $ = require('../util/preconditions');\n\n/**\n * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock\n * @returns {MerkleBlock}\n * @constructor\n */\nfunction MerkleBlock(arg) {\n  /* jshint maxstatements: 18 */\n\n  if (!(this instanceof MerkleBlock)) {\n    return new MerkleBlock(arg);\n  }\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = MerkleBlock._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    var header;\n    if (arg.header instanceof BlockHeader) {\n      header = arg.header;\n    } else {\n      header = BlockHeader.fromObject(arg.header);\n    }\n    info = {\n      /**\n       * @name MerkleBlock#header\n       * @type {BlockHeader}\n       */\n      header: header,\n      /**\n       * @name MerkleBlock#numTransactions\n       * @type {Number}\n       */\n      numTransactions: arg.numTransactions,\n      /**\n       * @name MerkleBlock#hashes\n       * @type {String[]}\n       */\n      hashes: arg.hashes,\n      /**\n       * @name MerkleBlock#flags\n       * @type {Number[]}\n       */\n      flags: arg.flags\n    };\n  } else {\n    throw new TypeError('Unrecognized argument for MerkleBlock');\n  }\n  _.extend(this, info);\n  this._flagBitsUsed = 0;\n  this._hashesUsed = 0;\n  return this;\n}\n\n/**\n * @param {Buffer} - MerkleBlock data in a Buffer object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBuffer = function fromBuffer(buf) {\n  return MerkleBlock.fromBufferReader(BufferReader(buf));\n};\n\n/**\n * @param {BufferReader} - MerkleBlock data in a BufferReader object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBufferReader = function fromBufferReader(br) {\n  return new MerkleBlock(MerkleBlock._fromBufferReader(br));\n};\n\n/**\n * @returns {Buffer} - A buffer of the block\n */\nMerkleBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock\n */\nMerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.write(this.header.toBuffer());\n  bw.writeUInt32LE(this.numTransactions);\n  bw.writeVarintNum(this.hashes.length);\n  for (var i = 0; i < this.hashes.length; i++) {\n    bw.write(Buffer.from(this.hashes[i], 'hex'));\n  }\n  bw.writeVarintNum(this.flags.length);\n  for (i = 0; i < this.flags.length; i++) {\n    bw.writeUInt8(this.flags[i]);\n  }\n  return bw;\n};\n\n/**\n * @returns {Object} - A plain object with the MerkleBlock properties\n */\nMerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {\n  return {\n    header: this.header.toObject(),\n    numTransactions: this.numTransactions,\n    hashes: this.hashes,\n    flags: this.flags\n  };\n};\n\n/**\n * Verify that the MerkleBlock is valid\n * @returns {Boolean} - True/False whether this MerkleBlock is Valid\n */\nMerkleBlock.prototype.validMerkleTree = function validMerkleTree() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\n\n  // Can't have more hashes than numTransactions\n  if (this.hashes.length > this.numTransactions) {\n    return false;\n  }\n\n  // Can't have more flag bits than num hashes\n  if (this.flags.length * 8 < this.hashes.length) {\n    return false;\n  }\n  var height = this._calcTreeHeight();\n  var opts = {\n    hashesUsed: 0,\n    flagBitsUsed: 0\n  };\n  var root = this._traverseMerkleTree(height, 0, opts);\n  if (opts.hashesUsed !== this.hashes.length) {\n    return false;\n  }\n  return BufferUtil.equals(root, this.header.merkleRoot);\n};\n\n/**\n * Return a list of all the txs hash that match the filter\n * @returns {Array} - txs hash that match the filter\n */\nMerkleBlock.prototype.filterdTxsHash = function filterdTxsHash() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\n\n  // Can't have more hashes than numTransactions\n  if (this.hashes.length > this.numTransactions) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n\n  // Can't have more flag bits than num hashes\n  if (this.flags.length * 8 < this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n\n  // If there is only one hash the filter do not match any txs in the block\n  if (this.hashes.length === 1) {\n    return [];\n  }\n  ;\n  var height = this._calcTreeHeight();\n  var opts = {\n    hashesUsed: 0,\n    flagBitsUsed: 0\n  };\n  var txs = this._traverseMerkleTree(height, 0, opts, true);\n  if (opts.hashesUsed !== this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n  return txs;\n};\n\n/**\n * Traverse a the tree in this MerkleBlock, validating it along the way\n * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()\n * @param {Number} - depth - Current height\n * @param {Number} - pos - Current position in the tree\n * @param {Object} - opts - Object with values that need to be mutated throughout the traversal\n * @param {Boolean} - checkForTxs - if true return opts.txs else return the Merkle Hash\n * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0\n * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0\n * @param {Array} - opts.txs - Will finish populated by transactions found during traversal that match the filter\n * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height\n * @returns {Array} - transactions found during traversal that match the filter\n * @private\n */\nMerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts, checkForTxs) {\n  /* jshint maxcomplexity:  12*/\n  /* jshint maxstatements: 20 */\n\n  opts = opts || {};\n  opts.txs = opts.txs || [];\n  opts.flagBitsUsed = opts.flagBitsUsed || 0;\n  opts.hashesUsed = opts.hashesUsed || 0;\n  var checkForTxs = checkForTxs || false;\n  if (opts.flagBitsUsed > this.flags.length * 8) {\n    return null;\n  }\n  var isParentOfMatch = this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7) & 1;\n  if (depth === 0 || !isParentOfMatch) {\n    if (opts.hashesUsed >= this.hashes.length) {\n      return null;\n    }\n    var hash = this.hashes[opts.hashesUsed++];\n    if (depth === 0 && isParentOfMatch) {\n      opts.txs.push(hash);\n    }\n    return Buffer.from(hash, 'hex');\n  } else {\n    var left = this._traverseMerkleTree(depth - 1, pos * 2, opts);\n    var right = left;\n    if (pos * 2 + 1 < this._calcTreeWidth(depth - 1)) {\n      right = this._traverseMerkleTree(depth - 1, pos * 2 + 1, opts);\n    }\n    if (checkForTxs) {\n      return opts.txs;\n    } else {\n      return Hash.sha256sha256(new Buffer.concat([left, right]));\n    }\n    ;\n  }\n};\n\n/** Calculates the width of a merkle tree at a given height.\n *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Width of the tree at a given height\n * @private\n */\nMerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {\n  return this.numTransactions + (1 << height) - 1 >> height;\n};\n\n/** Calculates the height of the merkle tree in this MerkleBlock\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Height of the merkle tree in this MerkleBlock\n * @private\n */\nMerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {\n  var height = 0;\n  while (this._calcTreeWidth(height) > 1) {\n    height++;\n  }\n  return height;\n};\n\n/**\n * @param {Transaction|String} - Transaction or Transaction ID Hash\n * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not\n * @private\n */\nMerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {\n  $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');\n  $.checkArgument(tx instanceof Transaction || typeof tx === 'string', 'Invalid tx given, tx must be a \"string\" or \"Transaction\"');\n  var hash = tx;\n  if (tx instanceof Transaction) {\n    // We need to reverse the id hash for the lookup\n    hash = BufferUtil.reverse(Buffer.from(tx.id, 'hex')).toString('hex');\n  }\n  var txs = [];\n  var height = this._calcTreeHeight();\n  this._traverseMerkleTree(height, 0, {\n    txs: txs\n  });\n  return txs.indexOf(hash) !== -1;\n};\n\n/**\n * @param {Buffer} - MerkleBlock data\n * @returns {Object} - An Object representing merkleblock data\n * @private\n */\nMerkleBlock._fromBufferReader = function _fromBufferReader(br) {\n  $.checkState(!br.finished(), 'No merkleblock data received');\n  var info = {};\n  info.header = BlockHeader.fromBufferReader(br);\n  info.numTransactions = br.readUInt32LE();\n  var numHashes = br.readVarintNum();\n  info.hashes = [];\n  for (var i = 0; i < numHashes; i++) {\n    info.hashes.push(br.read(32).toString('hex'));\n  }\n  var numFlags = br.readVarintNum();\n  info.flags = [];\n  for (i = 0; i < numFlags; i++) {\n    info.flags.push(br.readUInt8());\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\nMerkleBlock.fromObject = function fromObject(obj) {\n  return new MerkleBlock(obj);\n};\nmodule.exports = MerkleBlock;","map":{"version":3,"names":["_","require","BlockHeader","BufferUtil","BufferReader","BufferWriter","Hash","JSUtil","Transaction","errors","$","MerkleBlock","arg","info","isBuffer","_fromBufferReader","isObject","header","fromObject","numTransactions","hashes","flags","TypeError","extend","_flagBitsUsed","_hashesUsed","fromBuffer","buf","fromBufferReader","br","prototype","toBuffer","toBufferWriter","concat","bw","write","writeUInt32LE","writeVarintNum","length","i","Buffer","from","writeUInt8","toObject","toJSON","validMerkleTree","checkState","isArray","height","_calcTreeHeight","opts","hashesUsed","flagBitsUsed","root","_traverseMerkleTree","equals","merkleRoot","filterdTxsHash","InvalidMerkleTree","txs","traverseMerkleTree","depth","pos","checkForTxs","isParentOfMatch","hash","push","left","right","_calcTreeWidth","sha256sha256","calcTreeWidth","calcTreeHeight","hasTransaction","tx","checkArgument","isUndefined","reverse","id","toString","indexOf","finished","readUInt32LE","numHashes","readVarintNum","read","numFlags","readUInt8","obj","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/bitcore-lib/lib/block/merkleblock.js"],"sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar BlockHeader = require('./blockheader');\nvar BufferUtil = require('../util/buffer');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar JSUtil = require('../util/js');\nvar Transaction = require('../transaction');\nvar errors = require('../errors');\nvar $ = require('../util/preconditions');\n\n/**\n * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock\n * @returns {MerkleBlock}\n * @constructor\n */\nfunction MerkleBlock(arg) {\n  /* jshint maxstatements: 18 */\n\n  if (!(this instanceof MerkleBlock)) {\n    return new MerkleBlock(arg);\n  }\n\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = MerkleBlock._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    var header;\n    if(arg.header instanceof BlockHeader) {\n      header = arg.header;\n    } else {\n      header = BlockHeader.fromObject(arg.header);\n    }\n    info = {\n      /**\n       * @name MerkleBlock#header\n       * @type {BlockHeader}\n       */\n      header: header,\n      /**\n       * @name MerkleBlock#numTransactions\n       * @type {Number}\n       */\n      numTransactions: arg.numTransactions,\n      /**\n       * @name MerkleBlock#hashes\n       * @type {String[]}\n       */\n      hashes: arg.hashes,\n      /**\n       * @name MerkleBlock#flags\n       * @type {Number[]}\n       */\n      flags: arg.flags\n    };\n  } else {\n    throw new TypeError('Unrecognized argument for MerkleBlock');\n  }\n  _.extend(this,info);\n  this._flagBitsUsed = 0;\n  this._hashesUsed = 0;\n\n  return this;\n}\n\n/**\n * @param {Buffer} - MerkleBlock data in a Buffer object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBuffer = function fromBuffer(buf) {\n  return MerkleBlock.fromBufferReader(BufferReader(buf));\n};\n\n/**\n * @param {BufferReader} - MerkleBlock data in a BufferReader object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBufferReader = function fromBufferReader(br) {\n  return new MerkleBlock(MerkleBlock._fromBufferReader(br));\n};\n\n/**\n * @returns {Buffer} - A buffer of the block\n */\nMerkleBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock\n */\nMerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.write(this.header.toBuffer());\n  bw.writeUInt32LE(this.numTransactions);\n  bw.writeVarintNum(this.hashes.length);\n  for (var i = 0; i < this.hashes.length; i++) {\n    bw.write(Buffer.from(this.hashes[i], 'hex'));\n  }\n  bw.writeVarintNum(this.flags.length);\n  for (i = 0; i < this.flags.length; i++) {\n    bw.writeUInt8(this.flags[i]);\n  }\n  return bw;\n};\n\n/**\n * @returns {Object} - A plain object with the MerkleBlock properties\n */\nMerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {\n  return {\n    header: this.header.toObject(),\n    numTransactions: this.numTransactions,\n    hashes: this.hashes,\n    flags: this.flags\n  };\n};\n\n/**\n * Verify that the MerkleBlock is valid\n * @returns {Boolean} - True/False whether this MerkleBlock is Valid\n */\nMerkleBlock.prototype.validMerkleTree = function validMerkleTree() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\n\n  // Can't have more hashes than numTransactions\n  if(this.hashes.length > this.numTransactions) {\n    return false;\n  }\n\n  // Can't have more flag bits than num hashes\n  if(this.flags.length * 8 < this.hashes.length) {\n    return false;\n  }\n\n  var height = this._calcTreeHeight();\n  var opts = { hashesUsed: 0, flagBitsUsed: 0 };\n  var root = this._traverseMerkleTree(height, 0, opts);\n  if(opts.hashesUsed !== this.hashes.length) {\n    return false;\n  }\n  return BufferUtil.equals(root, this.header.merkleRoot);\n};\n\n/**\n * Return a list of all the txs hash that match the filter\n * @returns {Array} - txs hash that match the filter\n */\nMerkleBlock.prototype.filterdTxsHash = function filterdTxsHash() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\n\n  // Can't have more hashes than numTransactions\n  if(this.hashes.length > this.numTransactions) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n\n  // Can't have more flag bits than num hashes\n  if(this.flags.length * 8 < this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n\n  // If there is only one hash the filter do not match any txs in the block\n  if(this.hashes.length === 1) {\n    return [];\n  };\n\n  var height = this._calcTreeHeight();\n  var opts = { hashesUsed: 0, flagBitsUsed: 0 };\n  var txs = this._traverseMerkleTree(height, 0, opts, true);\n  if(opts.hashesUsed !== this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n  return txs;\n};\n\n/**\n * Traverse a the tree in this MerkleBlock, validating it along the way\n * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()\n * @param {Number} - depth - Current height\n * @param {Number} - pos - Current position in the tree\n * @param {Object} - opts - Object with values that need to be mutated throughout the traversal\n * @param {Boolean} - checkForTxs - if true return opts.txs else return the Merkle Hash\n * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0\n * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0\n * @param {Array} - opts.txs - Will finish populated by transactions found during traversal that match the filter\n * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height\n * @returns {Array} - transactions found during traversal that match the filter\n * @private\n */\nMerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts, checkForTxs) {\n  /* jshint maxcomplexity:  12*/\n  /* jshint maxstatements: 20 */\n\n  opts = opts || {};\n  opts.txs = opts.txs || [];\n  opts.flagBitsUsed = opts.flagBitsUsed || 0;\n  opts.hashesUsed = opts.hashesUsed || 0;\n  var checkForTxs = checkForTxs || false;\n\n  if(opts.flagBitsUsed > this.flags.length * 8) {\n    return null;\n  }\n  var isParentOfMatch = (this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7)) & 1;\n  if(depth === 0 || !isParentOfMatch) {\n    if(opts.hashesUsed >= this.hashes.length) {\n      return null;\n    }\n    var hash = this.hashes[opts.hashesUsed++];\n    if(depth === 0 && isParentOfMatch) {\n      opts.txs.push(hash);\n    }\n    return Buffer.from(hash, 'hex');\n  } else {\n    var left = this._traverseMerkleTree(depth-1, pos*2, opts);\n    var right = left;\n    if(pos*2+1 < this._calcTreeWidth(depth-1)) {\n      right = this._traverseMerkleTree(depth-1, pos*2+1, opts);\n    }\n    if (checkForTxs){\n      return opts.txs;\n    } else {\n      return Hash.sha256sha256(new Buffer.concat([left, right]));\n    };\n  }\n};\n\n/** Calculates the width of a merkle tree at a given height.\n *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Width of the tree at a given height\n * @private\n */\nMerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {\n  return (this.numTransactions + (1 << height) - 1) >> height;\n};\n\n/** Calculates the height of the merkle tree in this MerkleBlock\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Height of the merkle tree in this MerkleBlock\n * @private\n */\nMerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {\n  var height = 0;\n  while (this._calcTreeWidth(height) > 1) {\n    height++;\n  }\n  return height;\n};\n\n/**\n * @param {Transaction|String} - Transaction or Transaction ID Hash\n * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not\n * @private\n */\nMerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {\n  $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');\n  $.checkArgument(tx instanceof Transaction || typeof tx === 'string',\n      'Invalid tx given, tx must be a \"string\" or \"Transaction\"');\n\n  var hash = tx;\n  if(tx instanceof Transaction) {\n    // We need to reverse the id hash for the lookup\n    hash = BufferUtil.reverse(Buffer.from(tx.id, 'hex')).toString('hex');\n  }\n\n  var txs = [];\n  var height = this._calcTreeHeight();\n  this._traverseMerkleTree(height, 0, { txs: txs });\n  return txs.indexOf(hash) !== -1;\n};\n\n/**\n * @param {Buffer} - MerkleBlock data\n * @returns {Object} - An Object representing merkleblock data\n * @private\n */\nMerkleBlock._fromBufferReader = function _fromBufferReader(br) {\n  $.checkState(!br.finished(), 'No merkleblock data received');\n  var info = {};\n  info.header = BlockHeader.fromBufferReader(br);\n  info.numTransactions = br.readUInt32LE();\n  var numHashes = br.readVarintNum();\n  info.hashes = [];\n  for (var i = 0; i < numHashes; i++) {\n    info.hashes.push(br.read(32).toString('hex'));\n  }\n  var numFlags = br.readVarintNum();\n  info.flags = [];\n  for (i = 0; i < numFlags; i++) {\n    info.flags.push(br.readUInt8());\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\nMerkleBlock.fromObject = function fromObject(obj) {\n  return new MerkleBlock(obj);\n};\n\nmodule.exports = MerkleBlock;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}