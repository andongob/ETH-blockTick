{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar errors = require('./errors');\nvar Base58Check = require('./encoding/base58check');\nvar Bech32 = require('./encoding/bech32');\nvar Networks = require('./networks');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar PublicKey = require('./publickey');\n\n/**\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\n * or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this constructor is an\n * `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is one of\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string),\n * `Address.PayToScriptHash` (the string `'scripthash'`),\n * `Address.PayToWitnessPublicKeyHash` (the string `'witnesspubkeyhash'`),\n * or `Address.PayToWitnessScriptHash` (the string `'witnessscripthash'`).\n * The network is an instance of {@link Network}.\n * You can quickly check whether an address is of a given kind by using the methods\n * `isPayToPublicKeyHash`, `isPayToScriptHash`, `isPayToWitnessPublicKeyHash`,\n * and `isPayToWitnessScriptHash`.\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'scripthash', 'pubkeyhash', witnessscripthash, 'witnesspubkeyhash', or 'taproot'\n * @param {string=} multisigType - The type of multisig: 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\nfunction Address(data, network, type, multisigType) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n\n  if (!(this instanceof Address)) {\n    return new Address(data, network, type);\n  }\n  if (_.isArray(data) && _.isNumber(network)) {\n    return Address.createMultisig(data, network, type, false, multisigType);\n  }\n  if (data instanceof Address) {\n    // Immutable instance\n    return data;\n  }\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\n  }\n  if (type && type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash && type !== Address.PayToWitnessPublicKeyHash && type !== Address.PayToWitnessScriptHash && type !== Address.PayToTaproot) {\n    throw new TypeError('Third argument must be \"pubkeyhash\", \"scripthash\", \"witnesspubkeyhash\", \"witnessscripthash\", or \"taproot\".');\n  }\n  var info = this._classifyArguments(data, network, type);\n\n  // set defaults if not set\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n  info.type = info.type || type || Address.PayToPublicKeyHash;\n  JSUtil.defineImmutable(this, {\n    hashBuffer: info.hashBuffer,\n    network: info.network,\n    type: info.type\n  });\n  return this;\n}\n\n/**\n * Internal function used to split different kinds of arguments of the constructor\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n */\nAddress.prototype._classifyArguments = function (data, network, type) {\n  /* jshint maxcomplexity: 10 */\n  // transform and validate input data\n  if ((data instanceof Buffer || data instanceof Uint8Array) && (data.length === 20 || data.length === 32)) {\n    return Address._transformHash(data, network, type);\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length >= 21) {\n    return Address._transformBuffer(data, network, type);\n  } else if (data instanceof PublicKey) {\n    return Address._transformPublicKey(data, network, type);\n  } else if (data instanceof Script) {\n    return Address._transformScript(data, network);\n  } else if (typeof data === 'string') {\n    return Address._transformString(data, network, type);\n  } else if (_.isObject(data)) {\n    return Address._transformObject(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n};\n\n/** @static */\nAddress.PayToPublicKeyHash = 'pubkeyhash';\n/** @static */\nAddress.PayToScriptHash = 'scripthash';\n/** @static */\nAddress.PayToWitnessPublicKeyHash = 'witnesspubkeyhash';\n/** @static */\nAddress.PayToWitnessScriptHash = 'witnessscripthash';\n/** @static */\nAddress.PayToTaproot = 'taproot';\n\n/**\n * @param {Buffer} hash - An instance of a hash Buffer\n * @param {string} type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} network - the name of the network associated\n * @returns {Object} An object with keys: hashBuffer\n * @private\n */\nAddress._transformHash = function (hash, network, type) {\n  var info = {};\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (hash.length !== 20 && hash.length !== 32) {\n    throw new TypeError('Address hashbuffers must be either 20 or 32 bytes.');\n  }\n  info.hashBuffer = hash;\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.type = type;\n  return info;\n};\n\n/**\n * Deserializes an address serialized through `Address#toObject()`\n * @param {Object} data\n * @param {string} data.hash - the hash that this address encodes\n * @param {string} data.type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} data.network - the name of the network associated\n * @return {Address}\n */\nAddress._transformObject = function (data) {\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n  $.checkArgument(data.type, 'Must provide a `type` property');\n  return {\n    hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,\n    network: Networks.get(data.network) || Networks.defaultNetwork,\n    type: data.type\n  };\n};\n\n/**\n * Internal function to discover the network and type based on the first data byte\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @returns {Object} An object with keys: network and type\n * @private\n */\nAddress._classifyFromVersion = function (buffer) {\n  var version = {};\n  if (buffer.length > 21) {\n    var info = Bech32.decode(buffer.toString('utf8'));\n    if (info.version !== 0 && info.version !== 1) {\n      // v1 == taproot\n      throw new TypeError('Only witness v0 and v1 addresses are supported.');\n    }\n    if (info.version === 0) {\n      if (info.data.length === 20) {\n        version.type = Address.PayToWitnessPublicKeyHash;\n      } else if (info.data.length === 32) {\n        version.type = Address.PayToWitnessScriptHash;\n      } else {\n        throw new TypeError('Witness data must be either 20 or 32 bytes.');\n      }\n    } else if (info.version === 1) {\n      if (info.data.length === 32) {\n        version.type = Address.PayToTaproot;\n      } else {\n        throw new TypeError('Witness data must be 32 bytes for v1');\n      }\n    } else {}\n    version.network = Networks.get(info.prefix, 'bech32prefix');\n  } else {\n    var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n    var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n    if (pubkeyhashNetwork) {\n      version.network = pubkeyhashNetwork;\n      version.type = Address.PayToPublicKeyHash;\n    } else if (scripthashNetwork) {\n      version.network = scripthashNetwork;\n      version.type = Address.PayToScriptHash;\n    }\n  }\n  return version;\n};\n\n/**\n * Internal function to transform a bitcoin address buffer\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @param {string=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformBuffer = function (buffer, network, type) {\n  /* jshint maxcomplexity: 9 */\n  var info = {};\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (buffer.length < 21) {\n    throw new TypeError('Address buffer is incorrect length.');\n  }\n  var networkObj = Networks.get(network);\n  var bufferVersion = Address._classifyFromVersion(buffer);\n  if (network && !networkObj) {\n    throw new TypeError('Unknown network');\n  }\n  if (!bufferVersion.network || networkObj && networkObj.xpubkey !== bufferVersion.network.xpubkey) {\n    throw new TypeError('Address has mismatched network type.');\n  }\n  if (!bufferVersion.type || type && type !== bufferVersion.type) {\n    throw new TypeError('Address has mismatched type.');\n  }\n  if (buffer.length > 21) {\n    info.hashBuffer = Bech32.decode(buffer.toString('utf8')).data;\n  } else {\n    info.hashBuffer = buffer.slice(1);\n  }\n  info.network = bufferVersion.network;\n  info.type = bufferVersion.type;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link PublicKey}\n *\n * @param {PublicKey} pubkey - An instance of PublicKey\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', 'scripthash', or 'taproot'\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformPublicKey = function (pubkey, network, type) {\n  var info = {};\n  if (!(pubkey instanceof PublicKey)) {\n    throw new TypeError('Address must be an instance of PublicKey.');\n  }\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessPublicKeyHash && type !== Address.PayToPublicKeyHash && type !== Address.PayToTaproot) {\n    throw new TypeError('Type must be either pubkeyhash, witnesspubkeyhash, scripthash, or taproot to transform public key.');\n  }\n  if (!pubkey.compressed && (type === Address.PayToScriptHash || type === Address.PayToWitnessPublicKeyHash)) {\n    throw new TypeError('Witness addresses must use compressed public keys.');\n  }\n  if (type === Address.PayToScriptHash) {\n    info.hashBuffer = Hash.sha256ripemd160(Script.buildWitnessV0Out(pubkey).toBuffer());\n  } else if (type === Address.PayToTaproot) {\n    info.hashBuffer = Hash.sha256ripemd160(Script.buildWitnessV1Out(pubkey).toBuffer());\n  } else {\n    info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n  }\n  info.type = type || Address.PayToPublicKeyHash;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link Script} into a `info` object.\n *\n * @param {Script} script - An instance of Script\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformScript = function (script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = script.getAddressInfo(network);\n  if (!info) {\n    throw new errors.Script.CantDeriveAddress(script);\n  }\n  return info;\n};\n\n/**\n * Creates a P2SH address from a set of public keys and a threshold.\n *\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n * interface.\n *\n * @param {Array} publicKeys - a set of public keys to create an address\n * @param {number} threshold - the number of signatures needed to release the funds\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {boolean=} nestedWitness - if the address uses a nested p2sh witness\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'. If nestedWitness is set, then this is ignored\n * @return {Address}\n */\nAddress.createMultisig = function (publicKeys, threshold, network, nestedWitness, type) {\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessScriptHash) {\n    throw new TypeError('Type must be either scripthash or witnessscripthash to create multisig.');\n  }\n  if (nestedWitness || type === Address.PayToWitnessScriptHash) {\n    publicKeys = _.map(publicKeys, PublicKey);\n    for (var i = 0; i < publicKeys.length; i++) {\n      if (!publicKeys[i].compressed) {\n        throw new TypeError('Witness addresses must use compressed public keys.');\n      }\n    }\n  }\n  var redeemScript = Script.buildMultisigOut(publicKeys, threshold);\n  if (nestedWitness) {\n    return Address.payingTo(Script.buildWitnessMultisigOutFromScript(redeemScript), network);\n  }\n  return Address.payingTo(redeemScript, network, type);\n};\n\n/**\n * Internal function to transform a bitcoin address string\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformString = function (data, network, type) {\n  if (typeof data !== 'string') {\n    throw new TypeError('data parameter supplied is not a string.');\n  }\n  if (data.length > 100) {\n    throw new TypeError('address string is too long');\n  }\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Unknown network');\n  }\n  data = data.trim();\n  try {\n    var info = Address._transformBuffer(Buffer.from(data, 'utf8'), network, type);\n    return info;\n  } catch (e) {\n    if (type === Address.PayToWitnessPublicKeyHash || type === Address.PayToWitnessScriptHash || type === Address.PayToTaproot) {\n      throw e;\n    }\n  }\n  var addressBuffer = Base58Check.decode(data);\n  var info = Address._transformBuffer(addressBuffer, network, type);\n  return info;\n};\n\n/**\n * Instantiate an address from a PublicKey instance\n *\n * @param {PublicKey} data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKey = function (data, network, type) {\n  var info = Address._transformPublicKey(data, network, type);\n  network = network || Networks.defaultNetwork;\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a ripemd160 public key hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKeyHash = function (hash, network) {\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\n};\n\n/**\n * Instantiate an address from a ripemd160 script hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScriptHash = function (hash, network, type) {\n  $.checkArgument(hash, 'hash parameter is required');\n  var info = Address._transformHash(hash);\n  if (type === Address.PayToWitnessScriptHash && hash.length !== 32) {\n    throw new TypeError('Address hashbuffer must be exactly 32 bytes for v0 witness script hash.');\n  }\n  var type = type || Address.PayToScriptHash;\n  return new Address(info.hashBuffer, network, type);\n};\n\n/**\n * Builds a p2sh address paying to script. This will hash the script and\n * use that to create the address.\n * If you want to extract an address associated with a script instead,\n * see {{Address#fromScript}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.payingTo = function (script, network, type) {\n  $.checkArgument(script, 'script is required');\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\n  var hash;\n  if (type === Address.PayToWitnessScriptHash) {\n    hash = Hash.sha256(script.toBuffer());\n  } else {\n    hash = Hash.sha256ripemd160(script.toBuffer());\n  }\n  var type = type || Address.PayToScriptHash;\n  return Address.fromScriptHash(hash, network, type);\n};\n\n/**\n * Extract address from a Script. The script must be of one\n * of the following types: p2pkh input, p2pkh output, p2sh input\n * or p2sh output.\n * This will analyze the script and extract address information from it.\n * If you want to transform any script to a p2sh Address paying\n * to that script's hash instead, use {{Address#payingTo}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScript = function (script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = Address._transformScript(script, network);\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a buffer of the address\n *\n * @param {Buffer} buffer - An instance of buffer of the address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromBuffer = function (buffer, network, type) {\n  var info = Address._transformBuffer(buffer, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an address string\n *\n * @param {string} str - An string of the bitcoin address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromString = function (str, network, type) {\n  var info = Address._transformString(str, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an Object\n *\n * @param {string} json - An JSON string or Object with keys: hash, network and type\n * @returns {Address} A new valid instance of an Address\n */\nAddress.fromObject = function fromObject(obj) {\n  $.checkState(JSUtil.isHexa(obj.hash), 'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.');\n  var hashBuffer = Buffer.from(obj.hash, 'hex');\n  return new Address(hashBuffer, obj.network, obj.type);\n};\n\n/**\n * Will return a validation error if exists\n *\n * @example\n * ```javascript\n * // a network mismatch error\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {null|Error} The corresponding error message\n */\nAddress.getValidationError = function (data, network, type) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new Address(data, network, type);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Will return a boolean if an address is valid\n *\n * @example\n * ```javascript\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {boolean} The corresponding error message\n */\nAddress.isValid = function (data, network, type) {\n  return !Address.getValidationError(data, network, type);\n};\n\n/**\n * Returns true if an address is of pay to public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToPublicKeyHash = function () {\n  return this.type === Address.PayToPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to script hash type\n * @return boolean\n */\nAddress.prototype.isPayToScriptHash = function () {\n  return this.type === Address.PayToScriptHash;\n};\n\n/**\n * Returns true if an address is of pay to witness public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToWitnessPublicKeyHash = function () {\n  return this.type === Address.PayToWitnessPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to witness script hash type\n * @return boolean\n */\nAddress.prototype.isPayToWitnessScriptHash = function () {\n  return this.type === Address.PayToWitnessScriptHash;\n};\n\n/**\n * Returns true if an address is of pay to Taproot script hash type\n * @returns {boolean}\n */\nAddress.prototype.isPayToTaproot = function () {\n  return this.type === Address.PayToTaproot;\n};\n\n/**\n * Will return a buffer representation of the address\n *\n * @returns {Buffer} Bitcoin address buffer\n */\nAddress.prototype.toBuffer = function () {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {\n    return Buffer.from(this.toString(), 'utf8');\n  }\n  var version = Buffer.from([this.network[this.type]]);\n  return Buffer.concat([version, this.hashBuffer]);\n};\n\n/**\n * @returns {Object} A plain object with the address information\n */\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hashBuffer.toString('hex'),\n    type: this.type,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a the string representation of the address\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.toString = function () {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash() || this.isPayToTaproot()) {\n    let prefix = this.network.bech32prefix;\n    let version = 0;\n    let encoding = Bech32.encodings.BECH32;\n    if (this.isPayToTaproot()) {\n      version = 1;\n      encoding = Bech32.encodings.BECH32M;\n    }\n    return Bech32.encode(prefix, version, this.hashBuffer, encoding);\n  }\n  return Base58Check.encode(this.toBuffer());\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.inspect = function () {\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\n};\nmodule.exports = Address;\nvar Script = require('./script');","map":{"version":3,"names":["_","require","$","errors","Base58Check","Bech32","Networks","Hash","JSUtil","PublicKey","Address","data","network","type","multisigType","isArray","isNumber","createMultisig","checkArgument","get","TypeError","PayToPublicKeyHash","PayToScriptHash","PayToWitnessPublicKeyHash","PayToWitnessScriptHash","PayToTaproot","info","_classifyArguments","defaultNetwork","defineImmutable","hashBuffer","prototype","Buffer","Uint8Array","length","_transformHash","_transformBuffer","_transformPublicKey","Script","_transformScript","_transformString","isObject","_transformObject","hash","from","_classifyFromVersion","buffer","version","decode","toString","prefix","pubkeyhashNetwork","scripthashNetwork","networkObj","bufferVersion","xpubkey","slice","pubkey","compressed","sha256ripemd160","buildWitnessV0Out","toBuffer","buildWitnessV1Out","script","getAddressInfo","CantDeriveAddress","publicKeys","threshold","nestedWitness","map","i","redeemScript","buildMultisigOut","payingTo","buildWitnessMultisigOutFromScript","trim","e","addressBuffer","fromPublicKey","fromPublicKeyHash","fromScriptHash","sha256","fromScript","fromBuffer","fromString","str","fromObject","obj","checkState","isHexa","getValidationError","error","isValid","isPayToPublicKeyHash","isPayToScriptHash","isPayToWitnessPublicKeyHash","isPayToWitnessScriptHash","isPayToTaproot","concat","toObject","toJSON","bech32prefix","encoding","encodings","BECH32","BECH32M","encode","inspect","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/bitcore-lib/lib/address.js"],"sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar errors = require('./errors');\nvar Base58Check = require('./encoding/base58check');\nvar Bech32 = require('./encoding/bech32');\nvar Networks = require('./networks');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar PublicKey = require('./publickey');\n\n/**\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\n * or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this constructor is an\n * `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is one of\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string),\n * `Address.PayToScriptHash` (the string `'scripthash'`),\n * `Address.PayToWitnessPublicKeyHash` (the string `'witnesspubkeyhash'`),\n * or `Address.PayToWitnessScriptHash` (the string `'witnessscripthash'`).\n * The network is an instance of {@link Network}.\n * You can quickly check whether an address is of a given kind by using the methods\n * `isPayToPublicKeyHash`, `isPayToScriptHash`, `isPayToWitnessPublicKeyHash`,\n * and `isPayToWitnessScriptHash`.\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'scripthash', 'pubkeyhash', witnessscripthash, 'witnesspubkeyhash', or 'taproot'\n * @param {string=} multisigType - The type of multisig: 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\nfunction Address(data, network, type, multisigType) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n\n  if (!(this instanceof Address)) {\n    return new Address(data, network, type);\n  }\n\n  if (_.isArray(data) && _.isNumber(network)) {\n    return Address.createMultisig(data, network, type, false, multisigType);\n  }\n\n  if (data instanceof Address) {\n    // Immutable instance\n    return data;\n  }\n\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\n  }\n\n  if (type && (\n    type !== Address.PayToPublicKeyHash\n    && type !== Address.PayToScriptHash\n    && type !== Address.PayToWitnessPublicKeyHash\n    && type !== Address.PayToWitnessScriptHash\n    && type !== Address.PayToTaproot)) {\n    throw new TypeError('Third argument must be \"pubkeyhash\", \"scripthash\", \"witnesspubkeyhash\", \"witnessscripthash\", or \"taproot\".');\n  }\n\n  var info = this._classifyArguments(data, network, type);\n\n  // set defaults if not set\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n  info.type = info.type || type || Address.PayToPublicKeyHash;\n\n  JSUtil.defineImmutable(this, {\n    hashBuffer: info.hashBuffer,\n    network: info.network,\n    type: info.type\n  });\n\n  return this;\n}\n\n/**\n * Internal function used to split different kinds of arguments of the constructor\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n */\nAddress.prototype._classifyArguments = function(data, network, type) {\n  /* jshint maxcomplexity: 10 */\n  // transform and validate input data\n  if ((data instanceof Buffer || data instanceof Uint8Array) && (data.length === 20 || data.length === 32)) {\n    return Address._transformHash(data, network, type);\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length >= 21) {\n    return Address._transformBuffer(data, network, type);\n  } else if (data instanceof PublicKey) {\n    return Address._transformPublicKey(data, network, type);\n  } else if (data instanceof Script) {\n    return Address._transformScript(data, network);\n  } else if (typeof(data) === 'string') {\n    return Address._transformString(data, network, type);\n  } else if (_.isObject(data)) {\n    return Address._transformObject(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n};\n\n/** @static */\nAddress.PayToPublicKeyHash = 'pubkeyhash';\n/** @static */\nAddress.PayToScriptHash = 'scripthash';\n/** @static */\nAddress.PayToWitnessPublicKeyHash = 'witnesspubkeyhash';\n/** @static */\nAddress.PayToWitnessScriptHash = 'witnessscripthash';\n/** @static */\nAddress.PayToTaproot = 'taproot';\n\n/**\n * @param {Buffer} hash - An instance of a hash Buffer\n * @param {string} type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} network - the name of the network associated\n * @returns {Object} An object with keys: hashBuffer\n * @private\n */\nAddress._transformHash = function(hash, network, type) {\n  var info = {};\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (hash.length !== 20 && hash.length !== 32) {\n    throw new TypeError('Address hashbuffers must be either 20 or 32 bytes.');\n  }\n  info.hashBuffer = hash;\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.type = type;\n  return info;\n};\n\n/**\n * Deserializes an address serialized through `Address#toObject()`\n * @param {Object} data\n * @param {string} data.hash - the hash that this address encodes\n * @param {string} data.type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} data.network - the name of the network associated\n * @return {Address}\n */\nAddress._transformObject = function(data) {\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n  $.checkArgument(data.type, 'Must provide a `type` property');\n  return {\n    hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,\n    network: Networks.get(data.network) || Networks.defaultNetwork,\n    type: data.type\n  };\n};\n\n/**\n * Internal function to discover the network and type based on the first data byte\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @returns {Object} An object with keys: network and type\n * @private\n */\nAddress._classifyFromVersion = function(buffer) {\n  var version = {};\n\n  if (buffer.length > 21) {\n    var info = Bech32.decode(buffer.toString('utf8'));\n    if (info.version !== 0 && info.version !== 1) { // v1 == taproot\n      throw new TypeError('Only witness v0 and v1 addresses are supported.');\n    }\n\n    if (info.version === 0) {\n      if (info.data.length === 20) {\n        version.type = Address.PayToWitnessPublicKeyHash;\n      } else if (info.data.length === 32) {\n        version.type = Address.PayToWitnessScriptHash;\n      } else {\n        throw new TypeError('Witness data must be either 20 or 32 bytes.')\n      }\n    } else if (info.version === 1) {\n      if (info.data.length === 32) {\n        version.type = Address.PayToTaproot;\n      } else {\n        throw new TypeError('Witness data must be 32 bytes for v1');\n      }\n    } else {\n    }\n    version.network = Networks.get(info.prefix, 'bech32prefix');\n  } else {\n\n    var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n    var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n\n    if (pubkeyhashNetwork) {\n      version.network = pubkeyhashNetwork;\n      version.type = Address.PayToPublicKeyHash;\n    } else if (scripthashNetwork) {\n      version.network = scripthashNetwork;\n      version.type = Address.PayToScriptHash;\n    }\n  }\n\n  return version;\n};\n\n/**\n * Internal function to transform a bitcoin address buffer\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @param {string=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformBuffer = function(buffer, network, type) {\n  /* jshint maxcomplexity: 9 */\n  var info = {};\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n\n  if (buffer.length < 21) {\n    throw new TypeError('Address buffer is incorrect length.');\n  }\n\n  var networkObj = Networks.get(network);\n  var bufferVersion = Address._classifyFromVersion(buffer);\n\n  if (network && !networkObj) {\n    throw new TypeError('Unknown network');\n  }\n\n  if (!bufferVersion.network || (networkObj && networkObj.xpubkey !== bufferVersion.network.xpubkey)) {\n    throw new TypeError('Address has mismatched network type.');\n  }\n\n  if (!bufferVersion.type || (type && type !== bufferVersion.type)) {\n    throw new TypeError('Address has mismatched type.');\n  }\n\n  if (buffer.length > 21) {\n    info.hashBuffer = Bech32.decode(buffer.toString('utf8')).data;\n  } else {\n    info.hashBuffer = buffer.slice(1);\n  }\n  info.network = bufferVersion.network;\n  info.type = bufferVersion.type;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link PublicKey}\n *\n * @param {PublicKey} pubkey - An instance of PublicKey\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', 'scripthash', or 'taproot'\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformPublicKey = function(pubkey, network, type) {\n  var info = {};\n  if (!(pubkey instanceof PublicKey)) {\n    throw new TypeError('Address must be an instance of PublicKey.');\n  }\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessPublicKeyHash && type !== Address.PayToPublicKeyHash && type !== Address.PayToTaproot) {\n    throw new TypeError('Type must be either pubkeyhash, witnesspubkeyhash, scripthash, or taproot to transform public key.');\n  }\n  if (!pubkey.compressed && (type === Address.PayToScriptHash || type === Address.PayToWitnessPublicKeyHash)) {\n    throw new TypeError('Witness addresses must use compressed public keys.');\n  }\n  if (type === Address.PayToScriptHash) {\n    info.hashBuffer = Hash.sha256ripemd160(Script.buildWitnessV0Out(pubkey).toBuffer());\n  } else if (type === Address.PayToTaproot) {\n    info.hashBuffer = Hash.sha256ripemd160(Script.buildWitnessV1Out(pubkey).toBuffer());\n  } else {\n    info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n  }\n  info.type = type || Address.PayToPublicKeyHash;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link Script} into a `info` object.\n *\n * @param {Script} script - An instance of Script\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = script.getAddressInfo(network);\n  if (!info) {\n    throw new errors.Script.CantDeriveAddress(script);\n  }\n  return info;\n};\n\n/**\n * Creates a P2SH address from a set of public keys and a threshold.\n *\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n * interface.\n *\n * @param {Array} publicKeys - a set of public keys to create an address\n * @param {number} threshold - the number of signatures needed to release the funds\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {boolean=} nestedWitness - if the address uses a nested p2sh witness\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'. If nestedWitness is set, then this is ignored\n * @return {Address}\n */\nAddress.createMultisig = function(publicKeys, threshold, network, nestedWitness, type) {\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessScriptHash) {\n    throw new TypeError('Type must be either scripthash or witnessscripthash to create multisig.');\n  }\n  if (nestedWitness || type === Address.PayToWitnessScriptHash) {\n    publicKeys = _.map(publicKeys, PublicKey);\n    for (var i = 0; i < publicKeys.length; i++) {\n      if (!publicKeys[i].compressed) {\n        throw new TypeError('Witness addresses must use compressed public keys.');\n      }\n    }\n  }\n  var redeemScript = Script.buildMultisigOut(publicKeys, threshold);\n  if (nestedWitness) {\n    return Address.payingTo(Script.buildWitnessMultisigOutFromScript(redeemScript), network);\n  }\n  return Address.payingTo(redeemScript, network, type);\n};\n\n/**\n * Internal function to transform a bitcoin address string\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformString = function(data, network, type) {\n  if (typeof(data) !== 'string') {\n    throw new TypeError('data parameter supplied is not a string.');\n  }\n\n  if(data.length > 100) {\n    throw new TypeError('address string is too long');\n  }\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Unknown network');\n  }\n\n  data = data.trim();\n\n  try {\n    var info = Address._transformBuffer(Buffer.from(data, 'utf8'), network, type);\n    return info;\n  } catch (e) {\n    if (type === Address.PayToWitnessPublicKeyHash || type === Address.PayToWitnessScriptHash || type === Address.PayToTaproot) {\n      throw e;\n    }\n  }\n\n  var addressBuffer = Base58Check.decode(data);\n  var info = Address._transformBuffer(addressBuffer, network, type);\n  return info;\n};\n\n/**\n * Instantiate an address from a PublicKey instance\n *\n * @param {PublicKey} data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKey = function(data, network, type) {\n  var info = Address._transformPublicKey(data, network, type);\n  network = network || Networks.defaultNetwork;\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a ripemd160 public key hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKeyHash = function(hash, network) {\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\n};\n\n/**\n * Instantiate an address from a ripemd160 script hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScriptHash = function(hash, network, type) {\n  $.checkArgument(hash, 'hash parameter is required');\n  var info = Address._transformHash(hash);\n  if (type === Address.PayToWitnessScriptHash && hash.length !== 32) {\n      throw new TypeError('Address hashbuffer must be exactly 32 bytes for v0 witness script hash.');\n  }\n  var type = type || Address.PayToScriptHash;\n  return new Address(info.hashBuffer, network, type);\n};\n\n/**\n * Builds a p2sh address paying to script. This will hash the script and\n * use that to create the address.\n * If you want to extract an address associated with a script instead,\n * see {{Address#fromScript}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.payingTo = function(script, network, type) {\n  $.checkArgument(script, 'script is required');\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\n  var hash;\n  if (type === Address.PayToWitnessScriptHash) {\n    hash = Hash.sha256(script.toBuffer());\n  } else {\n    hash = Hash.sha256ripemd160(script.toBuffer());\n  }\n  var type = type || Address.PayToScriptHash;\n  return Address.fromScriptHash(hash, network, type);\n};\n\n/**\n * Extract address from a Script. The script must be of one\n * of the following types: p2pkh input, p2pkh output, p2sh input\n * or p2sh output.\n * This will analyze the script and extract address information from it.\n * If you want to transform any script to a p2sh Address paying\n * to that script's hash instead, use {{Address#payingTo}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = Address._transformScript(script, network);\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a buffer of the address\n *\n * @param {Buffer} buffer - An instance of buffer of the address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromBuffer = function(buffer, network, type) {\n  var info = Address._transformBuffer(buffer, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an address string\n *\n * @param {string} str - An string of the bitcoin address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromString = function(str, network, type) {\n  var info = Address._transformString(str, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an Object\n *\n * @param {string} json - An JSON string or Object with keys: hash, network and type\n * @returns {Address} A new valid instance of an Address\n */\nAddress.fromObject = function fromObject(obj) {\n  $.checkState(\n    JSUtil.isHexa(obj.hash),\n    'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.'\n  );\n  var hashBuffer = Buffer.from(obj.hash, 'hex');\n  return new Address(hashBuffer, obj.network, obj.type);\n};\n\n/**\n * Will return a validation error if exists\n *\n * @example\n * ```javascript\n * // a network mismatch error\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {null|Error} The corresponding error message\n */\nAddress.getValidationError = function(data, network, type) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new Address(data, network, type);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Will return a boolean if an address is valid\n *\n * @example\n * ```javascript\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {boolean} The corresponding error message\n */\nAddress.isValid = function(data, network, type) {\n  return !Address.getValidationError(data, network, type);\n};\n\n/**\n * Returns true if an address is of pay to public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToPublicKeyHash = function() {\n  return this.type === Address.PayToPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to script hash type\n * @return boolean\n */\nAddress.prototype.isPayToScriptHash = function() {\n  return this.type === Address.PayToScriptHash;\n};\n\n/**\n * Returns true if an address is of pay to witness public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToWitnessPublicKeyHash = function() {\n  return this.type === Address.PayToWitnessPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to witness script hash type\n * @return boolean\n */\nAddress.prototype.isPayToWitnessScriptHash = function() {\n  return this.type === Address.PayToWitnessScriptHash;\n};\n\n/**\n * Returns true if an address is of pay to Taproot script hash type\n * @returns {boolean}\n */\nAddress.prototype.isPayToTaproot = function() {\n  return this.type === Address.PayToTaproot;\n}\n\n/**\n * Will return a buffer representation of the address\n *\n * @returns {Buffer} Bitcoin address buffer\n */\nAddress.prototype.toBuffer = function() {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {\n    return Buffer.from(this.toString(), 'utf8')\n  }\n  var version = Buffer.from([this.network[this.type]]);\n  return Buffer.concat([version, this.hashBuffer]);\n};\n\n/**\n * @returns {Object} A plain object with the address information\n */\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hashBuffer.toString('hex'),\n    type: this.type,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a the string representation of the address\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.toString = function() {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash() || this.isPayToTaproot()) {\n    let prefix = this.network.bech32prefix;\n    let version = 0;\n    let encoding = Bech32.encodings.BECH32;\n    if (this.isPayToTaproot()) {\n      version = 1;\n      encoding = Bech32.encodings.BECH32M;\n    }\n    return Bech32.encode(prefix, version, this.hashBuffer, encoding);\n  }\n  return Base58Check.encode(this.toBuffer());\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.inspect = function() {\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\n};\n\nmodule.exports = Address;\n\nvar Script = require('./script');\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}