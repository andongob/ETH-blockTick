{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nvar secp256k1 = require('./secp256k1v3-adapter');\nvar BN = require(\"bn.js\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\n/**\r\n * Returns the ECDSA signature of a message hash.\r\n */\nexports.ecsign = function (msgHash, privateKey, chainId) {\n  var sig = secp256k1.sign(msgHash, privateKey);\n  var recovery = sig.recovery;\n  var ret = {\n    r: sig.signature.slice(0, 32),\n    s: sig.signature.slice(32, 64),\n    v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27\n  };\n  return ret;\n};\n/**\r\n * ECDSA public key recovery from signature.\r\n * @returns Recovered public key\r\n */\nexports.ecrecover = function (msgHash, v, r, s, chainId) {\n  var signature = Buffer.concat([bytes_1.setLength(r, 32), bytes_1.setLength(s, 32)], 64);\n  var recovery = calculateSigRecovery(v, chainId);\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);\n  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);\n};\n/**\r\n * Convert signature parameters into the format of `eth_sign` RPC method.\r\n * @returns Signature\r\n */\nexports.toRpcSig = function (v, r, s, chainId) {\n  var recovery = calculateSigRecovery(v, chainId);\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n  return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32), bytes_1.toBuffer(v)]));\n};\n/**\r\n * Convert signature format of the `eth_sign` RPC method to signature parameters\r\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\r\n */\nexports.fromRpcSig = function (sig) {\n  var buf = bytes_1.toBuffer(sig);\n  // NOTE: with potential introduction of chainId this might need to be updated\n  if (buf.length !== 65) {\n    throw new Error('Invalid signature length');\n  }\n  var v = buf[64];\n  // support both versions of `eth_sign` responses\n  if (v < 27) {\n    v += 27;\n  }\n  return {\n    v: v,\n    r: buf.slice(0, 32),\n    s: buf.slice(32, 64)\n  };\n};\n/**\r\n * Validate a ECDSA signature.\r\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\r\n */\nexports.isValidSignature = function (v, r, s, homesteadOrLater, chainId) {\n  if (homesteadOrLater === void 0) {\n    homesteadOrLater = true;\n  }\n  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\n  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);\n  if (r.length !== 32 || s.length !== 32) {\n    return false;\n  }\n  if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n    return false;\n  }\n  var rBN = new BN(r);\n  var sBN = new BN(s);\n  if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\n    return false;\n  }\n  if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\n    return false;\n  }\n  return true;\n};\n/**\r\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\r\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\r\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\r\n * used to produce the signature.\r\n */\nexports.hashPersonalMessage = function (message) {\n  var prefix = Buffer.from(\"\\u0019Ethereum Signed Message:\\n\" + message.length.toString(), 'utf-8');\n  return hash_1.keccak(Buffer.concat([prefix, message]));\n};\nfunction calculateSigRecovery(v, chainId) {\n  return chainId ? v - (2 * chainId + 35) : v - 27;\n}\nfunction isValidSigRecovery(recovery) {\n  return recovery === 0 || recovery === 1;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","hashPersonalMessage","isValidSignature","fromRpcSig","toRpcSig","ecrecover","ecsign","secp256k1","require","BN","bytes_1","hash_1","msgHash","privateKey","chainId","sig","sign","recovery","ret","r","signature","slice","s","v","Buffer","concat","setLength","calculateSigRecovery","isValidSigRecovery","Error","senderPubKey","recover","publicKeyConvert","bufferToHex","setLengthLeft","toBuffer","buf","length","homesteadOrLater","SECP256K1_N_DIV_2","SECP256K1_N","rBN","sBN","isZero","gt","cmp","message","prefix","from","toString","keccak"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFM - Enginering - SEP 2023/BLOCKTICK ETHEREUM/BLOCKTICK/Ethereum-Blocktick/node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/signature.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\r\nvar secp256k1 = require('./secp256k1v3-adapter');\r\nvar BN = require(\"bn.js\");\r\nvar bytes_1 = require(\"./bytes\");\r\nvar hash_1 = require(\"./hash\");\r\n/**\r\n * Returns the ECDSA signature of a message hash.\r\n */\r\nexports.ecsign = function (msgHash, privateKey, chainId) {\r\n    var sig = secp256k1.sign(msgHash, privateKey);\r\n    var recovery = sig.recovery;\r\n    var ret = {\r\n        r: sig.signature.slice(0, 32),\r\n        s: sig.signature.slice(32, 64),\r\n        v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27,\r\n    };\r\n    return ret;\r\n};\r\n/**\r\n * ECDSA public key recovery from signature.\r\n * @returns Recovered public key\r\n */\r\nexports.ecrecover = function (msgHash, v, r, s, chainId) {\r\n    var signature = Buffer.concat([bytes_1.setLength(r, 32), bytes_1.setLength(s, 32)], 64);\r\n    var recovery = calculateSigRecovery(v, chainId);\r\n    if (!isValidSigRecovery(recovery)) {\r\n        throw new Error('Invalid signature v value');\r\n    }\r\n    var senderPubKey = secp256k1.recover(msgHash, signature, recovery);\r\n    return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);\r\n};\r\n/**\r\n * Convert signature parameters into the format of `eth_sign` RPC method.\r\n * @returns Signature\r\n */\r\nexports.toRpcSig = function (v, r, s, chainId) {\r\n    var recovery = calculateSigRecovery(v, chainId);\r\n    if (!isValidSigRecovery(recovery)) {\r\n        throw new Error('Invalid signature v value');\r\n    }\r\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\r\n    return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32), bytes_1.toBuffer(v)]));\r\n};\r\n/**\r\n * Convert signature format of the `eth_sign` RPC method to signature parameters\r\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\r\n */\r\nexports.fromRpcSig = function (sig) {\r\n    var buf = bytes_1.toBuffer(sig);\r\n    // NOTE: with potential introduction of chainId this might need to be updated\r\n    if (buf.length !== 65) {\r\n        throw new Error('Invalid signature length');\r\n    }\r\n    var v = buf[64];\r\n    // support both versions of `eth_sign` responses\r\n    if (v < 27) {\r\n        v += 27;\r\n    }\r\n    return {\r\n        v: v,\r\n        r: buf.slice(0, 32),\r\n        s: buf.slice(32, 64),\r\n    };\r\n};\r\n/**\r\n * Validate a ECDSA signature.\r\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\r\n */\r\nexports.isValidSignature = function (v, r, s, homesteadOrLater, chainId) {\r\n    if (homesteadOrLater === void 0) { homesteadOrLater = true; }\r\n    var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\r\n    var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);\r\n    if (r.length !== 32 || s.length !== 32) {\r\n        return false;\r\n    }\r\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\r\n        return false;\r\n    }\r\n    var rBN = new BN(r);\r\n    var sBN = new BN(s);\r\n    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\r\n        return false;\r\n    }\r\n    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\n/**\r\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\r\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\r\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\r\n * used to produce the signature.\r\n */\r\nexports.hashPersonalMessage = function (message) {\r\n    var prefix = Buffer.from(\"\\u0019Ethereum Signed Message:\\n\" + message.length.toString(), 'utf-8');\r\n    return hash_1.keccak(Buffer.concat([prefix, message]));\r\n};\r\nfunction calculateSigRecovery(v, chainId) {\r\n    return chainId ? v - (2 * chainId + 35) : v - 27;\r\n}\r\nfunction isValidSigRecovery(recovery) {\r\n    return recovery === 0 || recovery === 1;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}