{"ast":null,"code":"'use strict';\n\nvar inherits = require('inherits');\nvar $ = require('../../util/preconditions');\nvar BufferUtil = require('../../util/buffer');\nvar Input = require('./input');\nvar Output = require('../output');\nvar Sighash = require('../sighash');\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar TransactionSignature = require('../signature');\n\n/**\n * Represents a special kind of input of PayToPublicKey kind.\n * @constructor\n */\nfunction PublicKeyInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyInput, Input);\n\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {String} signingMethod - method used to sign input - 'ecdsa' or 'schnorr' (future signing method)\n * @return {Array} of objects that can be\n */\nPublicKeyInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  var publicKey = privateKey.toPublicKey();\n  if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) {\n    return [new TransactionSignature({\n      publicKey: publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, signingMethod),\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {PublicKeyInput} this, for chaining\n */\nPublicKeyInput.prototype.addSignature = function (transaction, signature, signingMethod) {\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n  this.setScript(Script.buildPublicKeyIn(signature.signature.toDER(), signature.sigtype));\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyInput.prototype.clearSignatures = function () {\n  this.setScript(Script.empty());\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyInput.prototype.isFullySigned = function () {\n  return this.script.isPublicKeyIn();\n};\nPublicKeyInput.SCRIPT_MAX_SIZE = 73; // sigsize (1 + 72)\n\nPublicKeyInput.prototype._estimateSize = function () {\n  return PublicKeyInput.SCRIPT_MAX_SIZE;\n};\nmodule.exports = PublicKeyInput;","map":{"version":3,"names":["inherits","require","$","BufferUtil","Input","Output","Sighash","Script","Signature","TransactionSignature","PublicKeyInput","apply","arguments","prototype","getSignatures","transaction","privateKey","index","sigtype","hashData","signingMethod","checkState","output","SIGHASH_ALL","publicKey","toPublicKey","toString","script","getPublicKey","prevTxId","outputIndex","inputIndex","signature","sign","addSignature","isValidSignature","setScript","buildPublicKeyIn","toDER","clearSignatures","empty","isFullySigned","isPublicKeyIn","SCRIPT_MAX_SIZE","_estimateSize","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFG - Enginering/BLOCKTICK/blocktick_dApp/node_modules/bitcore-lib/lib/transaction/input/publickey.js"],"sourcesContent":["'use strict';\n\nvar inherits = require('inherits');\n\nvar $ = require('../../util/preconditions');\nvar BufferUtil = require('../../util/buffer');\n\nvar Input = require('./input');\nvar Output = require('../output');\nvar Sighash = require('../sighash');\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar TransactionSignature = require('../signature');\n\n/**\n * Represents a special kind of input of PayToPublicKey kind.\n * @constructor\n */\nfunction PublicKeyInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyInput, Input);\n\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {String} signingMethod - method used to sign input - 'ecdsa' or 'schnorr' (future signing method)\n * @return {Array} of objects that can be\n */\nPublicKeyInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  var publicKey = privateKey.toPublicKey();\n  if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) {\n    return [new TransactionSignature({\n      publicKey: publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, signingMethod),\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {PublicKeyInput} this, for chaining\n */\nPublicKeyInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n  this.setScript(Script.buildPublicKeyIn(\n    signature.signature.toDER(),\n    signature.sigtype\n  ));\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyInput.prototype.clearSignatures = function() {\n  this.setScript(Script.empty());\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyInput.prototype.isFullySigned = function() {\n  return this.script.isPublicKeyIn();\n};\n\nPublicKeyInput.SCRIPT_MAX_SIZE = 73; // sigsize (1 + 72)\n\nPublicKeyInput.prototype._estimateSize = function() {\n  return PublicKeyInput.SCRIPT_MAX_SIZE;\n};\n\nmodule.exports = PublicKeyInput;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}