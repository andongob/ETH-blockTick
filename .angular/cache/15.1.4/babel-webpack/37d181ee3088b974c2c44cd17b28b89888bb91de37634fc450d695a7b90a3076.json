{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\nvar $ = require('../../util/preconditions');\nconst errors = require('../../errors');\nvar BufferWriter = require('../../encoding/bufferwriter');\nvar buffer = require('buffer');\nvar BufferUtil = require('../../util/buffer');\nvar JSUtil = require('../../util/js');\nvar Script = require('../../script');\nvar Sighash = require('../sighash');\nvar Output = require('../output');\nvar MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;\nvar DEFAULT_SEQNUMBER = MAXINT;\nvar DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;\nvar DEFAULT_RBF_SEQNUMBER = MAXINT - 2;\nconst SEQUENCE_LOCKTIME_DISABLE_FLAG = Math.pow(2, 31); // (1 << 31);\nconst SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2, 22); // (1 << 22);\nconst SEQUENCE_LOCKTIME_MASK = 0xffff;\nconst SEQUENCE_LOCKTIME_GRANULARITY = 512; // 512 seconds\nconst SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2, 16) - 1; // 16 bits \n\nfunction Input(params) {\n  if (!(this instanceof Input)) {\n    return new Input(params);\n  }\n  if (params) {\n    return this._fromObject(params);\n  }\n}\nInput.MAXINT = MAXINT;\nInput.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;\nInput.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;\nInput.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;\nInput.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;\nObject.defineProperty(Input.prototype, 'script', {\n  configurable: false,\n  enumerable: true,\n  get: function () {\n    if (this.isNull()) {\n      return null;\n    }\n    if (!this._script) {\n      this._script = new Script(this._scriptBuffer);\n      this._script._isInput = true;\n    }\n    return this._script;\n  }\n});\nInput.fromObject = function (obj) {\n  $.checkArgument(_.isObject(obj));\n  var input = new Input();\n  return input._fromObject(obj);\n};\nInput.prototype._fromObject = function (params) {\n  var prevTxId;\n  if (_.isString(params.prevTxId) && JSUtil.isHexa(params.prevTxId)) {\n    prevTxId = Buffer.from(params.prevTxId, 'hex');\n  } else {\n    prevTxId = params.prevTxId;\n  }\n  this.witnesses = [];\n  this.output = params.output ? params.output instanceof Output ? params.output : new Output(params.output) : undefined;\n  this.prevTxId = prevTxId || params.txidbuf;\n  this.outputIndex = _.isUndefined(params.outputIndex) ? params.txoutnum : params.outputIndex;\n  this.sequenceNumber = _.isUndefined(params.sequenceNumber) ? _.isUndefined(params.seqnum) ? DEFAULT_SEQNUMBER : params.seqnum : params.sequenceNumber;\n  if (_.isUndefined(params.script) && _.isUndefined(params.scriptBuffer)) {\n    throw new errors.Transaction.Input.MissingScript();\n  }\n  this.setScript(params.scriptBuffer || params.script);\n  return this;\n};\nInput.prototype.toObject = Input.prototype.toJSON = function toObject() {\n  var obj = {\n    prevTxId: this.prevTxId.toString('hex'),\n    outputIndex: this.outputIndex,\n    sequenceNumber: this.sequenceNumber,\n    script: this._scriptBuffer.toString('hex')\n  };\n  // add human readable form if input contains valid script\n  if (this.script) {\n    obj.scriptString = this.script.toString();\n  }\n  if (this.output) {\n    obj.output = this.output.toObject();\n  }\n  return obj;\n};\nInput.fromBufferReader = function (br) {\n  var input = new Input();\n  input.prevTxId = br.readReverse(32);\n  input.outputIndex = br.readUInt32LE();\n  input._scriptBuffer = br.readVarLengthBuffer();\n  input.sequenceNumber = br.readUInt32LE();\n  // TODO: return different classes according to which input it is\n  // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.\n  return input;\n};\nInput.prototype.toBufferWriter = function (writer) {\n  if (!writer) {\n    writer = new BufferWriter();\n  }\n  writer.writeReverse(this.prevTxId);\n  writer.writeUInt32LE(this.outputIndex);\n  var script = this._scriptBuffer;\n  writer.writeVarintNum(script.length);\n  writer.write(script);\n  writer.writeUInt32LE(this.sequenceNumber);\n  return writer;\n};\nInput.prototype.setScript = function (script) {\n  this._script = null;\n  if (script instanceof Script) {\n    this._script = script;\n    this._script._isInput = true;\n    this._scriptBuffer = script.toBuffer();\n  } else if (JSUtil.isHexa(script)) {\n    // hex string script\n    this._scriptBuffer = Buffer.from(script, 'hex');\n  } else if (_.isString(script)) {\n    // human readable string script\n    this._script = new Script(script);\n    this._script._isInput = true;\n    this._scriptBuffer = this._script.toBuffer();\n  } else if (BufferUtil.isBuffer(script)) {\n    // buffer script\n    this._scriptBuffer = Buffer.from(script);\n  } else {\n    throw new TypeError('Invalid argument type: script');\n  }\n  return this;\n};\n\n/**\n * Retrieve signatures for the provided PrivateKey.\n *\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key to use when signing\n * @param {number} inputIndex - the index of this input in the provided transaction\n * @param {number} sigType - defaults to Signature.SIGHASH_ALL\n * @param {Buffer} addressHash - if provided, don't calculate the hash of the\n *     public key associated with the private key provided\n * @abstract\n */\nInput.prototype.getSignatures = function () {\n  throw new errors.AbstractMethodInvoked('Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' + ' for input: ' + JSON.stringify(this));\n};\nInput.prototype.getSatoshisBuffer = function () {\n  $.checkState(this.output instanceof Output);\n  $.checkState(this.output._satoshisBN);\n  return new BufferWriter().writeUInt64LEBN(this.output._satoshisBN).toBuffer();\n};\nInput.prototype.isFullySigned = function () {\n  throw new errors.AbstractMethodInvoked('Input#isFullySigned');\n};\nInput.prototype.isFinal = function () {\n  return this.sequenceNumber !== Input.MAXINT;\n};\nInput.prototype.addSignature = function () {\n  throw new errors.AbstractMethodInvoked('Input#addSignature');\n};\nInput.prototype.clearSignatures = function () {\n  throw new errors.AbstractMethodInvoked('Input#clearSignatures');\n};\nInput.prototype.hasWitnesses = function () {\n  if (this.witnesses && this.witnesses.length > 0) {\n    return true;\n  }\n  return false;\n};\nInput.prototype.getWitnesses = function () {\n  return this.witnesses;\n};\nInput.prototype.setWitnesses = function (witnesses) {\n  this.witnesses = witnesses;\n};\nInput.prototype.isValidSignature = function (transaction, signature, signingMethod) {\n  // FIXME: Refactor signature so this is not necessary\n  signingMethod = signingMethod || 'ecdsa';\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script, signingMethod);\n};\n\n/**\n * @returns true if this is a coinbase input (represents no input)\n */\nInput.prototype.isNull = function () {\n  return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' && this.outputIndex === 0xffffffff;\n};\nInput.prototype._estimateSize = function () {\n  return this.toBufferWriter().toBuffer().length;\n};\n\n/**\n * Sets sequence number so that transaction is not valid until the desired seconds\n *  since the transaction is mined\n *\n * @param {Number} time in seconds\n * @return {Transaction} this\n */\nInput.prototype.lockForSeconds = function (seconds) {\n  $.checkArgument(_.isNumber(seconds));\n  if (seconds < 0 || seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {\n    throw new errors.Transaction.Input.LockTimeRange();\n  }\n  seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY));\n\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 \n  this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG;\n  return this;\n};\n\n/**\n * Sets sequence number so that transaction is not valid until the desired block height differnece since the tx is mined\n *\n * @param {Number} height\n * @return {Transaction} this\n */\nInput.prototype.lockUntilBlockHeight = function (heightDiff) {\n  $.checkArgument(_.isNumber(heightDiff));\n  if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {\n    throw new errors.Transaction.Input.BlockHeightOutOfRange();\n  }\n  // SEQUENCE_LOCKTIME_TYPE_FLAG = 0\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 0\n  this.sequenceNumber = heightDiff;\n  return this;\n};\n\n/**\n *  Returns a semantic version of the input's sequence nLockTime.\n *  @return {Number|Date}\n *  If sequence lock is disabled  it returns null,\n *  if is set to block height lock, returns a block height (number)\n *  else it returns a Date object.\n */\nInput.prototype.getLockTime = function () {\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return null;\n  }\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {\n    var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);\n    return seconds;\n  } else {\n    var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;\n    return blockHeight;\n  }\n};\nmodule.exports = Input;","map":{"version":3,"names":["_","require","$","errors","BufferWriter","buffer","BufferUtil","JSUtil","Script","Sighash","Output","MAXINT","DEFAULT_SEQNUMBER","DEFAULT_LOCKTIME_SEQNUMBER","DEFAULT_RBF_SEQNUMBER","SEQUENCE_LOCKTIME_DISABLE_FLAG","Math","pow","SEQUENCE_LOCKTIME_TYPE_FLAG","SEQUENCE_LOCKTIME_MASK","SEQUENCE_LOCKTIME_GRANULARITY","SEQUENCE_BLOCKDIFF_LIMIT","Input","params","_fromObject","Object","defineProperty","prototype","configurable","enumerable","get","isNull","_script","_scriptBuffer","_isInput","fromObject","obj","checkArgument","isObject","input","prevTxId","isString","isHexa","Buffer","from","witnesses","output","undefined","txidbuf","outputIndex","isUndefined","txoutnum","sequenceNumber","seqnum","script","scriptBuffer","Transaction","MissingScript","setScript","toObject","toJSON","toString","scriptString","fromBufferReader","br","readReverse","readUInt32LE","readVarLengthBuffer","toBufferWriter","writer","writeReverse","writeUInt32LE","writeVarintNum","length","write","toBuffer","isBuffer","TypeError","getSignatures","AbstractMethodInvoked","JSON","stringify","getSatoshisBuffer","checkState","_satoshisBN","writeUInt64LEBN","isFullySigned","isFinal","addSignature","clearSignatures","hasWitnesses","getWitnesses","setWitnesses","isValidSignature","transaction","signature","signingMethod","nhashtype","sigtype","verify","publicKey","inputIndex","_estimateSize","lockForSeconds","seconds","isNumber","LockTimeRange","parseInt","floor","lockUntilBlockHeight","heightDiff","BlockHeightOutOfRange","getLockTime","blockHeight","module","exports"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFG - Enginering/BLOCKTICK/blocktick_dApp/node_modules/bitcore-lib/lib/transaction/input/input.js"],"sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('../../util/preconditions');\nconst errors = require('../../errors');\nvar BufferWriter = require('../../encoding/bufferwriter');\nvar buffer = require('buffer');\nvar BufferUtil = require('../../util/buffer');\nvar JSUtil = require('../../util/js');\nvar Script = require('../../script');\nvar Sighash = require('../sighash');\nvar Output = require('../output');\n\nvar MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;\nvar DEFAULT_SEQNUMBER = MAXINT;\nvar DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;\nvar DEFAULT_RBF_SEQNUMBER = MAXINT - 2;\nconst SEQUENCE_LOCKTIME_DISABLE_FLAG =  Math.pow(2,31); // (1 << 31);\nconst SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2,22); // (1 << 22);\nconst SEQUENCE_LOCKTIME_MASK = 0xffff;\nconst SEQUENCE_LOCKTIME_GRANULARITY = 512; // 512 seconds\nconst SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2,16)-1; // 16 bits \n\n\nfunction Input(params) {\n  if (!(this instanceof Input)) {\n    return new Input(params);\n  }\n  if (params) {\n    return this._fromObject(params);\n  }\n}\n\nInput.MAXINT = MAXINT;\nInput.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;\nInput.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;\nInput.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;\nInput.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;\n\nObject.defineProperty(Input.prototype, 'script', {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    if (this.isNull()) {\n      return null;\n    }\n    if (!this._script) {\n      this._script = new Script(this._scriptBuffer);\n      this._script._isInput = true;\n    }\n    return this._script;\n  }\n});\n\nInput.fromObject = function(obj) {\n  $.checkArgument(_.isObject(obj));\n  var input = new Input();\n  return input._fromObject(obj);\n};\n\nInput.prototype._fromObject = function(params) {\n  var prevTxId;\n  if (_.isString(params.prevTxId) && JSUtil.isHexa(params.prevTxId)) {\n    prevTxId = Buffer.from(params.prevTxId, 'hex');\n  } else {\n    prevTxId = params.prevTxId;\n  }\n  this.witnesses = [];\n  this.output = params.output ?\n    (params.output instanceof Output ? params.output : new Output(params.output)) : undefined;\n  this.prevTxId = prevTxId || params.txidbuf;\n  this.outputIndex = _.isUndefined(params.outputIndex) ? params.txoutnum : params.outputIndex;\n  this.sequenceNumber = _.isUndefined(params.sequenceNumber) ?\n    (_.isUndefined(params.seqnum) ? DEFAULT_SEQNUMBER : params.seqnum) : params.sequenceNumber;\n  if (_.isUndefined(params.script) && _.isUndefined(params.scriptBuffer)) {\n    throw new errors.Transaction.Input.MissingScript();\n  }\n  this.setScript(params.scriptBuffer || params.script);\n  return this;\n};\n\nInput.prototype.toObject = Input.prototype.toJSON = function toObject() {\n  var obj = {\n    prevTxId: this.prevTxId.toString('hex'),\n    outputIndex: this.outputIndex,\n    sequenceNumber: this.sequenceNumber,\n    script: this._scriptBuffer.toString('hex'),\n  };\n  // add human readable form if input contains valid script\n  if (this.script) {\n    obj.scriptString = this.script.toString();\n  }\n  if (this.output) {\n    obj.output = this.output.toObject();\n  }\n  return obj;\n};\n\nInput.fromBufferReader = function(br) {\n  var input = new Input();\n  input.prevTxId = br.readReverse(32);\n  input.outputIndex = br.readUInt32LE();\n  input._scriptBuffer = br.readVarLengthBuffer();\n  input.sequenceNumber = br.readUInt32LE();\n  // TODO: return different classes according to which input it is\n  // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.\n  return input;\n};\n\nInput.prototype.toBufferWriter = function(writer) {\n  if (!writer) {\n    writer = new BufferWriter();\n  }\n  writer.writeReverse(this.prevTxId);\n  writer.writeUInt32LE(this.outputIndex);\n  var script = this._scriptBuffer;\n  writer.writeVarintNum(script.length);\n  writer.write(script);\n  writer.writeUInt32LE(this.sequenceNumber);\n  return writer;\n};\n\nInput.prototype.setScript = function(script) {\n  this._script = null;\n  if (script instanceof Script) {\n    this._script = script;\n    this._script._isInput = true;\n    this._scriptBuffer = script.toBuffer();\n  } else if (JSUtil.isHexa(script)) {\n    // hex string script\n    this._scriptBuffer = Buffer.from(script, 'hex');\n  } else if (_.isString(script)) {\n    // human readable string script\n    this._script = new Script(script);\n    this._script._isInput = true;\n    this._scriptBuffer = this._script.toBuffer();\n  } else if (BufferUtil.isBuffer(script)) {\n    // buffer script\n    this._scriptBuffer = Buffer.from(script);\n  } else {\n    throw new TypeError('Invalid argument type: script');\n  }\n  return this;\n};\n\n/**\n * Retrieve signatures for the provided PrivateKey.\n *\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key to use when signing\n * @param {number} inputIndex - the index of this input in the provided transaction\n * @param {number} sigType - defaults to Signature.SIGHASH_ALL\n * @param {Buffer} addressHash - if provided, don't calculate the hash of the\n *     public key associated with the private key provided\n * @abstract\n */\nInput.prototype.getSignatures = function() {\n  throw new errors.AbstractMethodInvoked(\n    'Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' +\n    ' for input: ' + JSON.stringify(this)\n  );\n};\n\nInput.prototype.getSatoshisBuffer = function() {\n  $.checkState(this.output instanceof Output);\n  $.checkState(this.output._satoshisBN);\n  return new BufferWriter().writeUInt64LEBN(this.output._satoshisBN).toBuffer();\n};\n\n\nInput.prototype.isFullySigned = function() {\n  throw new errors.AbstractMethodInvoked('Input#isFullySigned');\n};\n\nInput.prototype.isFinal = function() {\n  return this.sequenceNumber !== Input.MAXINT;\n};\n\nInput.prototype.addSignature = function() {\n  throw new errors.AbstractMethodInvoked('Input#addSignature');\n};\n\nInput.prototype.clearSignatures = function() {\n  throw new errors.AbstractMethodInvoked('Input#clearSignatures');\n};\n\nInput.prototype.hasWitnesses = function() {\n  if (this.witnesses && this.witnesses.length > 0) {\n    return true;\n  }\n  return false;\n};\n\nInput.prototype.getWitnesses = function() {\n  return this.witnesses;\n};\n\nInput.prototype.setWitnesses = function(witnesses) {\n  this.witnesses = witnesses;\n};\n\nInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  // FIXME: Refactor signature so this is not necessary\n  signingMethod = signingMethod || 'ecdsa';\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(\n    transaction,\n    signature.signature,\n    signature.publicKey,\n    signature.inputIndex,\n    this.output.script,\n    signingMethod\n  );\n};\n\n/**\n * @returns true if this is a coinbase input (represents no input)\n */\nInput.prototype.isNull = function() {\n  return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' &&\n    this.outputIndex === 0xffffffff;\n};\n\nInput.prototype._estimateSize = function() {\n  return this.toBufferWriter().toBuffer().length;\n};\n\n\n/**\n * Sets sequence number so that transaction is not valid until the desired seconds\n *  since the transaction is mined\n *\n * @param {Number} time in seconds\n * @return {Transaction} this\n */\nInput.prototype.lockForSeconds = function(seconds) {\n  $.checkArgument(_.isNumber(seconds));\n  if (seconds < 0 ||  seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {\n    throw new errors.Transaction.Input.LockTimeRange();\n  }\n  seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY));\n\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 \n  this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG ;\n  return this;\n};\n\n/**\n * Sets sequence number so that transaction is not valid until the desired block height differnece since the tx is mined\n *\n * @param {Number} height\n * @return {Transaction} this\n */\nInput.prototype.lockUntilBlockHeight = function(heightDiff) {\n  $.checkArgument(_.isNumber(heightDiff));\n  if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {\n    throw new errors.Transaction.Input.BlockHeightOutOfRange();\n  }\n  // SEQUENCE_LOCKTIME_TYPE_FLAG = 0\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 0\n  this.sequenceNumber = heightDiff ;\n  return this;\n};\n\n\n/**\n *  Returns a semantic version of the input's sequence nLockTime.\n *  @return {Number|Date}\n *  If sequence lock is disabled  it returns null,\n *  if is set to block height lock, returns a block height (number)\n *  else it returns a Date object.\n */\nInput.prototype.getLockTime = function() {\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return null;\n  }\n\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {\n    var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);\n    return seconds;\n  } else {\n    var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;\n    return blockHeight;\n  }\n};\n\n\n\n\nmodule.exports = Input;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}