{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar externals_1 = require(\"./externals\");\nvar bytes_1 = require(\"./bytes\");\nvar account_1 = require(\"./account\");\nvar Address = /** @class */function () {\n  function Address(buf) {\n    (0, assert_1.default)(buf.length === 20, 'Invalid address length');\n    this.buf = buf;\n  }\n  /**\r\n   * Returns the zero address.\r\n   */\n  Address.zero = function () {\n    return new Address((0, bytes_1.zeros)(20));\n  };\n  /**\r\n   * Returns an Address object from a hex-encoded string.\r\n   * @param str - Hex-encoded address\r\n   */\n  Address.fromString = function (str) {\n    (0, assert_1.default)((0, account_1.isValidAddress)(str), 'Invalid address');\n    return new Address((0, bytes_1.toBuffer)(str));\n  };\n  /**\r\n   * Returns an address for a given public key.\r\n   * @param pubKey The two points of an uncompressed key\r\n   */\n  Address.fromPublicKey = function (pubKey) {\n    (0, assert_1.default)(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n    var buf = (0, account_1.pubToAddress)(pubKey);\n    return new Address(buf);\n  };\n  /**\r\n   * Returns an address for a given private key.\r\n   * @param privateKey A private key must be 256 bits wide\r\n   */\n  Address.fromPrivateKey = function (privateKey) {\n    (0, assert_1.default)(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n    var buf = (0, account_1.privateToAddress)(privateKey);\n    return new Address(buf);\n  };\n  /**\r\n   * Generates an address for a newly created contract.\r\n   * @param from The address which is creating this new address\r\n   * @param nonce The nonce of the from account\r\n   */\n  Address.generate = function (from, nonce) {\n    (0, assert_1.default)(externals_1.BN.isBN(nonce));\n    return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\n  };\n  /**\r\n   * Generates an address for a contract created using CREATE2.\r\n   * @param from The address which is creating this new address\r\n   * @param salt A salt\r\n   * @param initCode The init code of the contract being created\r\n   */\n  Address.generate2 = function (from, salt, initCode) {\n    (0, assert_1.default)(Buffer.isBuffer(salt));\n    (0, assert_1.default)(Buffer.isBuffer(initCode));\n    return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n  };\n  /**\r\n   * Is address equal to another.\r\n   */\n  Address.prototype.equals = function (address) {\n    return this.buf.equals(address.buf);\n  };\n  /**\r\n   * Is address zero.\r\n   */\n  Address.prototype.isZero = function () {\n    return this.equals(Address.zero());\n  };\n  /**\r\n   * True if address is in the address range defined\r\n   * by EIP-1352\r\n   */\n  Address.prototype.isPrecompileOrSystemAddress = function () {\n    var addressBN = new externals_1.BN(this.buf);\n    var rangeMin = new externals_1.BN(0);\n    var rangeMax = new externals_1.BN('ffff', 'hex');\n    return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n  };\n  /**\r\n   * Returns hex encoding of address.\r\n   */\n  Address.prototype.toString = function () {\n    return '0x' + this.buf.toString('hex');\n  };\n  /**\r\n   * Returns Buffer representation of address.\r\n   */\n  Address.prototype.toBuffer = function () {\n    return Buffer.from(this.buf);\n  };\n  return Address;\n}();\nexports.Address = Address;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Address","assert_1","require","externals_1","bytes_1","account_1","buf","default","length","zero","zeros","fromString","str","isValidAddress","toBuffer","fromPublicKey","pubKey","Buffer","isBuffer","pubToAddress","fromPrivateKey","privateKey","privateToAddress","generate","from","nonce","BN","isBN","generateAddress","toArrayLike","generate2","salt","initCode","generateAddress2","prototype","equals","address","isZero","isPrecompileOrSystemAddress","addressBN","rangeMin","rangeMax","gte","lte","toString"],"sources":["C:/Users/Ndongo/Desktop/noborrar/Ethereum-Blocktick/node_modules/ethereumjs-util/dist.browser/address.js"],"sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Address = void 0;\r\nvar assert_1 = __importDefault(require(\"assert\"));\r\nvar externals_1 = require(\"./externals\");\r\nvar bytes_1 = require(\"./bytes\");\r\nvar account_1 = require(\"./account\");\r\nvar Address = /** @class */ (function () {\r\n    function Address(buf) {\r\n        (0, assert_1.default)(buf.length === 20, 'Invalid address length');\r\n        this.buf = buf;\r\n    }\r\n    /**\r\n     * Returns the zero address.\r\n     */\r\n    Address.zero = function () {\r\n        return new Address((0, bytes_1.zeros)(20));\r\n    };\r\n    /**\r\n     * Returns an Address object from a hex-encoded string.\r\n     * @param str - Hex-encoded address\r\n     */\r\n    Address.fromString = function (str) {\r\n        (0, assert_1.default)((0, account_1.isValidAddress)(str), 'Invalid address');\r\n        return new Address((0, bytes_1.toBuffer)(str));\r\n    };\r\n    /**\r\n     * Returns an address for a given public key.\r\n     * @param pubKey The two points of an uncompressed key\r\n     */\r\n    Address.fromPublicKey = function (pubKey) {\r\n        (0, assert_1.default)(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\r\n        var buf = (0, account_1.pubToAddress)(pubKey);\r\n        return new Address(buf);\r\n    };\r\n    /**\r\n     * Returns an address for a given private key.\r\n     * @param privateKey A private key must be 256 bits wide\r\n     */\r\n    Address.fromPrivateKey = function (privateKey) {\r\n        (0, assert_1.default)(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\r\n        var buf = (0, account_1.privateToAddress)(privateKey);\r\n        return new Address(buf);\r\n    };\r\n    /**\r\n     * Generates an address for a newly created contract.\r\n     * @param from The address which is creating this new address\r\n     * @param nonce The nonce of the from account\r\n     */\r\n    Address.generate = function (from, nonce) {\r\n        (0, assert_1.default)(externals_1.BN.isBN(nonce));\r\n        return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\r\n    };\r\n    /**\r\n     * Generates an address for a contract created using CREATE2.\r\n     * @param from The address which is creating this new address\r\n     * @param salt A salt\r\n     * @param initCode The init code of the contract being created\r\n     */\r\n    Address.generate2 = function (from, salt, initCode) {\r\n        (0, assert_1.default)(Buffer.isBuffer(salt));\r\n        (0, assert_1.default)(Buffer.isBuffer(initCode));\r\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\r\n    };\r\n    /**\r\n     * Is address equal to another.\r\n     */\r\n    Address.prototype.equals = function (address) {\r\n        return this.buf.equals(address.buf);\r\n    };\r\n    /**\r\n     * Is address zero.\r\n     */\r\n    Address.prototype.isZero = function () {\r\n        return this.equals(Address.zero());\r\n    };\r\n    /**\r\n     * True if address is in the address range defined\r\n     * by EIP-1352\r\n     */\r\n    Address.prototype.isPrecompileOrSystemAddress = function () {\r\n        var addressBN = new externals_1.BN(this.buf);\r\n        var rangeMin = new externals_1.BN(0);\r\n        var rangeMax = new externals_1.BN('ffff', 'hex');\r\n        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\r\n    };\r\n    /**\r\n     * Returns hex encoding of address.\r\n     */\r\n    Address.prototype.toString = function () {\r\n        return '0x' + this.buf.toString('hex');\r\n    };\r\n    /**\r\n     * Returns Buffer representation of address.\r\n     */\r\n    Address.prototype.toBuffer = function () {\r\n        return Buffer.from(this.buf);\r\n    };\r\n    return Address;\r\n}());\r\nexports.Address = Address;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}