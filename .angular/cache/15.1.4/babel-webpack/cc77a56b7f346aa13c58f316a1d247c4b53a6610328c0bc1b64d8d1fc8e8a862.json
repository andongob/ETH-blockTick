{"ast":null,"code":"const BigInteger = require('bigi');\nconst Buffer = require('safe-buffer').Buffer;\nconst ecurve = require('ecurve');\nconst curve = ecurve.getCurveByName('secp256k1');\nconst math = require('./math');\nconst check = require('./check');\nconst convert = require('./convert');\nconst concat = Buffer.concat;\nconst G = curve.G;\nconst p = curve.p;\nconst n = curve.n;\nconst zero = BigInteger.ZERO;\nfunction sign(privateKey, message, aux) {\n  // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#signing\n  check.checkSignParams(privateKey, message);\n  privateKey = typeof privateKey == 'string' ? BigInteger.fromHex(privateKey) : privateKey;\n  const P = G.multiply(privateKey);\n  const Px = convert.intToBuffer(P.affineX);\n  const d = math.getEvenKey(P, privateKey);\n  let kPrime;\n  if (aux) {\n    check.checkAux(aux);\n    const t = convert.intToBuffer(d.xor(convert.bufferToInt(math.taggedHash('BIP0340/aux', aux))));\n    const rand = math.taggedHash('BIP0340/nonce', concat([t, Px, message]));\n    kPrime = convert.bufferToInt(rand).mod(n);\n  } else {\n    kPrime = math.deterministicGetK0(d, Px, message);\n  }\n  if (kPrime.signum() === 0) {\n    throw new Error('kPrime is zero');\n  }\n  const R = G.multiply(kPrime);\n  const k = math.getEvenKey(R, kPrime);\n  const Rx = convert.intToBuffer(R.affineX);\n  const e = math.getE(Rx, Px, message);\n  return concat([Rx, convert.intToBuffer(k.add(e.multiply(d)).mod(n))]);\n}\nfunction verify(pubKey, message, signature) {\n  check.checkVerifyParams(pubKey, message, signature);\n\n  // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#verification\n  const P = math.liftX(pubKey);\n  const Px = convert.intToBuffer(P.affineX);\n  const r = convert.bufferToInt(signature.slice(0, 32));\n  const s = convert.bufferToInt(signature.slice(32, 64));\n  check.checkSignatureInput(r, s);\n  const e = math.getE(convert.intToBuffer(r), Px, message);\n  const R = math.getR(s, e, P);\n  if (R.curve.isInfinity(R) || !math.isEven(R) || !R.affineX.equals(r)) {\n    throw new Error('signature verification failed');\n  }\n}\nfunction batchVerify(pubKeys, messages, signatures) {\n  check.checkBatchVerifyParams(pubKeys, messages, signatures);\n\n  // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Batch_Verification\n  let leftSide = zero;\n  let rightSide = null;\n  for (let i = 0; i < pubKeys.length; i++) {\n    const P = math.liftX(pubKeys[i]);\n    const Px = convert.intToBuffer(P.affineX);\n    const r = convert.bufferToInt(signatures[i].slice(0, 32));\n    const s = convert.bufferToInt(signatures[i].slice(32, 64));\n    check.checkSignatureInput(r, s);\n    const e = math.getE(convert.intToBuffer(r), Px, messages[i]);\n    const R = math.liftX(signatures[i].slice(0, 32));\n    if (i === 0) {\n      leftSide = leftSide.add(s);\n      rightSide = R;\n      rightSide = rightSide.add(P.multiply(e));\n    } else {\n      const a = math.randomA();\n      leftSide = leftSide.add(a.multiply(s));\n      rightSide = rightSide.add(R.multiply(a));\n      rightSide = rightSide.add(P.multiply(a.multiply(e)));\n    }\n  }\n  if (!G.multiply(leftSide).equals(rightSide)) {\n    throw new Error('signature verification failed');\n  }\n}\nmodule.exports = {\n  sign,\n  verify,\n  batchVerify\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}