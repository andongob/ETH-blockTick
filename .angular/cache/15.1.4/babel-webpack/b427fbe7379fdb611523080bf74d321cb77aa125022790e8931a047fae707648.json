{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar externals_1 = require(\"./externals\");\nvar secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nvar internal_1 = require(\"./internal\");\nvar constants_1 = require(\"./constants\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\nvar helpers_1 = require(\"./helpers\");\nvar types_1 = require(\"./types\");\nvar Account = /** @class */function () {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  function Account(nonce, balance, stateRoot, codeHash) {\n    if (nonce === void 0) {\n      nonce = new externals_1.BN(0);\n    }\n    if (balance === void 0) {\n      balance = new externals_1.BN(0);\n    }\n    if (stateRoot === void 0) {\n      stateRoot = constants_1.KECCAK256_RLP;\n    }\n    if (codeHash === void 0) {\n      codeHash = constants_1.KECCAK256_NULL;\n    }\n    this.nonce = nonce;\n    this.balance = balance;\n    this.stateRoot = stateRoot;\n    this.codeHash = codeHash;\n    this._validate();\n  }\n  Account.fromAccountData = function (accountData) {\n    var nonce = accountData.nonce,\n      balance = accountData.balance,\n      stateRoot = accountData.stateRoot,\n      codeHash = accountData.codeHash;\n    return new Account(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : undefined, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : undefined, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : undefined, codeHash ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n  };\n  Account.fromRlpSerializedAccount = function (serialized) {\n    var values = externals_1.rlp.decode(serialized);\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n    return this.fromValuesArray(values);\n  };\n  Account.fromValuesArray = function (values) {\n    var _a = __read(values, 4),\n      nonce = _a[0],\n      balance = _a[1],\n      stateRoot = _a[2],\n      codeHash = _a[3];\n    return new Account(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);\n  };\n  Account.prototype._validate = function () {\n    if (this.nonce.lt(new externals_1.BN(0))) {\n      throw new Error('nonce must be greater than zero');\n    }\n    if (this.balance.lt(new externals_1.BN(0))) {\n      throw new Error('balance must be greater than zero');\n    }\n    if (this.stateRoot.length !== 32) {\n      throw new Error('stateRoot must have a length of 32');\n    }\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n  };\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n  Account.prototype.raw = function () {\n    return [(0, types_1.bnToUnpaddedBuffer)(this.nonce), (0, types_1.bnToUnpaddedBuffer)(this.balance), this.stateRoot, this.codeHash];\n  };\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n  Account.prototype.serialize = function () {\n    return externals_1.rlp.encode(this.raw());\n  };\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  Account.prototype.isContract = function () {\n    return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  Account.prototype.isEmpty = function () {\n    return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n  return Account;\n}();\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nvar isValidAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nvar toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  (0, helpers_1.assertIsHexString)(hexAddress);\n  var address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n  var prefix = '';\n  if (eip1191ChainId) {\n    var chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);\n    prefix = chainId.toString() + '0x';\n  }\n  var hash = (0, hash_1.keccakFromString)(prefix + address).toString('hex');\n  var ret = '0x';\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nvar isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nvar generateAddress = function (from, nonce) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(nonce);\n  var nonceBN = new externals_1.BN(nonce);\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return (0, hash_1.rlphash)([from, null]).slice(-20);\n  }\n  // Only take the lower 160bits of the hash\n  return (0, hash_1.rlphash)([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nvar generateAddress2 = function (from, salt, initCode) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(salt);\n  (0, helpers_1.assertIsBuffer)(initCode);\n  (0, assert_1.default)(from.length === 20);\n  (0, assert_1.default)(salt.length === 32);\n  var address = (0, hash_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, hash_1.keccak256)(initCode)]));\n  return address.slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nvar isValidPrivate = function (privateKey) {\n  return (0, secp256k1_1.privateKeyVerify)(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nvar isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  (0, helpers_1.assertIsBuffer)(publicKey);\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n  if (!sanitize) {\n    return false;\n  }\n  return (0, secp256k1_1.publicKeyVerify)(publicKey);\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nvar pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  (0, helpers_1.assertIsBuffer)(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));\n  }\n  (0, assert_1.default)(pubKey.length === 64);\n  // Only take the lower 160bits of the hash\n  return (0, hash_1.keccak)(pubKey).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nvar privateToPublic = function (privateKey) {\n  (0, helpers_1.assertIsBuffer)(privateKey);\n  // skip the type flag and use the X, Y points\n  return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nvar privateToAddress = function (privateKey) {\n  return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\nvar importPublic = function (publicKey) {\n  (0, helpers_1.assertIsBuffer)(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));\n  }\n  return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\nvar zeroAddress = function () {\n  var addressLength = 20;\n  var addr = (0, bytes_1.zeros)(addressLength);\n  return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\nvar isZeroAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  var zeroAddr = (0, exports.zeroAddress)();\n  return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress;","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","__importDefault","mod","__esModule","Object","defineProperty","exports","isZeroAddress","zeroAddress","importPublic","privateToAddress","privateToPublic","publicToAddress","pubToAddress","isValidPublic","isValidPrivate","generateAddress2","generateAddress","isValidChecksumAddress","toChecksumAddress","isValidAddress","Account","assert_1","require","externals_1","secp256k1_1","internal_1","constants_1","bytes_1","hash_1","helpers_1","types_1","nonce","balance","stateRoot","codeHash","BN","KECCAK256_RLP","KECCAK256_NULL","_validate","fromAccountData","accountData","toBuffer","undefined","fromRlpSerializedAccount","serialized","values","rlp","decode","Array","isArray","Error","fromValuesArray","_a","prototype","lt","length","raw","bnToUnpaddedBuffer","serialize","encode","isContract","equals","isEmpty","isZero","hexAddress","assertIsString","test","eip1191ChainId","assertIsHexString","address","stripHexPrefix","toLowerCase","prefix","chainId","toType","TypeOutput","toString","hash","keccakFromString","ret","parseInt","toUpperCase","from","assertIsBuffer","nonceBN","rlphash","slice","Buffer","toArray","salt","initCode","default","keccak256","concat","privateKey","privateKeyVerify","publicKey","sanitize","publicKeyVerify","pubKey","publicKeyConvert","keccak","publicKeyCreate","addressLength","addr","zeros","bufferToHex","zeroAddr"],"sources":["D:/Documentos/BLOCKCHAIN/Doble Grado BlockChain/Blockchain Engineering/TFG - Enginering/BLOCKTICK/blocktick_dApp/node_modules/ethereumjs-util/dist.browser/account.js"],"sourcesContent":["\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar externals_1 = require(\"./externals\");\nvar secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nvar internal_1 = require(\"./internal\");\nvar constants_1 = require(\"./constants\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\nvar helpers_1 = require(\"./helpers\");\nvar types_1 = require(\"./types\");\nvar Account = /** @class */ (function () {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */\n    function Account(nonce, balance, stateRoot, codeHash) {\n        if (nonce === void 0) { nonce = new externals_1.BN(0); }\n        if (balance === void 0) { balance = new externals_1.BN(0); }\n        if (stateRoot === void 0) { stateRoot = constants_1.KECCAK256_RLP; }\n        if (codeHash === void 0) { codeHash = constants_1.KECCAK256_NULL; }\n        this.nonce = nonce;\n        this.balance = balance;\n        this.stateRoot = stateRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    Account.fromAccountData = function (accountData) {\n        var nonce = accountData.nonce, balance = accountData.balance, stateRoot = accountData.stateRoot, codeHash = accountData.codeHash;\n        return new Account(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : undefined, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : undefined, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : undefined, codeHash ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n    };\n    Account.fromRlpSerializedAccount = function (serialized) {\n        var values = externals_1.rlp.decode(serialized);\n        if (!Array.isArray(values)) {\n            throw new Error('Invalid serialized account input. Must be array');\n        }\n        return this.fromValuesArray(values);\n    };\n    Account.fromValuesArray = function (values) {\n        var _a = __read(values, 4), nonce = _a[0], balance = _a[1], stateRoot = _a[2], codeHash = _a[3];\n        return new Account(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);\n    };\n    Account.prototype._validate = function () {\n        if (this.nonce.lt(new externals_1.BN(0))) {\n            throw new Error('nonce must be greater than zero');\n        }\n        if (this.balance.lt(new externals_1.BN(0))) {\n            throw new Error('balance must be greater than zero');\n        }\n        if (this.stateRoot.length !== 32) {\n            throw new Error('stateRoot must have a length of 32');\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error('codeHash must have a length of 32');\n        }\n    };\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */\n    Account.prototype.raw = function () {\n        return [\n            (0, types_1.bnToUnpaddedBuffer)(this.nonce),\n            (0, types_1.bnToUnpaddedBuffer)(this.balance),\n            this.stateRoot,\n            this.codeHash,\n        ];\n    };\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */\n    Account.prototype.serialize = function () {\n        return externals_1.rlp.encode(this.raw());\n    };\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */\n    Account.prototype.isContract = function () {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    };\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */\n    Account.prototype.isEmpty = function () {\n        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    };\n    return Account;\n}());\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nvar isValidAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nvar toChecksumAddress = function (hexAddress, eip1191ChainId) {\n    (0, helpers_1.assertIsHexString)(hexAddress);\n    var address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n    var prefix = '';\n    if (eip1191ChainId) {\n        var chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);\n        prefix = chainId.toString() + '0x';\n    }\n    var hash = (0, hash_1.keccakFromString)(prefix + address).toString('hex');\n    var ret = '0x';\n    for (var i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nvar isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nvar generateAddress = function (from, nonce) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(nonce);\n    var nonceBN = new externals_1.BN(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return (0, hash_1.rlphash)([from, null]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return (0, hash_1.rlphash)([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nvar generateAddress2 = function (from, salt, initCode) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(salt);\n    (0, helpers_1.assertIsBuffer)(initCode);\n    (0, assert_1.default)(from.length === 20);\n    (0, assert_1.default)(salt.length === 32);\n    var address = (0, hash_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, hash_1.keccak256)(initCode)]));\n    return address.slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nvar isValidPrivate = function (privateKey) {\n    return (0, secp256k1_1.privateKeyVerify)(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nvar isValidPublic = function (publicKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([Buffer.from([4]), publicKey]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return (0, secp256k1_1.publicKeyVerify)(publicKey);\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nvar pubToAddress = function (pubKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    (0, helpers_1.assertIsBuffer)(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));\n    }\n    (0, assert_1.default)(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return (0, hash_1.keccak)(pubKey).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nvar privateToPublic = function (privateKey) {\n    (0, helpers_1.assertIsBuffer)(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nvar privateToAddress = function (privateKey) {\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\nvar importPublic = function (publicKey) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));\n    }\n    return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\nvar zeroAddress = function () {\n    var addressLength = 20;\n    var addr = (0, bytes_1.zeros)(addressLength);\n    return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\nvar isZeroAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    var zeroAddr = (0, exports.zeroAddress)();\n    return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}