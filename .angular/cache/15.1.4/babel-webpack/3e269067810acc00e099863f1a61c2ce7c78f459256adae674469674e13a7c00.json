{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bech32m = exports.bech32 = void 0;\nconst ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst ALPHABET_MAP = {};\nfor (let z = 0; z < ALPHABET.length; z++) {\n  const x = ALPHABET.charAt(z);\n  ALPHABET_MAP[x] = z;\n}\nfunction polymodStep(pre) {\n  const b = pre >> 25;\n  return (pre & 0x1ffffff) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;\n}\nfunction prefixChk(prefix) {\n  let chk = 1;\n  for (let i = 0; i < prefix.length; ++i) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')';\n    chk = polymodStep(chk) ^ c >> 5;\n  }\n  chk = polymodStep(chk);\n  for (let i = 0; i < prefix.length; ++i) {\n    const v = prefix.charCodeAt(i);\n    chk = polymodStep(chk) ^ v & 0x1f;\n  }\n  return chk;\n}\nfunction convert(data, inBits, outBits, pad) {\n  let value = 0;\n  let bits = 0;\n  const maxV = (1 << outBits) - 1;\n  const result = [];\n  for (let i = 0; i < data.length; ++i) {\n    value = value << inBits | data[i];\n    bits += inBits;\n    while (bits >= outBits) {\n      bits -= outBits;\n      result.push(value >> bits & maxV);\n    }\n  }\n  if (pad) {\n    if (bits > 0) {\n      result.push(value << outBits - bits & maxV);\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding';\n    if (value << outBits - bits & maxV) return 'Non-zero padding';\n  }\n  return result;\n}\nfunction toWords(bytes) {\n  return convert(bytes, 8, 5, true);\n}\nfunction fromWordsUnsafe(words) {\n  const res = convert(words, 5, 8, false);\n  if (Array.isArray(res)) return res;\n}\nfunction fromWords(words) {\n  const res = convert(words, 5, 8, false);\n  if (Array.isArray(res)) return res;\n  throw new Error(res);\n}\nfunction getLibraryFromEncoding(encoding) {\n  let ENCODING_CONST;\n  if (encoding === 'bech32') {\n    ENCODING_CONST = 1;\n  } else {\n    ENCODING_CONST = 0x2bc830a3;\n  }\n  function encode(prefix, words, LIMIT) {\n    LIMIT = LIMIT || 90;\n    if (prefix.length + 7 + words.length > LIMIT) throw new TypeError('Exceeds length limit');\n    prefix = prefix.toLowerCase();\n    // determine chk mod\n    let chk = prefixChk(prefix);\n    if (typeof chk === 'string') throw new Error(chk);\n    let result = prefix + '1';\n    for (let i = 0; i < words.length; ++i) {\n      const x = words[i];\n      if (x >> 5 !== 0) throw new Error('Non 5-bit word');\n      chk = polymodStep(chk) ^ x;\n      result += ALPHABET.charAt(x);\n    }\n    for (let i = 0; i < 6; ++i) {\n      chk = polymodStep(chk);\n    }\n    chk ^= ENCODING_CONST;\n    for (let i = 0; i < 6; ++i) {\n      const v = chk >> (5 - i) * 5 & 0x1f;\n      result += ALPHABET.charAt(v);\n    }\n    return result;\n  }\n  function __decode(str, LIMIT) {\n    LIMIT = LIMIT || 90;\n    if (str.length < 8) return str + ' too short';\n    if (str.length > LIMIT) return 'Exceeds length limit';\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    const uppered = str.toUpperCase();\n    if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str;\n    str = lowered;\n    const split = str.lastIndexOf('1');\n    if (split === -1) return 'No separator character for ' + str;\n    if (split === 0) return 'Missing prefix for ' + str;\n    const prefix = str.slice(0, split);\n    const wordChars = str.slice(split + 1);\n    if (wordChars.length < 6) return 'Data too short';\n    let chk = prefixChk(prefix);\n    if (typeof chk === 'string') return chk;\n    const words = [];\n    for (let i = 0; i < wordChars.length; ++i) {\n      const c = wordChars.charAt(i);\n      const v = ALPHABET_MAP[c];\n      if (v === undefined) return 'Unknown character ' + c;\n      chk = polymodStep(chk) ^ v;\n      // not in the checksum?\n      if (i + 6 >= wordChars.length) continue;\n      words.push(v);\n    }\n    if (chk !== ENCODING_CONST) return 'Invalid checksum for ' + str;\n    return {\n      prefix,\n      words\n    };\n  }\n  function decodeUnsafe(str, LIMIT) {\n    const res = __decode(str, LIMIT);\n    if (typeof res === 'object') return res;\n  }\n  function decode(str, LIMIT) {\n    const res = __decode(str, LIMIT);\n    if (typeof res === 'object') return res;\n    throw new Error(res);\n  }\n  return {\n    decodeUnsafe,\n    decode,\n    encode,\n    toWords,\n    fromWordsUnsafe,\n    fromWords\n  };\n}\nexports.bech32 = getLibraryFromEncoding('bech32');\nexports.bech32m = getLibraryFromEncoding('bech32m');","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}